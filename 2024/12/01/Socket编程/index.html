<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Socket编程 | 星の夜</title><meta name="author" content="kyzenzu"><meta name="copyright" content="kyzenzu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在socket编程中有一个通用的结构体来表示通用的表示一个网络中某个主机的地址struct sockaddr 123456&#x2F;* 16字节 *&#x2F;struct sockaddr &#x2F;* socket_address *&#x2F;&#123;	sa_family_t sa_family; &#x2F;* 地址族协议(2字节) *&#x2F;	char sa_data[14]; &#x2F;* 端口(2字节) + IP地址(4字节) + 填充">
<meta property="og:type" content="article">
<meta property="og:title" content="Socket编程">
<meta property="og:url" content="http://example.com/2024/12/01/Socket%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="星の夜">
<meta property="og:description" content="在socket编程中有一个通用的结构体来表示通用的表示一个网络中某个主机的地址struct sockaddr 123456&#x2F;* 16字节 *&#x2F;struct sockaddr &#x2F;* socket_address *&#x2F;&#123;	sa_family_t sa_family; &#x2F;* 地址族协议(2字节) *&#x2F;	char sa_data[14]; &#x2F;* 端口(2字节) + IP地址(4字节) + 填充">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/12.jpg">
<meta property="article:published_time" content="2024-11-30T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-29T09:55:59.953Z">
<meta property="article:author" content="kyzenzu">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/12.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Socket编程",
  "url": "http://example.com/2024/12/01/Socket%E7%BC%96%E7%A8%8B/",
  "image": "http://example.com/img/cover/12.jpg",
  "datePublished": "2024-11-30T16:00:00.000Z",
  "dateModified": "2025-12-29T09:55:59.953Z",
  "author": [
    {
      "@type": "Person",
      "name": "kyzenzu",
      "url": "http://kyzenzu.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2024/12/01/Socket%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Socket编程',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div class="bg-animation" id="web_bg" style="background-image: url(/img/background/01.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover/12.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/loading.gif" data-original="/img/navlogo.png" alt="Logo"><span class="site-name">星の夜</span></a><a class="nav-page-title" href="/"><span class="site-name">Socket编程</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Socket编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-30T16:00:00.000Z" title="发表于 2024-12-01 00:00:00">2024-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-29T09:55:59.953Z" title="更新于 2025-12-29 17:55:59">2025-12-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><img src="/img/loading.gif" data-original="/../posts_img/Socket%E7%BC%96%E7%A8%8B/Socket%E6%B5%81%E7%A8%8B.gif" alt="00"></p>
<p>在<code>socket</code>编程中有一个通用的结构体来表示通用的表示一个网络中某个主机的地址<code>struct sockaddr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 16字节 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> /* <span class="title">socket_address</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family; <span class="comment">/* 地址族协议(2字节) */</span></span><br><span class="line">	<span class="type">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/* 端口(2字节) + IP地址(4字节) + 填充(8字节) */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个结构体可以表示所有类型的网络，包括<code>ipv4</code>。因为比较普遍，所以<code>socket</code>中的大部分<code>API</code>中有关主机地址的参数类型都是它。就像父类一样，用多态的方式使用。</p>
<p>此外，使用地址类型的参数时还会有个<code>socklen_t addrlen</code>参数和它配套使用，表示地址变量的大小(bytes)</p>
<p>因为现在大多用的是<code>ipv4</code>协议，所以专门有一个类型表示<code>ipv4</code>地址，它的内存大小与<code>struct sockaddr</code>完全一样，内存布局也相似，完全就是它的子类一样</p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/linux/socket/">套接字-Socket | 爱编程的大丙 (subingwen.cn)</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> s_addr;  <span class="comment">/* 32-bit IPv4 address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">socklen_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> /* <span class="title">socket_address_internet</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;		<span class="comment">/* 地址族协议(2字节): AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;         <span class="comment">/* 端口, 2字节-&gt; 大端  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">/* IP地址, 4字节 -&gt; 大端  */</span></span><br><span class="line">    <span class="comment">/* 填充 8字节 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用到的时候需要传入指针，并且还需要像多态一样将其强制类型转化为其父类的指针，此外还需要配套一个<code>socklen_t addrlen</code>表示其大小。就像下面这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span> <span class="comment">/* client address */</span></span><br><span class="line"><span class="type">socklen_t</span> cadlen = <span class="keyword">sizeof</span>(cad);</span><br><span class="line">accept(welcomeSocket, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br></pre></td></tr></table></figure>

<p>网络字节序要求是大端发送的，所以跟<code>socket</code>相关的结构体尤其是<code>struct sockaddr_in</code>里面的<code>port</code>和<code>ip</code>地址要求都是大端存储的。为了实现对整数大小端的自由转换提供了<strong>2</strong>组<strong>4</strong>个函数，分别处理<code>2</code>个字节和<code>4</code>个字节大小的数据的大小端转换。</p>
<p>使用套接字通信函数需要包含头文件<code>&lt;arpa/inet.h&gt;</code>，包含了这个头文件<code>&lt;sys/socket.h&gt;</code>就不用在包含了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这套api主要用于 网络通信过程中 IP 和 port 的大小端的转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个短整形从主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// host to net : short</span></span><br><span class="line"><span class="comment">// 将一个短整形从网络字节序 -&gt; 主机字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// net to host : short</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个整形从主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// host to net : long</span></span><br><span class="line"><span class="comment">// 将一个整形从网络字节序 -&gt; 主机字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>; <span class="comment">// net to host : long</span></span><br></pre></td></tr></table></figure>

<p><code>IP</code>地址一般都是点分十进制字符串形式出现的，但其本质上还是<code>32</code>位<code>4</code>字节大小的整数(<strong>对IPv4而言</strong>)，所以还提供了针对<code>IP</code>地址(包括<code>IPv4和IPv6</code>)字符串和整数的转换函数。<strong>值得注意的是，转换的整数(不管的作为参数还是返回结果)都应该是大端序存储的。</strong></p>
<p><strong><code>n</code></strong>: <strong>Network</strong>（网络格式，也就是二进制格式(<strong>大端序整数格式</strong>)，通常是大端序的表示方式）</p>
<p><strong><code>p</code></strong>: <strong>Presentation</strong>（<strong>文本格式</strong>，适合人类阅读的形式，如 <code>&quot;192.168.1.1&quot;</code>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将大端的整数, 转换为小端的点分十进制的IP地址字符串        </span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">参数:</span><br><span class="line">af: 地址族协议</span><br><span class="line">AF_INET: ipv4格式的ip地址</span><br><span class="line">AF_INET6: ipv6格式的ip地址</span><br><span class="line">src: 传入参数, 这个指针指向的内存中存储了大端的整形IP地址</span><br><span class="line">dst: 传出参数, 存储转换得到的小端的点分十进制的IP地址</span><br><span class="line">size: 修饰dst参数的, 标记dst指向的内存中最多可以存储多少个字节</span><br><span class="line">返回值:</span><br><span class="line">成功: 指针指向第三个参数对应的内存地址, 通过返回值也可以直接取出转换得到的IP字符串</span><br><span class="line">失败: <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将小端的点分十进制的IP地址字符串, 转换为大端的整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>; </span><br><span class="line">参数:</span><br><span class="line">af: 地址族(IP地址的家族包括ipv4和ipv6)协议</span><br><span class="line">	AF_INET: ipv4格式的ip地址</span><br><span class="line">	AF_INET6: ipv6格式的ip地址</span><br><span class="line">src: 传入参数, 对应要转换的点分十进制的ip地址: <span class="number">192.168</span>.<span class="number">1.100</span></span><br><span class="line">dst: 传出参数, 函数调用完成, 转换得到的大端整形IP被写入到这块内存中</span><br><span class="line">返回值：成功返回<span class="number">1</span>，失败返回<span class="number">0</span>或者<span class="number">-1</span></span><br></pre></td></tr></table></figure>



<hr>
<p><img src="/img/loading.gif" data-original="/../posts_img/Socket%E7%BC%96%E7%A8%8B/TCP-Socket%E7%BC%96%E7%A8%8B.png" alt="01"></p>
<p>客户端通过命令行向服务器发送数据，按下回车后会将换行符一起发送给服务器。可能是<code>\r\n</code>也可能是<code>\n</code>视操作系统不同吧</p>
<p>客户端代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* SERVER_IP_ADDRESS = <span class="string">&quot;192.168.66.142&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> SERVER_PORT = <span class="number">8080</span>;</span><br><span class="line">    <span class="type">uint32_t</span> SERVER_IP;</span><br><span class="line">    inet_pton(AF_INET, SERVER_IP_ADDRESS, &amp;SERVER_IP);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* server address */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sad, <span class="number">0</span>, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    sad.sin_family = AF_INET;</span><br><span class="line">    sad.sin_port = htons(SERVER_PORT);</span><br><span class="line">    sad.sin_addr.s_addr = SERVER_IP;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (clientSocket == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;clientSocket创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = connect(clientSocket, (<span class="keyword">struct</span> sockaddr*)&amp;sad, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;与服务器建立连接失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d: Hello World\n&quot;</span>, i++);</span><br><span class="line">        send(clientSocket, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>, <span class="number">0</span>); <span class="comment">/* 如果内核中写缓冲区满了会阻塞 */</span></span><br><span class="line">        <span class="comment">/* write(clientSocket, buf, strlen(buf)+1) */</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf)); <span class="comment">/* 发送完了就清空准备用于接收 */</span></span><br><span class="line">        <span class="type">int</span> len = recv(clientSocket, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>); <span class="comment">/* 如果内核中读缓冲区为空会阻塞 */</span></span><br><span class="line">        <span class="comment">/* read(clientSocket, buf, sizeof(buf)) */</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器: %s&quot;</span>, buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">&quot;从服务器接收数据失败&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(clientSocket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* server address */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sad, <span class="number">0</span>, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    sad.sin_family = AF_INET;</span><br><span class="line">    sad.sin_port = htons(PORT);</span><br><span class="line">    sad.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> welcomeSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (welcomeSocket == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;welcomeSocket创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = bind(welcomeSocket, (<span class="keyword">struct</span> sockaddr*)&amp;sad, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;welcomeSocket绑定失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = listen(welcomeSocket, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;监听失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span> <span class="comment">/* client address */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;cad, <span class="number">0</span>, <span class="keyword">sizeof</span>(cad));</span><br><span class="line">    <span class="type">socklen_t</span> cadlen = <span class="keyword">sizeof</span>(cad);</span><br><span class="line">    <span class="type">int</span> connectionSocket = accept(welcomeSocket, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen); <span class="comment">/* 如果连接请求队列为空会阻塞 */</span></span><br><span class="line">    <span class="keyword">if</span> (connectionSocket == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;与客户端建立连接失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cip[<span class="number">32</span>]; <span class="comment">/* client ip */</span></span><br><span class="line">    inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cport = ntohs(cad.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;与客户端[%s:%d]建立连接成功\n&quot;</span>, cip, cport);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = recv(connectionSocket, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>); <span class="comment">/* 如果内核中读缓冲区为空会阻塞 */</span></span><br><span class="line">        <span class="comment">/* read(connectionSocket, buf, sizeof(buf)) */</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端: %s&quot;</span>, buf);</span><br><span class="line">            send(connectionSocket, buf, len, <span class="number">0</span>); <span class="comment">/* 如果内核中写缓冲区满了会阻塞 */</span></span><br><span class="line">            <span class="comment">/* write(connectionSocket, buf, len) */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">&quot;从客户端接收数据失败&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(welcomeSocket);</span><br><span class="line">    close(connectionSocket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>多线程简单高并发服务器端代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNCONNECTED -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_CLIENTS 128</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> connectionSocket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client</span> <span class="title">clients</span>[<span class="title">NR_CLIENTS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">client</span>* <span class="title">client</span> =</span> (<span class="keyword">struct</span> client*)arg;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cip[<span class="number">32</span>]; <span class="comment">/* client ip */</span></span><br><span class="line">    inet_ntop(AF_INET, &amp;client-&gt;address.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cport = ntohs(client-&gt;address.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;与客户端[%s:%d]连接成功\n&quot;</span>, cip, cport);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = recv(client-&gt;connectionSocket, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端[%s:%d]: %s&quot;</span>, cip, cport, buf);</span><br><span class="line">            send(client-&gt;connectionSocket, buf, len, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端[%s:%d]断开连接\n&quot;</span>, cip, cport);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> error[<span class="number">128</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(error, <span class="string">&quot;从客户端[%s:%d]接收数据失败&quot;</span>, cip, cport);</span><br><span class="line">            perror(error);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(client-&gt;connectionSocket);</span><br><span class="line">    <span class="built_in">memset</span>(client, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> client));</span><br><span class="line">    client-&gt;connectionSocket = UNCONNECTED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CLIENTS; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;clients[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> client));</span><br><span class="line">        clients[i].connectionSocket = UNCONNECTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sad, <span class="number">0</span>, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    sad.sin_family = AF_INET;</span><br><span class="line">    sad.sin_port = htons(PORT);</span><br><span class="line">    sad.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> welcomeSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (welcomeSocket == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;welcomeSocket创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = bind(welcomeSocket, (<span class="keyword">struct</span> sockaddr*)&amp;sad, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;welcomeSocket绑定失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = listen(welcomeSocket, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;监听失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">client</span>* <span class="title">client</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clients[i].connectionSocket == UNCONNECTED) &#123;</span><br><span class="line">                client = &amp;clients[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!client) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> socket = accept(welcomeSocket, (<span class="keyword">struct</span> sockaddr*)&amp;client-&gt;address, &amp;addrlen);</span><br><span class="line">        client-&gt;connectionSocket = socket;</span><br><span class="line">        <span class="keyword">if</span> (socket == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;与客户端建立连接失败&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, client);</span><br><span class="line">        pthread_detach(tid); <span class="comment">/* 子线程与主线程分离，不会阻塞主线程，由操作系统回收子线程 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(welcomeSocket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>IO多路复用</strong>有三种方式：<code>select</code>、<code>poll</code>、<code>epoll</code></p>
<p>其中只有<code>select</code>是可以跨平台的，<code>poll</code>和<code>epoll</code>只支持<code>Linux</code></p>
<p><code>select</code>和<code>poll</code>底层实现是线性表，<code>epoll</code>底层实现是红黑树。从效率上来看，<code>epoll</code>的事件驱动效率会高于其它两个</p>
<p><code>select</code>有上限限制，默认 1024。其它两个没有限制</p>
<p>用<code>select</code>实现<strong>IO多路复用</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval * timeout)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">大于0：成功，返回集合中已就绪的文件描述符的总个数</span></span><br><span class="line"><span class="comment">等于-1：函数调用失败</span></span><br><span class="line"><span class="comment">等于0：超时，没有检测到就绪的文件描述符</span></span><br><span class="line"><span class="comment">注意：这个函数在给定的fd集合中没有检测到就绪的文件描述符时是会阻塞的，除非设置了timeout</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件描述符fd从set集合中删除 == 将fd对应的标志位设置为0        </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 判断文件描述符fd是否在set集合中 == 读一下fd对应的标志位到底是0还是1</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将文件描述符fd添加到set集合中 == 将fd对应的标志位设置为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将set集合中, 所有文件文件描述符对应的标志位设置为0, 集合中没有添加任何文件描述符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>服务器代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_CLIENTS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGSIZE 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFDS(fd) (fd+1) <span class="comment">/* 根据下标获取fd的个数 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* listen_fd */</span></span><br><span class="line">	<span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;lfd创建失败&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化本地地址 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = htons(PORT);</span><br><span class="line">	addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 绑定socket和addr */</span></span><br><span class="line">	res = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;lfd绑定失败&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 在lfd上监听,数组大小设置为128 */</span></span><br><span class="line">	listen(lfd, NR_CLIENTS);</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;监听失败&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建文件描述符位图(集合) */</span></span><br><span class="line">	fd_set read_set; <span class="comment">/* 1024位,128字节*/</span></span><br><span class="line">	<span class="comment">/* 清零read_set */</span></span><br><span class="line">	FD_ZERO(&amp;read_set);</span><br><span class="line">	<span class="comment">/* 将lfd对应标志位设置为1 */</span></span><br><span class="line">	FD_SET(lfd, &amp;read_set);</span><br><span class="line"></span><br><span class="line">	fd_set write_set; <span class="comment">/* 写集合 */</span></span><br><span class="line">	fd_set except_set; <span class="comment">/* 异常集合 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span> <span class="comment">/* select()的最后一个参数的结构体 */</span></span><br><span class="line">	time.tv_sec = <span class="number">0</span>;</span><br><span class="line">	time.tv_usec = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>* <span class="title">timeval</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* max_fd */</span></span><br><span class="line">	<span class="type">int</span> mfd = lfd;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		fd_set temp_set = read_set;</span><br><span class="line">		<span class="type">int</span> res = select(NFDS(mfd), &amp;temp_set, &amp;write_set, &amp;except_set, timeval);</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line">		<span class="type">socklen_t</span> cadlen = <span class="keyword">sizeof</span>(cad);</span><br><span class="line">		<span class="built_in">memset</span>(&amp;cad, <span class="number">0</span>, <span class="keyword">sizeof</span>(cad));</span><br><span class="line">		<span class="type">char</span> cip[<span class="number">32</span>];</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cport;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 判断lfd读缓冲区是否有数据 */</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(lfd, &amp;temp_set)) &#123;</span><br><span class="line">			<span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">			FD_SET(cfd, &amp;read_set);	 <span class="comment">/* 将cfd对应标志位设置为1 */</span></span><br><span class="line">			mfd = cfd &gt; mfd ? cfd : mfd; <span class="comment">/* 每次更新最大的fd */</span></span><br><span class="line">			inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">			cport = ntohs(cad.sin_port);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;与客户端[%s:%d]连接成功\n&quot;</span>, cip, cport);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> fd = <span class="number">0</span>; fd &lt; NFDS(mfd); fd++) &#123;</span><br><span class="line">			<span class="comment">/* 不是lfd且fd读缓冲区内有数据 */</span></span><br><span class="line">			<span class="keyword">if</span> (fd != lfd &amp;&amp; FD_ISSET(fd, &amp;temp_set)) &#123;</span><br><span class="line">				<span class="type">unsigned</span> <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">				<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* 获取客户端地址 */</span></span><br><span class="line">				res = getpeername(fd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">				<span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="type">char</span> error[MSGSIZE];</span><br><span class="line">					<span class="built_in">sprintf</span>(error, <span class="string">&quot;fd:%d获取客户端地址失败&quot;</span>, fd);</span><br><span class="line">					perror(error);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/* 设置客户端ip和port */</span></span><br><span class="line">				inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">				cport = ntohs(cad.sin_port);</span><br><span class="line">				<span class="comment">/* 接收数据 */</span></span><br><span class="line">				<span class="type">int</span> len = recv(fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="type">char</span> error[MSGSIZE];</span><br><span class="line">					<span class="built_in">sprintf</span>(error, <span class="string">&quot;与客户端[%s:%d]接收数据失败&quot;</span>, cip, cport);</span><br><span class="line">					perror(error);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="type">char</span> message[MSGSIZE];</span><br><span class="line">					<span class="built_in">sprintf</span>(message, <span class="string">&quot;与客户端[%s:%d]断开连接\n&quot;</span>, cip, cport);</span><br><span class="line">					<span class="built_in">printf</span>(message);</span><br><span class="line">					FD_CLR(fd, &amp;read_set);</span><br><span class="line">					close(fd);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;客户端[%s:%d]: %s&quot;</span>, cip, cport, buf);</span><br><span class="line">				<span class="comment">/* 转换成大写字母 */</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">					buf[i] &amp;= <span class="number">0xdf</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/* 发送数据 */</span></span><br><span class="line">				res = send(fd, buf, len, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="type">char</span> error[MSGSIZE];</span><br><span class="line">					<span class="built_in">sprintf</span>(error, <span class="string">&quot;向客户端[%s:%d]发送数据失败&quot;</span>, cip, cport);</span><br><span class="line">					perror(error);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	close (lfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>select</code>函数是将传入参数当传出参数来用，也就是说它会修改原来的参数。<code>read_set</code>是我们用来记录有效<code>fd</code>的所以不能被传进去轻易的被修改，所以需要创建一个它的拷贝副本<code>temp_set</code>传进去，然后从这个临时变量中读取想要的数据。</p>
<p>用<code>select</code>实现的<strong>IO多路复用</strong>核心思想就是操作系统提供一个函数给你，你把要遍历的文件描述符统一交给操作系统，操作系统会统一检查这些文件描述符的缓冲区里有没有数据(这里以读缓冲区为例)，再把缓冲区中有数据的文件描述符筛选出来返回给你。这样我们只需要遍历这些确定有数据的文件描述符调用<code>read()</code>来读取数据就可以了，不需要像原来一样把所有文件描述都调用一遍<code>read()</code>，造成当前线程的在某个文件描述符上堵塞，以及避免一些切换到内核区所需要的资源开销的浪费。</p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/linux/select/">IO多路转接（复用）之select | 爱编程的大丙 (subingwen.cn)</a></p>
<hr>
<p><code>poll</code>和<code>select</code>的原理差不多，都是由操作系统统一检查文件描述符的缓冲区，返回就绪的文件描述符，避免用户调用<code>read()</code>造成的当前进程的阻塞和切换到内核去的资源开销浪费。</p>
<p>但是和<code>select</code>不同的是，<code>select</code>操作的是位图，而<code>poll</code>会针对每一个<code>pollfd</code>数组内元素预留的<code>events</code>来根据文件描述符读写缓冲区的实际情况设置对应的<code>revents</code>来表示函数返回的结果。</p>
<p>出于跨平台和效率的考虑，一般不会选择<code>poll</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 每个委托poll检测的fd都对应这样一个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* 文件描述符实际发生的事件 -&gt; 传出 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>[100];</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">/* 传进去pollfd的数组、数组内有效fd的个数、超时时间(单位为毫秒) */</span></span><br><span class="line"><span class="comment">/* timeout设置为-1函数就会一直阻塞 */</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://subingwen.cn/linux/poll/">IO多路转接（复用）之poll | 爱编程的大丙 (subingwen.cn)</a></p>
<hr>
<p><strong>epoll(eventpoll)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数会创建一个<code>epoll树</code>或者说一个<code>epoll</code>实例，因为一个进程中可以不止创建一个<code>epoll</code>实例，所以这个函数会返回一个整数用于标识此次创建的<code>epoll</code>实例。这个整数其实就是一个文件描述符，这个标识某个<code>epoll</code>实例的文件描述符也会在当前进程的文件描述符表中占据一个位置。所以在不使用某个<code>epoll</code>实例后需要<code>close(epfd)</code>来归还文件描述符，释放资源。</p>
<ul>
<li>函数参数 size：在Linux内核2.6.8版本以后，这个参数是被忽略的，只需要指定一个大于0的数值就可以了。</li>
<li>函数返回值：<ul>
<li>失败：返回-1</li>
<li>成功：返回一个有效的文件描述符，通过这个文件描述符就可以访问创建的<code>epoll</code>实例了</li>
</ul>
</li>
</ul>
<p><code>epoll</code>的实例本质上是一颗红黑树。树节点的具体实现是<code>struct epitem</code>，源码有些复杂</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">llink</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span> <span class="comment">/* fd存储在这里面 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">/* event,注意是结构体不是结构体指针 */</span></span><br><span class="line">    u64 data;</span><br><span class="line">    u64 data1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是可供用户操作成员变量就是<code>fd</code>和<code>event</code>。或者说这个结构体的重点就是这两个，干脆抽象成这两个好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------------+</span><br><span class="line">|      fd      |</span><br><span class="line">+--------------+</span><br><span class="line">|     event    |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>

<p><code>fd</code>，是文件描述符，也就是个整数，没什么好说的，<code>event</code>的具体实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">	<span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* events标注这个节点的事件是读事件还是写事件,分别对应操作系统是检查这个fd的读缓冲区还是写缓冲区 */</span></span><br><span class="line"><span class="comment">/* data相当于是这个节点的事件是一个备注,因为epoll_wait()函数传出的是结构体struct epoll_event,光凭这个无法判断这个事件是哪个fd的,所以在事件envent里除了标明属性还需要打上备注 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合体, 多个变量共用同一块内存   </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line"> 	<span class="type">void</span>        *ptr;</span><br><span class="line">	<span class="type">int</span>          fd;	<span class="comment">// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可</span></span><br><span class="line">	<span class="type">uint32_t</span>     u32;</span><br><span class="line">	<span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>epoll_ctl()</code>函数的作用是管理红黑树实例上的节点，可以进行添加、删除、修改操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure>

<p>函数参数：</p>
<ul>
<li><code>epfd</code>：<code>epoll_create()</code> 函数的返回值，通过这个参数找到<code>epoll</code>实例</li>
<li><code>op</code>：这是一个枚举值，控制通过该函数执行什么操作<ul>
<li><code>EPOLL_CTL_ADD</code>：往<code>epoll</code>模型中添加新的节点</li>
<li><code>EPOLL_CTL_MOD</code>：修改<code>epoll</code>模型中已经存在的节点</li>
<li><code>EPOLL_CTL_DEL</code>：删除<code>epoll</code>模型中的指定的节点</li>
</ul>
</li>
<li><code>fd</code>：文件描述符，即要添加&#x2F;修改&#x2F;删除的文件描述符</li>
<li><code>event</code>：<code>epoll</code>事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件<ul>
<li><code>events</code>：委托<code>epoll</code>检测的事件<ul>
<li><code>EPOLLIN</code>：读事件, 接收数据, 检测读缓冲区，如果有数据该文件描述符就绪</li>
<li><code>EPOLLOUT</code>：写事件, 发送数据, 检测写缓冲区，如果可写该文件描述符就绪</li>
<li><code>EPOLLERR</code>：异常事件</li>
</ul>
</li>
<li><code>data</code>：用户数据变量，这是一个联合体类型，通常情况下使用里边的fd成员，用于存储待检测的文件描述符的值，在调用<code>epoll_wait()</code>函数的时候这个值会被传出。</li>
</ul>
</li>
<li>函数返回值：<br>  失败：返回<code>-1</code><br>  成功：返回<code>0</code></li>
</ul>
<p>需要注意的是，用<code>epoll_ctl()</code>函数做添加操作的时候，虽然传进去的事件是以指针的方式传进去的，但是真正创建节点，设置节点的<code>event</code>时采用的是拷贝的方式，源码是下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">epi-&gt;event = *event; <span class="comment">/* epi即epoll-item */</span></span><br></pre></td></tr></table></figure>

<p>所以会看到下面的代码只会定义一个<code>event</code>当作公共变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>函数参数：</p>
<ul>
<li><code>epfd</code>：e<code>poll_create()</code> 函数的返回值, 通过这个参数找到epoll实例</li>
<li><code>events</code>：传出参数, 这是一个结构体数组的地址, 里边存储了已就绪的文件描述符的信息</li>
<li><code>maxevents</code>：修饰第二个参数, 结构体数组的容量（元素个数）</li>
<li><code>timeout</code>：如果检测的epoll实例中没有已就绪的文件描述符，该函数阻塞的时长, 单位ms 毫秒<ul>
<li>0：函数不阻塞，不管epoll实例中有没有就绪的文件描述符，函数被调用后都直接返回</li>
<li>大于0：如果epoll实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回</li>
<li>-1：函数一直阻塞，直到epoll实例中有已就绪的文件描述符之后才解除阻塞</li>
</ul>
</li>
<li>函数返回值：<ul>
<li>成功：<ul>
<li>等于0：函数是阻塞被强制解除了, 没有检测到满足条件的文件描述符</li>
<li>大于0：检测到的已就绪的文件描述符的总个数</li>
</ul>
</li>
<li>失败：返回-1</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/linux/epoll/">IO多路转接（复用）之epoll | 爱编程的大丙 (subingwen.cn)</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_CLIENTS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVSSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGSIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置服务器本地地址 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建lfd作为监听socket */</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 绑定addr到lfd上 */</span></span><br><span class="line">    res = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd绑定失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 开始在lfd上监听,数组大小设置为128 */</span></span><br><span class="line">    res = listen(lfd, NR_CLIENTS);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd监听失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个epoll树 */</span></span><br><span class="line">    <span class="type">int</span> epoll = epoll_create(EPOLL);</span><br><span class="line">    <span class="keyword">if</span> (epoll == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建公共变量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EVSSIZE</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cadlen = <span class="keyword">sizeof</span>(cad);</span><br><span class="line">    <span class="type">char</span> cip[<span class="number">32</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cport;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加lfd到epoll中 */</span></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epoll, EPOLL_CTL_ADD, lfd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> event_count = epoll_wait(epoll, events, EVSSIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; event_count; i++) &#123;</span><br><span class="line">            <span class="type">int</span> fd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (fd == lfd) &#123;</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">                <span class="comment">/* 设置事件和添加cfd到epoll上 */</span></span><br><span class="line">                event.events = EPOLLIN;</span><br><span class="line">                event.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epoll, EPOLL_CTL_ADD, cfd, &amp;event);</span><br><span class="line">                inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">			    cport = ntohs(cad.sin_port);</span><br><span class="line">			    <span class="built_in">printf</span>(<span class="string">&quot;与客户端[%s:%d]连接成功\n&quot;</span>, cip, cport);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf)); </span><br><span class="line">                <span class="comment">/* 获取客户端地址 */</span></span><br><span class="line">                res = getpeername(fd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">                <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="type">char</span> error[MSGSIZE];</span><br><span class="line">                    <span class="built_in">sprintf</span>(error, <span class="string">&quot;fd:%d获取客户端地址失败&quot;</span>, fd);</span><br><span class="line">                    perror(error);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 设置客户端ip和port */</span></span><br><span class="line">                inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">                cport = ntohs(cad.sin_port);</span><br><span class="line">                <span class="comment">/* 接收数据 */</span></span><br><span class="line">				<span class="type">int</span> len = recv(fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);  </span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="type">char</span> error[MSGSIZE];</span><br><span class="line">                    <span class="built_in">sprintf</span>(error, <span class="string">&quot;与客户端[%s:%d]接收数据失败&quot;</span>, cip, cport);</span><br><span class="line">                    perror(error);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">char</span> message[MSGSIZE];</span><br><span class="line">                    <span class="built_in">sprintf</span>(message, <span class="string">&quot;与客户端[%s:%d]断开连接\n&quot;</span>, cip, cport);</span><br><span class="line">                    <span class="built_in">printf</span>(message);</span><br><span class="line">                    epoll_ctl(epoll, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(fd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;客户端[%s:%d]: %s&quot;</span>, cip, cport, buf);</span><br><span class="line">                <span class="comment">/* 转换成大写字母 */</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">					buf[i] &amp;= <span class="number">0xdf</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">/* 发送数据 */</span></span><br><span class="line">				res = send(fd, buf, len, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="type">char</span> error[MSGSIZE];</span><br><span class="line">					<span class="built_in">sprintf</span>(error, <span class="string">&quot;向客户端[%s:%d]发送数据失败&quot;</span>, cip, cport);</span><br><span class="line">					perror(error);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(epoll);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>触发模式是针对<code>epoll</code>树里的某个节点的，或者说某个节点的<code>event</code></p>
<p>水平触发模式：代码里的<code>buf</code>就这么大，每次读取不能将文件描述符的读缓冲区里数据全部读完，这样在下次循环检测的时候，这个文件描述符的读缓冲区仍然会被标记为就绪状态，且仍然从上次没读取完的数据开始读取。对于写缓冲区来说，只要写缓冲区不是满的就是就绪状态，<code>epoll</code>每次都会发送通知。</p>
<p>边沿触发模式：代码里的<code>buf</code>就这么大，如果这次没有将读缓冲区里的数据全部读完，在下次循环中<code>epoll</code>不会再把这个缓冲区标记为就绪状态，也不会返回通知，只有当下一条数据从客户端接收到，这个读缓冲区才会被标记为就绪状态。对于写缓冲区来说，一开始空的，<code>epoll</code>标记为就绪状态，只返回这一次通知，后面即使写缓冲区没满也不会通知，下次通知只有在写缓冲区从满到不满，写缓冲区才会被标记为就绪返回通知。</p>
<p>对于读缓冲区来说：</p>
<ul>
<li>水平触发模式(默认)：只要缓冲区内数据没有读完，就会被标记为就绪，在下次检测时会返回通知</li>
<li>边沿触发模式：只有当新的数据到达时，才会被标记为就绪，在下次检测时返回通知</li>
</ul>
<p>对于写缓冲区来说：</p>
<ul>
<li>水平触发模式(默认)：只要缓冲区内还没有写满，就会被标记为就绪，在下次检测时会返回通知</li>
<li>边沿触发模式：只有当缓冲区从满到不满，或者一开始就是不满时才会被标记为就绪，在下次检测时返回通知</li>
</ul>
<p><code>recv()</code>函数能否调用，能否读取内核中读缓冲区的数据，这与<code>epoll</code>或者说<code>IO多路复用</code>的返回值无关，真正能决定<code>recv()</code>函数还能不能继续读下去的应该是缓冲区本身有记录的接收到的字节数这个成员变量。但是每次调用<code>recv()</code>函数的开销是很大的，什么时候调用，而让<code>recv()</code>每次都能读取到数据，不会跑空，不会因此而阻塞，换句话说我们在调用<code>recv()</code>函数前就需要知道读缓冲区的情况才能更好的决定是否要调用<code>recv()</code>函数。内核提供的<code>IO多路复用</code>就是为此而存在的，像<code>select()</code>、<code>epoll_wait()</code>这样的函数，就能够让内核在内核态中检测各个读缓冲区的情况，再返回通知告诉我们哪些<code>socket</code>的缓冲区是有数据的，让我们可以挑这些有数据的缓冲区去高效地调用<code>recv()</code>。而让内核决定是否对某个缓冲区返回通知，这就是两种触发模式地区别。</p>
<p>边沿触发模式代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_CLIENTS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVSSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGSIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置服务器本地地址 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建lfd作为监听socket */</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 绑定addr到lfd上 */</span></span><br><span class="line">    res = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd绑定失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 开始在lfd上监听,数组大小设置为128 */</span></span><br><span class="line">    res = listen(lfd, NR_CLIENTS);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd监听失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个epoll树 */</span></span><br><span class="line">    <span class="type">int</span> epoll = epoll_create(EPOLL);</span><br><span class="line">    <span class="keyword">if</span> (epoll == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建公共变量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EVSSIZE</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cadlen = <span class="keyword">sizeof</span>(cad);</span><br><span class="line">    <span class="type">char</span> cip[<span class="number">32</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cport;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加lfd到epoll中 */</span></span><br><span class="line">    event.events = EPOLLIN | EPOLLET; <span class="comment">/* 将这个监听节点设置为边沿触发模式 */</span></span><br><span class="line">    event.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epoll, EPOLL_CTL_ADD, lfd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> event_count = epoll_wait(epoll, events, EVSSIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; event_count; i++) &#123;</span><br><span class="line">            <span class="type">int</span> fd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (fd == lfd) &#123;</span><br><span class="line">                <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">                <span class="comment">/* 设置cfd为非阻塞属性 */</span></span><br><span class="line">                <span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">                flag |= O_NONBLOCK;</span><br><span class="line">                fcntl(cfd, F_SETFL, flag);</span><br><span class="line">                <span class="comment">/* 设置事件和添加cfd到epoll上 */</span></span><br><span class="line">                event.events = EPOLLIN | EPOLLET;</span><br><span class="line">                event.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epoll, EPOLL_CTL_ADD, cfd, &amp;event);</span><br><span class="line">                inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">			    cport = ntohs(cad.sin_port);</span><br><span class="line">			    <span class="built_in">printf</span>(<span class="string">&quot;与客户端[%s:%d]连接成功\n&quot;</span>, cip, cport);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">                <span class="comment">/* 获取客户端地址 */</span></span><br><span class="line">                res = getpeername(fd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">                <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="type">char</span> error[MSGSIZE];</span><br><span class="line">                    <span class="built_in">sprintf</span>(error, <span class="string">&quot;fd:%d获取客户端地址失败&quot;</span>, fd);</span><br><span class="line">                    perror(error);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 设置客户端ip和port */</span></span><br><span class="line">                inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">                cport = ntohs(cad.sin_port);</span><br><span class="line">                <span class="comment">/* 接收数据 */</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">				    <span class="type">int</span> len = recv(fd, buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">/* 如果读缓冲区空了,或者文件描述符失效了返回recv()返回-1</span></span><br><span class="line"><span class="comment">                        如果客户端发出了断开连接请求,recv()函数返回0</span></span><br><span class="line"><span class="comment">                        如果客户端正常通信发送字节流,recv()函数返回已经读入buf的字节数    </span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="type">char</span> error[MSGSIZE];</span><br><span class="line">                        <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;数据接收完毕...\n&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">char</span> message[MSGSIZE];</span><br><span class="line">                        <span class="built_in">sprintf</span>(message, <span class="string">&quot;与客户端[%s:%d]断开连接\n&quot;</span>, cip, cport);</span><br><span class="line">                        <span class="built_in">printf</span>(message);</span><br><span class="line">                        epoll_ctl(epoll, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">                        close(fd);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端[%s:%d]: %s&quot;</span>, cip, cport, buf);</span><br><span class="line">                    <span class="comment">/* 转换成大写字母 */</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                        buf[i] &amp;= <span class="number">0xdf</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* 发送数据 */</span></span><br><span class="line">                    res = send(fd, buf, len, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="type">char</span> error[MSGSIZE];</span><br><span class="line">                        <span class="built_in">sprintf</span>(error, <span class="string">&quot;向客户端[%s:%d]发送数据失败&quot;</span>, cip, cport);</span><br><span class="line">                        perror(error);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(epoll);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于边沿触发模式的多线程代码</p>
<p>每次有新连接时会创建一个线程，建立连接后线程马上就会销毁</p>
<p>在已经建立的连接上，如果客户端发来数据，就会创建一个线程，处理完数据后线程马上销毁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_CLIENTS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVSSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGSIZE 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATASIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">accept_t</span> <span class="title">accept_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">accept_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> lfd;</span><br><span class="line">    <span class="type">int</span> epoll;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">acceptance</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">accept_t</span>* args = (<span class="type">accept_t</span>*)arg;</span><br><span class="line">    <span class="type">int</span> lfd = args-&gt;lfd;</span><br><span class="line">    <span class="type">int</span> epoll = args-&gt;epoll;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cadlen = <span class="keyword">sizeof</span>(cad);</span><br><span class="line">    <span class="type">char</span> cip[<span class="number">32</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cport;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">    <span class="comment">/* 设置cfd为非阻塞属性 */</span></span><br><span class="line">    <span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    fcntl(cfd, F_SETFL, flag);</span><br><span class="line">    <span class="comment">/* 设置事件和添加cfd到epoll上 */</span></span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    event.data.fd = cfd;</span><br><span class="line">    epoll_ctl(epoll, EPOLL_CTL_ADD, cfd, &amp;event);</span><br><span class="line">    inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">	cport = ntohs(cad.sin_port);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;与客户端[%s:%d]连接成功\n&quot;</span>, cip, cport);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(args);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">commu_t</span> <span class="title">commu_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">commu_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> epoll;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">communication</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">commu_t</span>* args = (<span class="type">commu_t</span>*)arg;</span><br><span class="line">    <span class="type">int</span> fd = args-&gt;fd;</span><br><span class="line">    <span class="type">int</span> epoll = args-&gt;epoll;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cadlen = <span class="keyword">sizeof</span>(cad);</span><br><span class="line">    <span class="type">char</span> cip[<span class="number">32</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> cport;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取客户端地址 */</span></span><br><span class="line">    <span class="type">int</span> res = getpeername(fd, (<span class="keyword">struct</span> sockaddr*)&amp;cad, &amp;cadlen);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> error[MSGSIZE];</span><br><span class="line">        <span class="built_in">sprintf</span>(error, <span class="string">&quot;fd:%d获取客户端地址失败&quot;</span>, fd);</span><br><span class="line">        perror(error);</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 设置客户端ip和port */</span></span><br><span class="line">    inet_ntop(AF_INET, &amp;cad.sin_addr.s_addr, cip, <span class="keyword">sizeof</span>(cip));</span><br><span class="line">    cport = ntohs(cad.sin_port);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[DATASIZE];</span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="comment">/* 接收数据 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	    <span class="type">int</span> len = recv(fd, buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* 如果读缓冲区空了,或者文件描述符失效了返回recv()返回-1</span></span><br><span class="line"><span class="comment">            如果客户端发出了断开连接请求,recv()函数返回0</span></span><br><span class="line"><span class="comment">            如果客户端正常通信发送字节流,recv()函数返回已经读入buf的字节数    </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> error[MSGSIZE];</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;数据接收完毕...\n&quot;</span>);</span><br><span class="line">                <span class="comment">/* 发送数据 */</span></span><br><span class="line">                res = send(fd, data, <span class="built_in">strlen</span>(data) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">sprintf</span>(error, <span class="string">&quot;向客户端[%s:%d]发送数据失败&quot;</span>, cip, cport);</span><br><span class="line">                    perror(error);</span><br><span class="line">                    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span> message[MSGSIZE];</span><br><span class="line">            <span class="built_in">sprintf</span>(message, <span class="string">&quot;与客户端[%s:%d]断开连接\n&quot;</span>, cip, cport);</span><br><span class="line">            <span class="built_in">printf</span>(message);</span><br><span class="line">            epoll_ctl(epoll, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端[%s:%d]: %s&quot;</span>, cip, cport, buf);</span><br><span class="line">        <span class="comment">/* 转换成大写字母 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            buf[i] &amp;= <span class="number">0xdf</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strncat</span>(data+<span class="built_in">strlen</span>(data), buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(args);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> PORT = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置服务器本地地址 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建lfd作为监听socket */</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 绑定addr到lfd上 */</span></span><br><span class="line">    res = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd绑定失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 开始在lfd上监听,数组大小设置为128 */</span></span><br><span class="line">    res = listen(lfd, NR_CLIENTS);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lfd监听失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个epoll树 */</span></span><br><span class="line">    <span class="type">int</span> epoll = epoll_create(EPOLL);</span><br><span class="line">    <span class="keyword">if</span> (epoll == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建公共变量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EVSSIZE</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加lfd到epoll中 */</span></span><br><span class="line">    event.events = EPOLLIN | EPOLLET; <span class="comment">/* 将这个监听节点设置为边沿触发模式 */</span></span><br><span class="line">    event.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epoll, EPOLL_CTL_ADD, lfd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> event_count = epoll_wait(epoll, events, EVSSIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; event_count; i++) &#123;</span><br><span class="line">            <span class="type">int</span> fd = events[i].data.fd;</span><br><span class="line">            <span class="type">pthread_t</span> tid;</span><br><span class="line">            <span class="keyword">if</span> (fd == lfd) &#123;</span><br><span class="line">                <span class="type">accept_t</span>* arg = (<span class="type">accept_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">accept_t</span>));</span><br><span class="line">                arg-&gt;lfd = lfd;</span><br><span class="line">                arg-&gt;epoll = epoll;</span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, acceptance, arg);</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">commu_t</span>* arg = (<span class="type">commu_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">commu_t</span>));</span><br><span class="line">                arg-&gt;fd = fd;</span><br><span class="line">                arg-&gt;epoll = epoll;</span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, communication, arg);</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(epoll);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>在 Windows 和 Linux 下进行套接字编程时，所需的头文件有所不同。以下是对比分析：</p>
<hr>
<h3 id="1-Windows-下的头文件"><a href="#1-Windows-下的头文件" class="headerlink" title="1. Windows 下的头文件"></a><strong>1. Windows 下的头文件</strong></h3><p>Windows 使用的是 Winsock（Windows Sockets）API，所需头文件如下：</p>
<h4 id="必要的头文件"><a href="#必要的头文件" class="headerlink" title="必要的头文件"></a><strong>必要的头文件</strong></h4><ul>
<li><strong><code>&lt;winsock2.h&gt;</code></strong><br>  提供基本的套接字函数和数据结构，例如 <code>socket()</code>、<code>bind()</code>、<code>listen()</code>、<code>connect()</code>、<code>recv()</code>、<code>send()</code>、<code>closesocket()</code> 等。</li>
<li><strong><code>&lt;ws2tcpip.h&gt;</code></strong><br>  提供对现代网络协议（如 IPv6）和功能（如 <code>getaddrinfo()</code>、<code>inet_ntop()</code>）的支持。</li>
</ul>
<h4 id="额外头文件"><a href="#额外头文件" class="headerlink" title="额外头文件"></a><strong>额外头文件</strong></h4><ul>
<li><strong><code>&lt;windows.h&gt;</code></strong><br>  如果程序涉及到其他 Windows API 功能（如多线程、事件等），可能需要包含。</li>
</ul>
<h4 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a><strong>库文件</strong></h4><ul>
<li>需要链接 <code>Ws2_32.lib</code>，可以通过 <code>#pragma comment(lib, &quot;Ws2_32.lib&quot;)</code> 指令自动链接，或在项目设置中手动添加。</li>
</ul>
<hr>
<h3 id="2-Linux-下的头文件"><a href="#2-Linux-下的头文件" class="headerlink" title="2. Linux 下的头文件"></a><strong>2. Linux 下的头文件</strong></h3><p>Linux 使用的是 POSIX 套接字 API，头文件更简洁：</p>
<h4 id="必要的头文件-1"><a href="#必要的头文件-1" class="headerlink" title="必要的头文件"></a><strong>必要的头文件</strong></h4><ul>
<li><strong><code>&lt;arpa/inet.h&gt;</code></strong><br>  提供 IP 地址的转换函数，例如 <code>inet_pton()</code> 和 <code>inet_ntop()</code>。还包含了<code>&lt;sys/socket.h&gt;</code>和<code>&lt;netinet/in.h&gt;</code>。这个头文件可能是基于下面这两个头文件制作的，所以包含了这个头文件就不需要包含下面两个头文件了。</li>
<li><strong><code>&lt;sys/socket.h&gt;</code></strong><br>  提供套接字函数和数据结构，例如 <code>socket()</code>、<code>bind()</code>、<code>listen()</code>、<code>accept()</code>、<code>connect()</code> 等。</li>
<li><strong><code>&lt;netinet/in.h&gt;</code></strong><br>  提供与网络地址相关的结构（如 <code>sockaddr_in</code>）和常量（如 <code>INADDR_ANY</code>、<code>htons()</code>）。</li>
<li><strong><code>&lt;unistd.h&gt;</code></strong><br>  提供 POSIX 接口的常规函数，例如 <code>close()</code>，用于关闭套接字。</li>
</ul>
<h4 id="额外头文件-1"><a href="#额外头文件-1" class="headerlink" title="额外头文件"></a><strong>额外头文件</strong></h4><ul>
<li><strong><code>&lt;netdb.h&gt;</code></strong><br>  提供主机名解析的函数，例如 <code>getaddrinfo()</code> 和 <code>gethostbyname()</code>。</li>
</ul>
<hr>
<h3 id="Windows-和-Linux-的头文件对比表"><a href="#Windows-和-Linux-的头文件对比表" class="headerlink" title="Windows 和 Linux 的头文件对比表"></a><strong>Windows 和 Linux 的头文件对比表</strong></h3><table>
<thead>
<tr>
<th>功能</th>
<th>Windows 头文件</th>
<th>Linux 头文件</th>
</tr>
</thead>
<tbody><tr>
<td>基本套接字函数</td>
<td><code>&lt;winsock2.h&gt;</code></td>
<td><code>&lt;sys/socket.h&gt;</code></td>
</tr>
<tr>
<td>地址族、协议、常量定义</td>
<td><code>&lt;winsock2.h&gt;</code></td>
<td><code>&lt;netinet/in.h&gt;</code></td>
</tr>
<tr>
<td>地址转换函数</td>
<td><code>&lt;ws2tcpip.h&gt;</code></td>
<td><code>&lt;arpa/inet.h&gt;</code></td>
</tr>
<tr>
<td>主机名解析</td>
<td><code>&lt;ws2tcpip.h&gt;</code></td>
<td><code>&lt;netdb.h&gt;</code></td>
</tr>
<tr>
<td>关闭套接字函数</td>
<td><code>&lt;winsock2.h&gt;</code></td>
<td><code>&lt;unistd.h&gt;</code></td>
</tr>
<tr>
<td>系统通用功能</td>
<td><code>&lt;windows.h&gt;</code></td>
<td><code>&lt;unistd.h&gt;</code> (POSIX)</td>
</tr>
</tbody></table>
<h3 id="3-使用差异"><a href="#3-使用差异" class="headerlink" title="3. 使用差异"></a><strong>3. 使用差异</strong></h3><h4 id="1-closesocket-和-close"><a href="#1-closesocket-和-close" class="headerlink" title="1) closesocket() 和 close()"></a><strong>1) <code>closesocket()</code> 和 <code>close()</code></strong></h4><ul>
<li>Windows 下：套接字关闭需要用 <code>closesocket()</code>，因为套接字是特定于 Winsock 的资源。</li>
<li>Linux 下：直接使用 <code>close()</code> 函数，因为套接字被视为文件描述符。</li>
</ul>
<h4 id="2-初始化与清理"><a href="#2-初始化与清理" class="headerlink" title="2) 初始化与清理"></a><strong>2) 初始化与清理</strong></h4><ul>
<li>Windows：<ul>
<li>必须在使用任何网络功能前调用 <code>WSAStartup()</code> 初始化 Winsock。</li>
<li>使用完套接字后调用 <code>WSACleanup()</code> 进行清理。</li>
</ul>
</li>
<li>Linux：<ul>
<li>不需要专门的初始化或清理操作，直接使用套接字 API。</li>
</ul>
</li>
</ul>
<h4 id="3-错误处理"><a href="#3-错误处理" class="headerlink" title="3) 错误处理"></a><strong>3) 错误处理</strong></h4><ul>
<li><strong>Windows</strong>：使用 <code>WSAGetLastError()</code> 获取错误码。</li>
<li><strong>Linux</strong>：错误通过 <code>errno</code> 提供，使用 <code>perror()</code> 或 <code>strerror()</code> 打印。</li>
</ul>
<hr>
<h3 id="4-示例对比"><a href="#4-示例对比" class="headerlink" title="4. 示例对比"></a><strong>4. 示例对比</strong></h3><p>以下是 Windows 和 Linux 下一个简单的 TCP 客户端的代码示例，展示如何使用这些头文件。</p>
<h4 id="Windows-示例"><a href="#Windows-示例" class="headerlink" title="Windows 示例"></a><strong>Windows 示例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    SOCKET sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Winsock</span></span><br><span class="line">    <span class="keyword">if</span> (WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (sock == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Socket creation failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置服务器地址</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(<span class="number">80</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;93.184.216.34&quot;</span>, &amp;server.sin_addr); <span class="comment">// www.example.com 的 IP 地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connection failed: %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        closesocket(sock);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connected successfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字和清理</span></span><br><span class="line">    closesocket(sock);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Linux-示例"><a href="#Linux-示例" class="headerlink" title="Linux 示例"></a><strong>Linux 示例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置服务器地址</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(<span class="number">80</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;93.184.216.34&quot;</span>, &amp;server.sin_addr); <span class="comment">// www.example.com 的 IP 地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Connection failed&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connected successfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>Windows</th>
<th>Linux</th>
</tr>
</thead>
<tbody><tr>
<td><strong>头文件</strong></td>
<td><code>&lt;winsock2.h&gt;</code>, <code>&lt;ws2tcpip.h&gt;</code></td>
<td><code>&lt;arpa/inet.h&gt;</code></td>
</tr>
<tr>
<td><strong>库文件</strong></td>
<td>必须链接 <code>Ws2_32.lib</code></td>
<td>无需额外库</td>
</tr>
<tr>
<td><strong>关闭套接字</strong></td>
<td><code>closesocket()</code></td>
<td><code>close()</code></td>
</tr>
<tr>
<td><strong>初始化</strong></td>
<td>必须调用 <code>WSAStartup()</code></td>
<td>无需初始化</td>
</tr>
<tr>
<td><strong>错误处理</strong></td>
<td>使用 <code>WSAGetLastError()</code></td>
<td>使用 <code>errno</code></td>
</tr>
</tbody></table>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ai_flags;           <span class="comment">// 标志，提供额外的选项</span></span><br><span class="line">    <span class="type">int</span> ai_family;          <span class="comment">// 地址族（如 AF_INET 或 AF_INET6）</span></span><br><span class="line">    <span class="type">int</span> ai_socktype;        <span class="comment">// 套接字类型（如 SOCK_STREAM 或 SOCK_DGRAM）</span></span><br><span class="line">    <span class="type">int</span> ai_protocol;        <span class="comment">// 协议类型（如 IPPROTO_TCP 或 IPPROTO_UDP）</span></span><br><span class="line">    <span class="type">size_t</span> ai_addrlen;      <span class="comment">// 地址的长度（单位：字节）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span> <span class="comment">// 指向具体地址的指针</span></span><br><span class="line">    <span class="type">char</span> *ai_canonname;     <span class="comment">// 主机的规范名（可选）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span> <span class="comment">// 指向下一个 addrinfo 的指针（用于链表）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接 Ws2_32.lib</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">char</span> ipstr[INET6_ADDRSTRLEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Winsock</span></span><br><span class="line">    result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStartup failed: %d\n&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *hostname = <span class="string">&quot;36.155.132.76&quot;</span>; <span class="comment">// 主机名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *service = <span class="literal">NULL</span>;            <span class="comment">// 服务名 (也可以直接指定端口号，如 &quot;80&quot;)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">res</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 hints</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = AF_UNSPEC;    <span class="comment">// 支持 IPv4 和 IPv6</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// 使用 TCP</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取地址信息</span></span><br><span class="line">    result = getaddrinfo(hostname, service, &amp;hints, &amp;res);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getaddrinfo failed: %s\n&quot;</span>, gai_strerror(result));</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IP addresses for www.baidu.com:\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 遍历地址链表</span></span><br><span class="line">    <span class="keyword">for</span> (p = res; p != <span class="literal">NULL</span>; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="type">void</span> *addr;</span><br><span class="line">        <span class="type">char</span> *ipver;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取地址（区分 IPv4 和 IPv6）</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;ai_family == AF_INET) &#123; <span class="comment">// IPv4</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">ipv4</span> =</span> (<span class="keyword">struct</span> sockaddr_in *)p-&gt;ai_addr;</span><br><span class="line">            addr = &amp;(ipv4-&gt;sin_addr);</span><br><span class="line">            ipver = <span class="string">&quot;IPv4&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// IPv6</span></span><br><span class="line">            <span class="keyword">struct</span> sockaddr_in6 *ipv6 = (<span class="keyword">struct</span> sockaddr_in6 *)p-&gt;ai_addr;</span><br><span class="line">            addr = &amp;(ipv6-&gt;sin6_addr);</span><br><span class="line">            ipver = <span class="string">&quot;IPv6&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换 IP 地址为字符串并打印</span></span><br><span class="line">        inet_ntop(p-&gt;ai_family, addr, ipstr, <span class="keyword">sizeof</span>(ipstr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %s: %s\n&quot;</span>, ipver, ipstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放地址链表</span></span><br><span class="line">    freeaddrinfo(res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 Winsock</span></span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="http://kyzenzu.github.io">kyzenzu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/12/01/Socket%E7%BC%96%E7%A8%8B/">http://example.com/2024/12/01/Socket编程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">星の夜</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/12.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/2024/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/" title="数据库系统概论"><img class="cover" src="/img/loading.gif" data-original="/img/cover/18.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">数据库系统概论</div></div></div></a><a class="pagination-related  no-desc" href="/2024/11/29/libcurl%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/" title="libcurl示例代码"><img class="cover" src="/img/loading.gif" data-original="/img/cover/05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">libcurl示例代码</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2024/06/20/%E3%80%90%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E6%A6%82%E8%BF%B0/" title="【中科大计算机网络】概述"><img class="cover" src="/img/loading.gif" data-original="/img/cover/04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-20</div><div class="info-item-2">【中科大计算机网络】概述</div></div></div></a><a class="pagination-related no-desc" href="/2024/07/21/%E3%80%90%E4%B8%AD%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AF%87/" title="【中科大计算机网络】网络安全"><img class="cover" src="/img/loading.gif" data-original="/img/cover/07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-21</div><div class="info-item-2">【中科大计算机网络】网络安全</div></div></div></a><a class="pagination-related no-desc" href="/2024/07/10/gcc%E5%92%8Cg++%E7%9A%84%E5%8C%BA%E5%88%AB/" title="gcc和g++的区别"><img class="cover" src="/img/loading.gif" data-original="/img/cover/10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-10</div><div class="info-item-2">gcc和g++的区别</div></div></div></a><a class="pagination-related no-desc" href="/2024/08/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="线程池"><img class="cover" src="/img/loading.gif" data-original="/img/cover/13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-27</div><div class="info-item-2">线程池</div></div></div></a><a class="pagination-related no-desc" href="/2023/04/01/C++%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" title="C++移动语义"><img class="cover" src="/img/loading.gif" data-original="/img/cover/08.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-01</div><div class="info-item-2">C++移动语义</div></div></div></a><a class="pagination-related no-desc" href="/2024/07/17/gdb%E7%9A%84%E4%BD%BF%E7%94%A8/" title="gdb的使用"><img class="cover" src="/img/loading.gif" data-original="/img/cover/08.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-17</div><div class="info-item-2">gdb的使用</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">kyzenzu</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kyzenzu"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">没有最新通知</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Windows-%E4%B8%8B%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">1. Windows 下的头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%85%E8%A6%81%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">必要的头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">额外头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%93%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">库文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Linux-%E4%B8%8B%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">2. Linux 下的头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%85%E8%A6%81%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6-1"><span class="toc-number">2.1.</span> <span class="toc-text">必要的头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E5%A4%B4%E6%96%87%E4%BB%B6-1"><span class="toc-number">2.2.</span> <span class="toc-text">额外头文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-%E5%92%8C-Linux-%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">Windows 和 Linux 的头文件对比表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%B7%AE%E5%BC%82"><span class="toc-number">4.</span> <span class="toc-text">3. 使用差异</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-closesocket-%E5%92%8C-close"><span class="toc-number">4.1.</span> <span class="toc-text">1) closesocket() 和 close()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">2) 初始化与清理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">3) 错误处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A4%BA%E4%BE%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">5.</span> <span class="toc-text">4. 示例对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows-%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.1.</span> <span class="toc-text">Windows 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.2.</span> <span class="toc-text">Linux 示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">5. 总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/29/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="哈工大操作系统"><img src="/img/loading.gif" data-original="/img/cover/15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="哈工大操作系统"/></a><div class="content"><a class="title" href="/2025/12/29/%E5%93%88%E5%B7%A5%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="哈工大操作系统">哈工大操作系统</a><time datetime="2025-12-28T16:00:00.000Z" title="发表于 2025-12-29 00:00:00">2025-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/02/call%E5%92%8Cleave%E5%92%8Cret/" title="call和leave和ret"><img src="/img/loading.gif" data-original="/img/cover/08.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="call和leave和ret"/></a><div class="content"><a class="title" href="/2025/10/02/call%E5%92%8Cleave%E5%92%8Cret/" title="call和leave和ret">call和leave和ret</a><time datetime="2025-10-01T16:00:00.000Z" title="发表于 2025-10-02 00:00:00">2025-10-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/01/Linux%E7%AE%A1%E7%90%86%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F/" title="Linux管理打开文件的方式"><img src="/img/loading.gif" data-original="/img/cover/19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux管理打开文件的方式"/></a><div class="content"><a class="title" href="/2025/08/01/Linux%E7%AE%A1%E7%90%86%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F/" title="Linux管理打开文件的方式">Linux管理打开文件的方式</a><time datetime="2025-07-31T16:00:00.000Z" title="发表于 2025-08-01 00:00:00">2025-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/" title="数据库系统概论"><img src="/img/loading.gif" data-original="/img/cover/18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库系统概论"/></a><div class="content"><a class="title" href="/2024/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/" title="数据库系统概论">数据库系统概论</a><time datetime="2024-12-28T16:00:00.000Z" title="发表于 2024-12-29 00:00:00">2024-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/01/Socket%E7%BC%96%E7%A8%8B/" title="Socket编程"><img src="/img/loading.gif" data-original="/img/cover/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Socket编程"/></a><div class="content"><a class="title" href="/2024/12/01/Socket%E7%BC%96%E7%A8%8B/" title="Socket编程">Socket编程</a><time datetime="2024-11-30T16:00:00.000Z" title="发表于 2024-12-01 00:00:00">2024-12-01</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By kyzenzu</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/js/tw_cn.js?v=5.5.3"></script><script src="/"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>